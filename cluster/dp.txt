1,"POJ3030-Nasty Hacks_Annie de blog_百度空间

Description
You are the CEO of Nasty Hacks Inc., a company that creates small pieces of malicious software which teenagers may use
to fool their friends. The company has just finished their first product and it is time to sell it. You want to make as much money as possible and consider advertising in order to increase sales. You get an analyst to predict the expected revenue, both with and without advertising. You now want to make a decision as to whether you should advertise or not, given the expected revenues.
Input
The input consists of n cases, and the first line consists of one positive integer giving n. The next n lines each contain 3 integers, r, e and c. The first, r, is the expected revenue if you do not advertise, the second, e, is the expected revenue if you do advertise, and the third, c, is the cost of advertising. You can assume that the input will follow these restrictions: −106 ≤ r, e ≤ 106 and 0 ≤ c ≤ 106.
Output
Output one line for each test case: “advertise”, “do not advertise” or “does not matter”, presenting whether it is most profitable to advertise or not, or whether it does not make any difference.
Sample Input
3

0 100 70

100 130 30

-100 -70 40

Sample Output
advertise

does not matter

do not advertise

Source Code

  #include<stdio.h>
 
main()
 
{int i;
 
long a[3],k;
 
scanf(""%d"",&i);
 
while(i)
 
{scanf(""%ld%ld%ld"",&a[0],&a[1],&a[2]);
 
k=a[1]-a[2];
 
if(a[0]<k) printf(""advertise\n"");
 
else if(a[0]==k) printf(""does not matter\n"");
 
else printf(""do not advertise\n"");
 
i--;}
 
}
"
11,"poj1182 食物链和poj1988 cube stacking类似（并查集的经典应用）_Keep  Moving_百度空间

#include   <iostream>
using   namespace std;
const int maxn = 50005;
int set[maxn],kind[maxn];
void   ready(int n)
{
    for(int   i=0;i<=n;i++) {set[i] = i;kind[i]=0;}
}
int find(int a)
{
   if(set[a]!=a)
   {
      int t = set[a];
      set[a] = find(set[a]);
      kind[a] = (kind[a]+kind[t])%3;//和cube stacking一样 kind[]就像其上面有多少个。。。//次步也不太好想
   }     
   return set[a];
}
/*void UNION(int a,int b,int k)
{
 set[b] = 
}*/
int main()
{
int i,j,k,n,m,a,b;
scanf(""%d%d"",&n,&m);
ready(n);
int count = 0;
for(i=0;i<m;i++)
{
scanf(""%d%d%d"",&k,&a,&b);
 if(a>n||b>n) count++;
    else if(k==2&&(a==b)) {count++;}
     else {
        int aa = find(a);
        int bb = find(b);
        if(aa==bb)
          {
                  if(k==2&&(kind[b]-kind[a]+3)%3!=1) count++;//次步不好想啊。。。
                  if(k==1&&kind[a]!=kind[b]) count++;   
          }
          else
          {
             kind[bb] =(kind[a]-kind[b]+3+k-1)%3;
             set[bb] = aa; 
          }
          } 
}
printf(""%d\n"",count);
//system(""pause"");
return 0;     
}
//本题算法参考各个大牛的博客才写成。。。
//本题和poj1988cube stacking中的查找极像，只是本题是类型，就加个取模。。。。
//详解见http://hi.baidu.com/flabbyan/blog/item/4374633e9fdad2cb7c1e7131.html
//和http://www.cnblogs.com/kdy71107216/archive/2008/11/19/1246722.html
#include <iostream>
using namespace std;
const int maxn = 30003;
typedef struct S{
 int pa;
 int up,sum;         
}S;
S set[maxn];
void ready()
{
 for(int i=1;i<maxn;i++)
 {
    set[i].pa = i;
    set[i].up = 0;
    set[i].sum = 1;;                   
 }    
 return ; 
}
int find(int i)
{
 int r = set[i].pa;
 int sum = 0;
 if(set[i].pa!=i)
 {
 set[i].pa = find(set[i].pa);
 set[i].up+=set[r].up;//这一步和食物链中的同一步一样。。。
 }
 return set[i].pa;
}
void he(int a,int b)
{
 int aa = find(a);
 int bb = find(b);
 set[bb].pa = aa;
 set[bb].up = set[aa].sum;
 set[aa].sum+=set[bb].sum;
 return ;
}
int main()
{
     int i,j,k,n,a,b,c;
     ready();
     scanf(""%d"",&n);
     char ch[4];
     while(n--)
     {
       scanf(""%s"",&ch);
       switch(ch[0])
       {
         case 'M':
               scanf(""%d%d"",&a,&b);
               he(a,b); break;
         case 'C':
               scanf(""%d"",&a);
               int aa = find(a);
               printf(""%d\n"",set[aa].sum-set[a].up-1);
               break;
       }
     }
    // system(""pause"");
     return 0;
}
//详解见 http://www.cppblog.com/RyanWang/archive/2009/02/21/74518.aspx
"
13,"栈可是一个好东西啊pku3044_苏航的空间_百度空间

比较好的栈类型题目。

值得纪念！

题目大意： 给我们一个由一些矩形构造出来的图，我们需要找到最少矩形的块数来覆盖它。acm.pku.edu.cn/JudgeOnline/problem

解题思路：

首先可以肯定如果有两块矩形是连在一起的，那么肯定是用低的那块矩形的高去覆盖，然后再去覆盖高的那块矩形, 所以横坐标是没有关系的，只会受到矩形高度的影响。但是如果直接这样贪心，会出现这种情况：1、2、1，这样做的时候1与2用1先覆盖，但是之后这个1是不需要多余的矩形来覆盖的。所以可以用到栈来处理这个东西。首先我要保证栈是单调上升的。当前插入一个h[i]高度的矩形，也就是在栈中插入h[i]。如果小于栈顶元素那么踢掉栈顶元素，答案累加1，知道大于等于栈顶元素为止。因为在你加入这个h[i]的时候如果它前面的矩形高于它肯定 要竖着去覆盖那个矩形了。最后再累加栈中元素即可！ 

代码：


C++语言: 
Codee#883001 #include <cstdio>

02 

03 const int maxn=50123;

04 

05 int stack[maxn],tot,n,w,h[maxn];

06 

07 int main()

08 {

09     freopen(""p3044.in"",""r"",stdin);

10     freopen(""p3044.out"",""w"",stdout);

11     

12     

13     int ans=0;tot=0;stack[0]=0;

14     scanf(""%d%d"",&n,&w);

15     for (int i=1;i<=n;i++)

16     {

17         int x,y;

18         scanf(""%d%d"",&x,&y);

19         h[i]=y;

20     }

21     h[n+1]=0;

22     for (int i=1;i<=n+1;i++)

23     {

24         while (h[i]<stack[tot] && tot>0)

25         {

26             tot--;

27             ans++;

28         }

29         if (h[i]!=stack[tot])

30         {

31             tot++;

32             stack[tot]=h[i];

33         }

34     }

35     printf(""%d\n"",ans);

36     

37     return 0;

38 }"
17,"2-SAT——3.0（poj3207） - laoda扯一扯  - 博客频道 - CSDN.NET

poj3207 Ikki's Story IV - Panda's Trick
这个题卡的是建图，我开始一直没想到怎么建图，后来看了报告才明白的，= =！
题意是说给出一个圆上的 n 个点（0~n-1编号），然后在指定的 m 对点之间各连一条线（可以在圆内，也可以在圆外，可以是曲线，这点真心坑爹，开始一直木有看明白），然后问你是否能使这些线都不相交。
以每条线段为点，那么对于两点之间的一条位于圆内部的曲线 B，肯定有一条对应的位于圆外部的曲线 B‘，显然这两个点满足 2-SAT 问题模型中的 “B 与 非B” 的关系，然后对于每对两条同在圆内部（或者外部）的曲线来说，通过他们的起点，终点坐标就可以判断2者是否矛盾了，从而依赖这个关系建图，剩下的就是塞模板了。
代码：
 
#include<cstdio>
#include<cstring>
#include<stack>
#include<climits>
using namespace std;
const int N = 250010;
struct Edge{
	int s,e,next;
}edge[N];
int n,m,e_num,vis_num,cnt,head[N],instack[N],tim[N],low[N],belong[N];
void AddEdge(int a,int b){
	edge[e_num].s=a; edge[e_num].e=b; edge[e_num].next=head[a]; head[a]=e_num++;
}
void getmap(){
	int i,j,tmp;
	int px[510],py[510];
	memset(px,0,sizeof(px));
	memset(py,0,sizeof(py));
	for(i=1;i<=m;i++){
		scanf(""%d%d"",&px[i],&py[i]);
		if(px[i]>py[i]){tmp=px[i]; px[i]=py[i]; py[i]=tmp;}
	}
	e_num=0;
	memset(head,-1,sizeof(head));
	for(i=1;i<=m;i++){
		for(j=i+1;j<=m;j++){
			if(px[j]>=px[i]&&px[j]<=py[i]&&py[j]>=py[i] || py[j]>=px[i]&&py[j]<=py[i]&&px[j]<=px[i]){
				AddEdge(2*i-1,2*j);
				AddEdge(2*j-1,2*i);
				AddEdge(2*j,2*i-1);
				AddEdge(2*i,2*j-1);
			}
		}
	}
}
stack <int>st;
void tarjan(int x){
	int i;
	tim[x]=low[x]=++vis_num;
	instack[x]=1;
	st.push(x);
	for(i=head[x];i!=-1;i=edge[i].next){
		int u=edge[i].e;
		if(tim[u]==-1){
			tarjan(u);
			if(low[x]>low[u])low[x]=low[u];
		}
		else if(instack[u] && low[x]>tim[u])low[x]=tim[u];
	}
	if(low[x]==tim[x]){
		cnt++;
		do{
			i=st.top();
			st.pop();
			instack[i]=0;
			belong[i]=cnt;
		}while(i!=x);
	}
}
void solve(){
	int i;
	vis_num=cnt=0;
	memset(instack,0,sizeof(instack));
	memset(belong,-1,sizeof(belong));
	memset(tim,-1,sizeof(tim));
	memset(low,0,sizeof(low));
	for(i=1;i<=2*m;i++){
		if(tim[i]==-1)tarjan(i);
	}
	int flag=1;
	for(i=1;i<2*m;i=i+2){
		if(belong[i]==belong[i+1]){
			flag=0;break;
		}
	}
	if(flag)puts(""panda is telling the truth..."");
	else puts(""the evil panda is lying again"");
}
int main()
{
	while(~scanf(""%d%d"",&n,&m)){
		getmap();
		solve();
	}
	return 0;
}

"
18,"POJ3628-Bookshelf 2_vjudge_新浪博客

 题目链接：
http://poj.org/problem?id=3628

 
题意描述：有n头牛，有一个高为m的书架，求其中某几头牛摞起来比书架高的最小高度。
 题意分析：0-1背包、、、
 代码如下：
 一、背包写法：

 #include<stdio.h>

 #include<string.h>

 #include<stdlib.h>

 #define max(a,b) (a)>(b) ? (a):(b)

 #define MAX 20000005

 int w[25];

 int dp[MAX];

 int main(){

  
 
 
 int m,n,sum;

  
 
 
 int i,j;

  
 
 
 while( scanf( ""%d%d"", &n, &m ) == 2 ){

  
 
 
 
 
 
 
 sum = 0;

  
 
 
 
 
 
 
 for( i=1; i<=n; i++ ){

  
 
 
 
 
 
 
 
 
 
 
 scanf( ""%d"", &w[i] );

  
 
 
 
 
 
 
 
 
 
 
 sum += w[i];

  
 
 
 
 
 
 
 }

  
 
 
 
 
 
 
 for( i=0; i<=sum; i++ )

  
 
 
 
 
 
 
 
 
 
 
 dp[i] = 0;

  
 
 
 
 
 
 
 for( i=1; i<=n; i++ ){

  
 
 
 
 
 
 
 
 
 
 
 for( j=sum; j>=w[i]; j-- ){

  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 dp[j] = max( dp[j], dp[ j-w[i] ] + w[i] );

  
 
 
 
 
 
 
 
 
 
 
 }

  
 
 
 
 
 
 
 }

  
 
 
 
 
 
 
 for( i=m; i<=sum; i++ ){

  
 
 
 
 
 
 
 
 
 
 
 if( dp[i] == i ){

  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 printf( ""%d\n"", i-m );

  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 break;

  
 
 
 
 
 
 
 
 
 
 
 }

  
 
 
 
 
 
 
 }

  
 
 
 }

  
 
 
 return 0;

 }

 
二、改写背包：

 #include<stdio.h>

 #include<string.h>

 #include<stdlib.h>

 #define MAX 20000005

 int w[22];

 bool dp[MAX];

 int main(){

  
 
 
 int m,n,sum;

  
 
 
 int i,j;

  
 
 
 while( scanf( ""%d%d"", &n, &m ) == 2 ){

  
 
 
 
 
 
 
 sum = 0;

  
 
 
 
 
 
 
 for( i=1; i<=n; i++ ){

  
 
 
 
 
 
 
 
 
 
 
 scanf( ""%d"", &w[i] );

  
 
 
 
 
 
 
 
 
 
 
 sum += w[i];

  
 
 
 
 
 
 
 }

  
 
 
 
 
 
 
 memset( dp, 0, sizeof(dp) );

  
 
 
 
 
 
 
 dp[0] = 1;

  
 
 
 
 
 
 
 for( i=1; i<=n; i++ ){

  
 
 
 
 
 
 
 
 
 
 
 for( j=sum; j>=w[i]; j-- ){

  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 if( dp[ j-w[i] ] )

  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 dp[j] = 1;

  
 
 
 
 
 
 
 
 
 
 
 }

  
 
 
 
 
 
 
 }

  
 
 
 
 
 
 
 for( i=m; i<=sum; i++ ){

  
 
 
 
 
 
 
 
 
 
 
 if( dp[i] == 1 ){

  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 printf( ""%d\n"", i-m );

  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 break;

  
 
 
 
 
 
 
 
 
 
 
 }

  
 
 
 
 
 
 
 }

  
 
 
 }

  
 
 
 return 0;

 }

 
三、深搜写法：

 #include<stdio.h>

 #include<string.h>

 #include<stdlib.h>

 #define MAX 99999999

 int w[20];

 int m,n;

 int ans = MAX;

 void DFS( int num,int sum ){

  
 
  
if( sum >= ans )

  
 
 
 
 
 
 
 return;

  
 
  
if( num == n ){

  
 
  
 
 
  
if( sum >= m )

  
 
 
 
 
 
 
 
 
 
 
 ans=sum;

  
 
  
 
 
  
return;

  
 
  
}

  
 
  
DFS( num+1, sum );

  
 
  
DFS( num+1, sum+w[num] );

 }

 int main(){

  
 
  
int i;

  
 
  
scanf( ""%d%d"", &n, &m );

  
 
  
for( i=0; i<n; i++ )

  
 
  
 
 
  
scanf( ""%d"", &w[i] );

  
 
  
DFS( 0,0 );

  
 
  
printf( ""%d"",ans-m );

  
 
  
return 0;

 }"
22,"poj1491简单题_七七·Jianglu_百度空间

#include <iostream>
#include <math.h>
#include <stdio.h>
#include <memory.h>
#include <string.h>
using namespace std;
long gcd(long a,long b)
{
    return b==0?a:gcd(b,a%b);
}
int main()
{
   int n;
   long a[51];
   while(scanf(""%d"",&n)!=EOF)
   {
       if(n==0)
       break;
       for(int i=0;i<n;i++)
       scanf(""%d"",&a[i]);
       int sum=0;
       int s=n*(n-1)/2;
       for(int i=0;i<n;i++)
       {
           for(int j=0;j<n;j++)
           {
               if(a[i]!=a[j])
               {
                   if(gcd(a[i],a[j])==1)
                   sum++;
               }
           }
       }
       sum=sum/2;
       if(sum==0)
       printf(""No estimate for this data set.\n"");
       else
       {
       double r=s*6*1.0/sum;
       r=sqrt(r);
       printf(""%.6lf\n"",r);
       }
   }
}
"
25,"poj1085  Triangle War  极大极小 - qiqijianglu - 博客频道 - CSDN.NET


 Triangle War
 
 
  
   
    
    Time Limit: 1000MS 
      
    Memory Limit: 65536K 
    
    
    Total Submissions: 2171 
      
    Accepted: 831 
    
   
  
 
Description
 

 Triangle War is a two-player game played on the following triangular grid: 
 
 Two players, A and B, take turns filling in any dotted line connecting two dots, with A starting first. Once a line is filled, it cannot be filled again. If the line filled by a player completes one or more triangles, she owns the completed triangles and she is awarded another turn (i.e. the opponent skips a turn). The game ends after all dotted lines are filled in, and the player with the most triangles wins the game. The difference in the number of triangles owned by the two players is not important. 
 
 For example, if A fills in the line between 2 and 5 in the partial game on the left below: 
 
 Then, she owns the triangle labelled A and takes another turn to fill in the line between 3 and 5. B can now own 3 triangles (if he wishes) by filling in the line between 2 and 3, then the one between 5 and 6, and finally the one between 6 and 9. B would then make one more move before it is A's turn again. 
 
 In this problem, you are given a number of moves that have already been made. From the partial game, you should determine which player will win assuming that each player plays a perfect game from that point on. That is, assume that each player always chooses the play that leads to the best possible outcome for himself/herself. 
 
Input
 

 You will be given a number of games in the input. The first line of input is a positive integer indicating the number of games to follow. Each game starts with an integer 6 <= m <= 18 indicating the number of moves that have been made in the game. The next m lines indicate the moves made by the two players in order, each of the form i j (with i < j) indicating that the line between i and j is filled in that move. You may assume that all given moves are legal. 
 
Output
 

 For each game, print the game number and the result on one line as shown below. If A wins, print the sentence ""A wins."" If B wins, print ""B wins."" 
 
Sample Input
 
4 
6 
2 4 
4 5 
5 9 
3 6 
2 5 
3 5 
7 
2 4 
4 5 
5 9 
3 6 
2 5 
3 5 
7 8 
6 
1 2 
2 3 
1 3 
2 4 
2 5 
4 5 
10 
1 2 
2 5 
3 6 
5 8 
4 7 
6 10 
2 4 
4 5 
4 8 
7 8  
Sample Output
 
Game 1: B wins. 
Game 2: A wins. 
Game 3: A wins. 
Game 4: B wins. 
Source
 

 East Central North America 1999
 

  
 

 #include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>
#define M 11
int map[M][M]=
{{0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,2,3,4,0,0,0,0,0},
{0,1,2,0,0,5,6,0,0,0,0},
{0,0,3,0,0,7,0,9,10,0,0},
{0,0,4,5,7,0,8,0,11,12,0},
{0,0,0,6,0,8,0,0,0,13,14},
{0,0,0,0,9,0,0,0,15,0,0},
{0,0,0,0,10,11,0,15,0,16,0},
{0,0,0,0,0,12,13,0,16,0,17},
{0,0,0,0,0,0,14,0,0,17,0}
};
int tri[9]={7,152,52,352,34304,3200,71680,12544,155648};
/*tri[0]=1|(1<<1)|(1<<2);tri[1]=(1<<3)|(1<<4)|(1<<7);tri[2]=(1<<2)|(1<<4)|(1<<5);
tri[3]=(1<<5)|(1<<6)|(1<<8);tri[4]=(1<<9)|(1<<10)|(1<<15);tri[5]=(1<<7)|(1<<10)|(1<<11);
tri[6]=(1<<11)|(1<<12)|(1<<16);tri[7]=(1<<8)|(1<<12)|(1<<13);tri[8]=(1<<13)|(1<<14)|(1<<17);*/
const int mirror=(1<<18)-1;
int MinSearch(int ,int ,int ,int );
int MaxSearch(int ,int ,int ,int );
int Place(int s,int seg,int &of)
{
	int i;
	int r=s|seg;
	for(i=0;i<9;i++){
		if(((tri[i]&s)!=tri[i])&&((tri[i]&r)==tri[i]))
			of++;
	}
	return r;
}
int MaxSearch(int statu,int alpha,int as,int bs)
{
	int bit,seg;
	int cs,r;
	int max=-1,tmp;
	if(as>=5) return 1;
	if(bs>=5) return -1;
	if(statu==mirror)
		return as>bs?1:-1;
	bit=(~statu)&mirror;
	while(bit){
		seg=bit&(-bit);
		cs=as;
		r=Place(statu,seg,cs);
		if(cs>as)
			tmp=MaxSearch(r,alpha,cs,bs);
		else
			tmp=MinSearch(r,max,cs,bs);
		if(tmp>max)
			max=tmp;
		if(max>=alpha)///
			return max;
		bit-=seg;
	}
	return max;
}
int MinSearch(int statu,int beta,int as,int bs)
{
	int bit,seg,cs,r;
	int min=1,tmp;
	if(as>=5) return 1;
	if(bs>=5) return -1;
	if(statu==mirror)
		return as>bs?1:-1;
	bit=(~statu)&mirror;
	while(bit){
		seg=bit&(-bit);//最右边的1
		cs=bs;
		r=Place(statu,seg,cs);
		if(cs>bs)
			tmp=MinSearch(r,beta,as,cs);
		else
			tmp=MaxSearch(r,min,as,cs);
		if(tmp<min) min=tmp;
		if(tmp<=beta)///
			return min;
		bit-=seg;
	}
	return min;
}
int main()
{
	int t,k=0;
	int a,b,n,i,turn;
	int res;
	int ofa,ofb;
	int ta,tb;
	int status;
	scanf(""%d"",&t);
	while(t--){
		scanf(""%d"",&n);
		status=ofa=ofb=0;
		for(turn=i=0;i<n;i++){
			scanf(""%d%d"",&a,&b);
			ta=ofa,tb=ofb;
			status=Place(status,1<<map[a][b],(turn&1)?ofb:ofa);
			if(ta==ofa&&tb==ofb)
				turn++;
		}
		if(turn&1)
			res=MinSearch(status,-1,ofa,ofb);
		else
			res=MaxSearch(status,1,ofa,ofb);
		printf(""Game %d: %c wins.\n"",++k,res==1?'A':'B');
	}
	return 0;
}
 
"
29,"poj2309(BST) - 鸟 的 天 空 - 博客频道 - CSDN.NET

           题目链接：http://poj.org/problem?id=2309
        题意不难理解，不方便描述，所以，抱歉了！
直接看代码：
 
#include<stdio.h>
void main(){
  int num;
  scanf(""%d"",&num);
  while(num--)
  {
	  long int i,n,q,min,max;
	  scanf(""%d"", &n);
	  if(n%2==1)
	  {
		  min=n;
		  max=n;
	  }
	  else
	  {
		   q=1;
	    for(i=1;i<=31;i++)
		{
		   q*=2;
		    if(n%q==0 && n%(q*2)!=0)
				   break;
		}
		min=n-q+1;
		max=n+q-1;
	  }
    printf(""%d %d\n"",min,max);
  }
}
"
37,"poj 2754 Similarity of necklaces 2 转换成多重背包，单调队列优化/ 二进制优化 - yefeng1627 - 博客园

　　贴个官方解题报告
 
 
 Similarity of necklaces 2
这个问题是一个012背包问题。我们知道01背包只要逆向线性检索，无限背包只要正向检索。012背包就是说，每个物品有一个数量上限。这个问题可以用log方法，也存在线性方法，需要维护一个递增/递减序列。
我们先把所有的Table都放成下限，接下来我们可以算出它距离总和为0还需要增加多少。对于1<=i<=M，它可以看成这样一个物品：体积为Multi[i]，费用为Pairs[i]，数量为Up[i]-Low[i]。然后就得到一个012背包问题了。
复杂度约为：O(M*背包大小)。其中背包大小不超过M*20*25=200*20*25=100000。 
 

　　单调队列优化解法：
　　　　多重背包状态方程：
　　　　　　　　
　　　　令  转换下得到：
　　　　　　　　
　　　　因为 ， 当 j 确定时， 则x的取值范围为，  
　　　　也就是说    ，  也可看作为 
　　　　则可得
　　　　　　　　    ，其中 j <= k
　　　　那么意味着，对于确定的 j， 求 Xk 时候，我们只需要对  维护一个单调队列即可。
　　　　对于任意的 Xi < Xj, 若 Xb 优于 Xa,则必将满足如下要求， 
　　　　
　　　　这种写法 AC时间是 1500ms，有点慢　　　　
 

 
 
 View Code  
  
  #include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<algorithm>
using namespace std;
const int maxn = 210;
const int N = 100000+10;
const int inf = -2139062144;
int dp[2][N];
int P[maxn], M[maxn], Low[maxn], Up[maxn];
int n, m, Q[N], cnt[maxn], val;
int max(int a,int b) {return a>b?a:b;}
int main()
{ 
    while( scanf(""%d"", &n) != EOF)
    {
        m = 0; val = 0;    
        for(int i = 1; i <= n; i++)
        {    
            scanf(""%d%d%d%d"",P+i,M+i,Low+i,Up+i);
            m += Low[i]*M[i];
            val += Low[i]*P[i];    
            cnt[i] = Up[i]-Low[i];    
        }    
        memset(dp, 0x80, sizeof(dp));
        dp[0][0] = 0;    
        m = -m;
        int cur = 0;
        for(int i = 1; i <= n; i++)
        {
            int nxt = cur^1;
            // 枚举剩余系j    
            for(int j = 0; j < M[i]; j++)
            {
                //单调队列队首指针qh,队尾指针qe, 当前最大长度len    
                int qh = 0, qe = -1, len = cnt[i]*M[i];
                for(int k = j; k <= m; k += M[i] )
                {
                    if( dp[cur][k] != -inf )
                    {
                        while( (qh <= qe) && (dp[cur][ Q[qe] ]+(k-Q[qe])*P[i]/M[i] <= dp[cur][k] ) )
                            qe--;
                        Q[++qe] = k;    
                        while( (qh <= qe) && (k-Q[qh]>len) ) qh++;
                        if(qh <= qe)    dp[nxt][k] = dp[cur][ Q[qh] ] + (k-Q[qh])*P[i]/M[i];
                        else    dp[nxt][k] = -inf;    
                    }
                }
            }
            cur = nxt;    
        }
        printf(""%d\n"", dp[cur][m]+val );    
    }
    return 0;
} 
  
 

　　　　
　　　　将其转换成 01背包：
　　　　　　套用 背包九讲 的二进制写法就可以了，一样将Table取下限，转换出一个物品数量。
　　　　　　模板是处理第i种物品时， 若其 体积*数量 >= 总背包大小， 则当作完全背包处理，
　　　　　　否则 将其按照 二进制表示的形式，当作一次 01背包来处理。代码400MS左右，比上面写法快
 

 
 
 View Code  
  
  #include<stdio.h>
#include<string.h>
#include<stdlib.h>
using namespace std;
const int inf = 0x80808080;
const int N = 100010;
int n, V, val;
int P[210], M[210], cnt[210];
int dp[N];
int max(int a,int b)
{ return a>b?a:b; }
void ZeroOnePack( int cost, int weight )
{
    for(int v = V; v >= cost; v-- )    
        dp[v] = max( dp[v], dp[v-cost] + weight );
}
void CompletePack( int cost, int weight )
{
    for(int v = cost; v <= V; v++ )
        dp[v] = max( dp[v], dp[v-cost] + weight );
}
void MultiplePack( int cost, int weight, int num )
{
    if( cost*num >= V )
    {    
        CompletePack( cost, weight );
        return ;
    }
    int k = 1;
    while( k <= num )
    {
        ZeroOnePack( k*cost, k*weight );
        num = num-k;
        k <<= 1;
    }
    ZeroOnePack( num*cost, num*weight );
}
int main()
{
    while( scanf(""%d"",&n) != EOF)
    {
        V = 0; val = 0;
        int up, low;
        for(int i = 1; i <= n; i++)
        {
            scanf(""%d%d%d%d"",P+i,M+i,&low,&up);
            V += low*M[i];
            val += low*P[i];
            cnt[i] = up-low;    
        }
        V = -V;
        memset( dp, 0x80, sizeof(dp));
        dp[0] = 0;
        for(int i = 1; i <= n; i++)
            MultiplePack( M[i], P[i], cnt[i] );    
        printf(""%d\n"", dp[V]+val );
    }    
    return 0;
} 
  
 

　　　　
　　　　
"
41,"北大ACM poj2301 - gubojun的专栏 - 博客频道 - CSDN.NET

//解方程 x=a+b,y=|a-b|,求a b
#include <stdio.h>
#include <time.h>
main()
{
    int n;
    scanf(""%d"",&n);
    while(n--)
    {
        int x,y,c;
        scanf(""%d%d"",&x,&y);
        c=x-y;
        if(x<y||c%2!=0)
        puts(""impossible"");
        else
        {
            c/=2;
            printf(""%d %d\n"",c+y,c);
        }
    }
 //   printf(""%f\n"",(float)clock()/CLOCKS_PER_SEC);
}

"
44,"poj3077 - xuezhongfenfei的专栏 - 博客频道 - CSDN.NET

水题啊水题！
 
#include<iostream>
#include<string>
using namespace std;
int main()
{
	char a[10];
	int len,i,t,j,n;
	cin>>n;
	while(n--) 
	{
		scanf(""%s"",a);
		t=0;
		len=strlen(a);
		if(len==1)
			cout<<a<<endl;
		else
		{
			for(i=1; i<len; i++)
			{
				if(a[i]>='5')
				{
				   if(a[0]=='9')
                   printf(""10"");
				   else
					   printf(""%c"",a[0]+1);
				   for(j=1; j<len; j++)
					   cout<<'0';
				   cout<<endl;
				   t=1;
				   break;
				}
				else if(a[i]<'4')
				{
                   printf(""%c"",a[0]);
				   for(j=1; j<len; j++)
					   cout<<'0';
				   cout<<endl;
				   t=1;
				   break;
				}
			}
			if(t==0)
			{
                  printf(""%c"",a[0]);
				   for(j=1; j<len; j++)
					   cout<<'0';
				   cout<<endl;
				   t=1;
			}
		}
	}
	return 0;
} 

"
48,"pku 1535 dfs - 小鱼的日志 - 网易博客

这题还好了，怎么ac那么少的人。诡异!,就是在dfs去的方向同时判断回来的方向。

 
  

 
 
  #include <iostream>
 
 
  using namespace std;
 
 
  

 
 
  const int N =101;
 
 
  

 
 
  int m,n;
 
 
  int x0,y0,x1,y1;
 
 
  bool a[N][N],vis[N][N];
 
 
  int path[4]={0,2,3,1};// 前后左右
 
 
  int pos[4][2]={{-1,0},{0,1},{1,0},{0,-1}};//上右下左
 
 
  

 
 
  bool in(int x,int y)
 
 
  {
 
 
   return !(x <0 || x>=m || y <0 || y>=n);
 
 
  }
 
 
  bool dfs(int xs,int ys,int ps,int xe,int ye,int pe)
 
 
  {
 
 
   if(xs == x1 && ys == y1)
 
 
   return (xe== x0 && ye== y0);
 
 
   if(xe== x0 && ye== y0)
 
 
   return (xs == x1 && ys == y1);
 
 
  

 
 
   int xss,yss,xee,yee;
 
 
   for(int j,i=0;i<4;i++)
 
 
   {
 
 
   xss = xs + pos[j = (ps+path[i])%4][0];
 
 
   yss = ys + pos[j][1];
 
 
   xee = xe + pos[j = (pe+path[i])%4][0];
 
 
   yee = ye+ pos[j][1];
 
 
   if(!in(xss,yss) || !in(xee,yee))continue;
 
 
   if(vis[xss][yss] || a[xss][yss] || a[xee][yee])continue;
 
 
   vis[xss][yss] =1;
 
 
   if(dfs(xss,yss,(ps+path[i])%4,xee,yee,(pe+path[i])%4))
 
 
   return true;
 
 
   vis[xss][yss] =0;
 
 
   }
 
 
   return false;
 
 
  }
 
 
  int main()
 
 
  {
 
 
   while(scanf(""%d %d"",&m,&n), m || n)
 
 
   {
 
 
   scanf(""%d %d %d %d"",&x0,&y0,&x1,&y1);
 
 
   memset(a,0,sizeof(a));
 
 
   int x,y,k,i;
 
 
   scanf(""%d"",&k);
 
 
   for(i=0;i<k;i++){
 
 
   scanf(""%d %d"",&x,&y);
 
 
   a[x][y] =1;
 
 
   }
 
 
  

 
 
   memset(vis,0,sizeof(vis));
 
 
   vis[x0][y0]=1;
 
 
   if(dfs(x0,y0,1,x1,y1,3))
 
 
   printf(""YES\n"");
 
 
   else printf(""NO\n"");
 
 
   }
 
 
   return 0;
 
 
  }
 
"
49,"pku3233_Acer_Vagabond_新浪博客

http://acm.pku.edu.cn/JudgeOnline/problem?id=3233
大意：各一个N*N的方阵A，求S = A + A2 + A3 + … + Ak 
       其中N<=30,k<=100000000,m<=10000
算法：本想看作等比数列来做，在除的时候乘上分母的逆矩阵。可以只能过样例，WA。
      然后看了下题解，用二分优化递推。即找前k项和与前k/2项和得关系。
#include <iostream>
   using namespace std;
   int a[31][31],b[31][31],c[31][31],f[31][31],e[31][31],n,m,link;
 void multi(){
   memset(c,0,sizeof(c));
   int i,j,k;
   for(i=0;i<n;i++)
   for(j=0;j<n;j++)
   for(k=0;k<n;k++)
   c[i][j]=(c[i][j]+a[i][k]*b[k][j])%m;
 }
 void pow(int x){
   int i,j;
   if(x==1){
     for(i=0;i<n;i++)
     for(j=0;j<n;j++)c[i][j]=e[i][j];
     return;
     };
   int y=x>>1;
   pow(y);
   for(i=0;i<n;i++)
   for(j=0;j<n;j++)a[i][j]=b[i][j]=c[i][j];
   multi();
   if(y+y<x){
     for(i=0;i<n;i++)
     for(j=0;j<n;j++){a[i][j]=c[i][j];b[i][j]=e[i][j];};
     multi();
     };
 }
 void calc(int x){
   int i,j;
   if(x==1){
     for(i=0;i<n;i++)
     for(j=0;j<n;j++)f[i][j]=e[i][j];
     return;
     };
   int y=x>>1;
   calc(y);
   pow(y);
   for(i=0;i<n;i++)
   for(j=0;j<n;j++){a[i][j]=f[i][j];b[i][j]=c[i][j];};
   multi();
   for(i=0;i<n;i++)
   for(j=0;j<n;j++)f[i][j]=(f[i][j]+c[i][j])%m;
   if(y+y<x){
     pow(x);
     for(i=0;i<n;i++)
     for(j=0;j<n;j++)f[i][j]=(f[i][j]+c[i][j])%m;
     };
 }
 int main(){
  // freopen(""a.in"",""r"",stdin);freopen(""a.out"",""w"",stdout);
   scanf(""%d%d%d\n"",&n,&link,&m);
   int i,j,k;
   for(i=0;i<n;i++)
   for(j=0;j<n;j++){
     scanf(""%d"",&k);
     e[i][j]=k % m;
     };
   calc(link);
   for(i=0;i<n;i++){
     for(j=0;j<n-1;j++)cout<<f[i][j]<<' ';
     cout<<f[i][n-1]<<endl;
     };
   return 0;
 }
那个WA的程序：
#include <iostream>
 #include <cmath>
   using namespace std;
   int a[31][31],b[31][31],c[31][31],st[321][31],e[31][31],d[31][31],n,link,m;
   double nb[31][31],ne[31][31],f[31][31],err=0.000001;
 void multi(){
   memset(c,0,sizeof(c));
   int i,j,k;
   for(i=0;i<n;i++)
   for(j=0;j<n;j++)
   for(k=0;k<n;k++)c[i][j]=(c[i][j]+a[i][k]*b[k][j])%m;
 }
 void pow(int x){
   if(x==1){
     memcpy(c,st,sizeof(c));
     return;
     };
   int y=x>>1;
   pow(y);
   memcpy(a,c,sizeof(c));memcpy(b,c,sizeof(b));
   multi();
   if(y+y<x){
     memcpy(a,c,sizeof(c));
     memcpy(b,st,sizeof(b));
     multi();
     };
 }
 void print(){
   int i,j;
   for(i=0;i<n;i++){
     for(j=0;j<n;j++)cout<<ne[i][j]<<' ';
     cout<<endl;
     };
 }
 int main(){
   freopen(""a.in"",""r"",stdin);freopen(""a.out"",""w"",stdout);
   scanf(""%d%d%d\n"",&n,&link,&m);
   int i,j,k;
   memset(e,0,sizeof(e));
   for(i=0;i<n;i++)e[i][i]=1;
   for(i=0;i<n;i++)
   for(j=0;j<n;j++){
     scanf(""%d"",&st[i][j]);
     st[i][j]%=m;
     };
   if(link==0){
     for(i=0;i<n;i++){
       for(j=0;j<n-1;j++)cout<<e[i][j]<<' ';
       cout<<e[i][n-1]<<endl;
       };
     return 0;
     };
   pow(link);
   memcpy(a,st,sizeof(a));
   for(i=0;i<n;i++)
   for(j=0;j<n;j++)b[i][j]=(e[i][j]-c[i][j]+m)%m;
   multi();
   double x,y;
   for(i=0;i<n;i++)
   for(j=0;j<n;j++){
     k=e[i][j]-st[i][j];
     nb[i][j]=(double)k;
     ne[i][j]=(double)e[i][j];
     };
   for(k=0;k<n-1;k++){
     i=k;
     while(i<n&&fabs(nb[i][k])<err)i++;
     if(i>=n){cout<<""SB!""<<endl;break;};
     for(j=0;j<n;j++){
       x=nb[i][j];nb[i][j]=nb[k][j];nb[k][j]=x;
       x=ne[i][j];ne[i][j]=ne[k][j];ne[k][j]=x;
       };
     x=nb[k][k];
     for(j=0;j<n;j++){
       nb[k][j]/=x;
       ne[k][j]/=x;
       };
     for(i=k+1;i<n;i++){
       x=nb[i][k];
       for(j=0;j<n;j++){
         nb[i][j]=nb[i][j]-nb[k][j]*x;
         ne[i][j]=ne[i][j]-ne[k][j]*x;
         };
       };
     };
   for(j=0;j<n;j++)ne[n-1][j]/=nb[n-1][n-1];
   nb[n-1][n-1]=1.0;
   for(k=n;k>0;k--)
   for(i=k-1;i>-1;i--){
     x=nb[i][k];
     for(j=0;j<n;j++){
       nb[i][j]=nb[i][j]-nb[k][j]*x;
       ne[i][j]=ne[i][j]-ne[k][j]*x;
       };
     };
   print();
   for(i=0;i<n;i++)
   for(j=0;j<n;j++)nb[i][j]=(double)c[i][j];
   for(i=0;i<n;i++)
   for(j=0;j<n;j++){
     f[i][j]=0.0;
     for(k=0;k<n;k++)f[i][j]=f[i][j]+ne[i][k]*nb[k][j];
     };
   for(i=0;i<n;i++)
   for(j=0;j<n;j++){
     c[i][j]=(int)f[i][j];
     c[i][j]=c[i][j]%m;
     c[i][j]=(c[i][j]+m)%m;
     };
   for(i=0;i<n;i++){
     for(j=0;j<n-1;j++)cout<<c[i][j]<<' ';
     cout<<c[i][n-1]<<endl;
     };
   return 0;
 }   
"
50,"poj 2275_wegnahz的空间_百度空间

我发现。。。一边看电视剧一边写代码效率的确太低了。。。
这题从8点多一直写到10点，题目并不难，就是给你个二叉树，问有多少种不同顺序的输入序列也能构造出相同结构的二叉树。其实只要构造出树的形状，那么设f[i]为以i为根的子树的答案
f[i]=c[i的孩子数][i的左（右）孩子数]×f[左孩子]×f[右孩子]，输出根节点的答案即可。因为我半秃，秃然想写个完全非递归的，于是插入节点和递推的时候都用非递归，拿栈模拟了个，结果。。。不管怎么说，好歹ac了
/* pku2775 */
/* produced by wegnahz */
#include <iostream>
#include <string>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <ctype.h>
using namespace std;
const int inf=100000000,mm=9901;
const double pi=acos(-1.0);
const double eps=1e-8;
const int maxn=101;
template<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}
template<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}
inline void fill(int *a,int b,int c){
 for (int i=0;i<c/4;i++,a++) *a=b;}
int n,a[maxn],c[maxn][maxn],l[maxn],r[maxn],nl[maxn],nr[maxn],f[maxn],s[maxn];
int main(){
    int i,j,k,t;
    freopen(""pku2775.in"",""r"",stdin);
    freopen(""pku2775.out"",""w"",stdout);
    for (c[0][0]=1,i=1;i<=100;i++)
        for (c[i][0]=1,j=1;j<=i;j++)
            c[i][j]=(c[i-1][j]+c[i-1][j-1])% mm;
    while (cin>>n,n)
    {
        memset(nl,0,sizeof(nl));
        memset(nr,0,sizeof(nr));
        memset(l,0,sizeof(l));
        memset(r,0,sizeof(r));
        for (cin>>a[1],i=2;i<=n;i++)
            for (cin>>a[i],j=1;j!=i;)
                if (a[i]<=a[j])
                {
                    nl[j]++;
                    if (!l[j]) l[j]=i;
                    j=l[j];
                } else
                {
                    nr[j]++;
                    if (!r[j]) r[j]=i;
                    j=r[j];
                }
        memset(f,0,sizeof(f));
        for (i=1;i<=n;i++) a[i]=c[nl[i]+nr[i]][nl[i]];
        for (t=1,s[1]=1;t;)
        {
            if (!s[t]) f[s[--t]]++; else
            if (f[s[t]]==0) {s[t+1]=l[s[t]]; t++;} else
            if (f[s[t]]==1) {s[t+1]=r[s[t]]; t++;} else
            {f[s[--t]]++; a[s[t]]=(a[s[t]]*a[s[t+1]])%mm;}            
        }
        cout<<a[1]<<endl;
    }
    return 0;
}
"
52,"pku 1324  Holedox Moving_lywdx_百度空间

首先声明我的程序写的很烂，限时5秒，我的程序4.5秒水过去了，

我的思想应该是正确的，肯定还有剪枝的地方没注意到！

先说一下题目大意：给你一个用二维数组，告诉你蛇的初始位置，并告诉你那些坐标点是石头，

是石头的点蛇不能通过，问你蛇从起始点到（1，1）这点用的最少步数！

思路：广搜，关键是怎么设置状态，首先头的位置必须清楚，之后是身体的位置，身体的位置我们

可以用一个int类型的整数（2*（n-1）位的二进制数），我设4个方向为上下左右，

其中上（00也就是十进制的0），右（01也就是十进制的1），下（10也就是十进制的2），

左（11也就是十进制的3），记录身体的方法就是，看蛇的颈部在头的什么方向，得到颈部的位置，再看

通过颈部的位置，看身体在颈部的什么方向，得到身体的位置.....这样进行直到找到尾部的位置！

这样，一个状态怎么表示就出来了，它包含：1，头的坐标，2，身体的状态，3，到该状态走了多少步！

如果用结构体表示一个状态，就应该是

struct Node

{

     int s, y;   //头坐标

     int state;   //改状态身体情况

     int steps;   //当前用了多少步

};

怎么把状态转换成int类型，我是这样做的，比如，题目中的测试数据，state = 0；

4 1

4 2

3 2

3 1

头坐标4 1

则 （4，2） 头的右边，state |= 1 << (2*(n-i)-2);//其中的  i  是表示

头后面的第几个节点，因为我的二进制是位高——>低  表示蛇的  颈——>尾

（3，2）又在（4，2）的上边，上边不用管，因为  state ｜= 0 << (2*(n-i)-2)没变化

（3，1）在（3，2） 的左边  state ｜= 0 << (2*(n-i)-1)；state ｜= 0 << (2*(n-i)-2)

这里有两个式子，因为左边是二进制11，两个1，所以都要处理，

这样就得到了初始状态，在后面的蛇头移动后，要找身体的位置的状态 也是这种方法，但是在那里既要

注意了，如果蛇头往上运动，则颈部在它的下边，如果蛇头往左边移动，则颈部在它的右边，这里别弄

混了！

这个题的标记要用三维的数组，

状态都设计出来了，这个题就简单了！ 直接bfs；

可是我没找出哪里还可以剪枝的地方！！！继续调试中..............

#include <iostream>

#include <cstdio>

#include <cstring>

#include <algorithm>

#include <queue>

#define Max 25

#define Maxn 10010

using namespace std;

struct Node

{

 int x, y;

 int steps;

 int state;

};

struct Node1

{

 int x, y;

};

bool G[Max][Max];

int move[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};

bool visit[Max][Max][Maxn];

int r, c, n, m;

void bfs(Node fir)

{

 queue<Node> q;

 Node end;

 int sum = 0;

 bool juge = false;

 Node1 parent[Max];

 memset(parent, 0 , sizeof(parent));

 parent[0].x = fir.x;

 parent[0].y = fir.y;

 q.push(fir);

 while(!q.empty())

 {

 fir = q.front();

 q.pop();

 int index_x = fir.x;

 int index_y = fir.y;

 for(int j = 1; j < n; ++j)    //计算蛇在上一状态中的身体的坐标，并记录在parent中

 {

 int index = 0, rez = 0;

 index = (((1<<(2*(n-j)-1)) | (1<<(2*(n-j)-2))) & fir.state) ;

 int index1 = (index & (1<<(2*(n-j)-2)));

 rez = index1 >> (2*(n-j)-2);

 int index2 = (index & (1<<(2*(n-j)-1)));

 rez |= index2 >> (2*(n-j)-2);

 int xnow = index_x + move[rez][0];

 int ynow = index_y + move[rez][1];

 parent[j].x = xnow;

 parent[j].y = ynow;

 index_x = xnow;

 index_y = ynow;

 }

 for(int i = 0; i < 4; ++i)          //蛇头向4个方向移动

 {

 Node media;

 bool flag = false;

 media.x = fir.x + move[i][0];

 media.y = fir.y + move[i][1];

 if(media.x <= 0 || media.x > r || media.y <= 0 || media.y > c || G[media.x][media.y])

 continue;

 if(media.x == 1 && media.y == 1)           //到达（1，1）退出

 {

 sum = fir.steps + 1;

 juge = true;

 break;

 }

 if(i == 0)                 //上边条件全部满足后，计算蛇头移动一步后，当前蛇身体状态

 {

 media.state = (fir.state >> 2) | (1 << (2*(n-1)-1));

 }

 else if(i == 1)

 {

 media.state = (fir.state >> 2) | (1 << (2*(n-1)-1)) | (1 << (2*(n-1)-2));

 }

 else if(i == 2)

 {

 media.state = fir.state >> 2;

 }

 else if(i == 3)

 {

 media.state = (fir.state >> 2) | (1<<(2*(n-1)-2));

 }

 if(!visit[media.x][media.y][media.state] )            //假如这个状态没有出现过，入队列

 {

 for(int j = 1; j < n; ++ j)

 {

 if(media.x == parent[j].x && media.y == parent[j].y)

 {

 flag = true;

 break;

 }

 }

 if(flag)

 continue;

 visit[media.x][media.y][media.state] = true;       //标记

 media.steps = fir.steps + 1;

 q.push(media);

 }

 if(juge) break;

 }

 if(juge) break;

 }

 while(!q.empty()) q.pop();

 if(juge) printf(""%d\n"",sum);

 else printf(""-1\n"");

}

void init()

{

 int test = 1;

 while(scanf(""%d%d%d"",&r,&c,&n) && r && c && n)

 {

 Node str;

 int x, y, index = 0, rez = 0;

 printf(""Case %d"", test);

 printf("": "");

 test ++;

 int x1, y1;

 scanf(""%d%d"",&str.x,&str.y);

 x1 = str.x;

 y1 = str.y;

 for(int i = 1; i < n; ++i)           // 计算蛇的初始状态

 {

 scanf(""%d%d"",&x,&y);

 if(x1 == x)

 {

 if(y > y1)

 {

 index |= 1 << (2*(n-i)-2);

 }

 else

 {

 index |= 1 << (2*(n-i)-1);

 index |= 1 << (2*(n-i)-2);

 }

 }

 else if(y == y1)

 {

 if(x > x1)

 {

 index |= 1 << (2*(n-i)-1);

 }

 }

 x1 = x;

 y1 = y;

 }

 str.state = index;

 str.steps = 0;

 scanf(""%d"", &m);

 for(int i = 0; i < Max; ++i)

 {

 for(int j = 0; j < Max ; ++ j)

 G[i][j] = false;

 }

 for(int i = 0; i < m ; ++ i)

 {

 scanf(""%d%d"",&x,&y);

 G[x][y] = true;

 }

 if(str.x == 1 && str.y == 1)

 {

 printf(""0\n"");

 continue;

 }

 memset(visit, false, sizeof(visit));

 visit[str.x][str.y][str.state] = true;

 bfs(str);

 }

}

int main()

{

 init();

 return 0;

}"
56,"poj2080 Calendar - hlb430 - 博客园

Time Limit: 1000MS Memory Limit: 30000K
Total Submissions: 7821 Accepted: 2919
Description
A calendar is a system for measuring time, from hours and minutes, to months and days, and finally to years and centuries. The terms of hour, day, month, year and century are all units of time measurements of a calender system.
According to the Gregorian calendar, which is the civil calendar in use today, years evenly divisible by 4 are leap years, with the exception of centurial years that are not evenly divisible by 400. Therefore, the years 1700, 1800, 1900 and 2100 are not leap years, but 1600, 2000, and 2400 are leap years.
Given the number of days that have elapsed since January 1, 2000 A.D, your mission is to find the date and the day of the week.
Input
The input consists of lines each containing a positive integer, which is the number of days that have elapsed since January 1, 2000 A.D. The last line contains an integer −1, which should not be processed.
You may assume that the resulting date won’t be after the year 9999.
Output
For each test case, output one line containing the date and the day of the week in the format of “YYYY-MM-DD DayOfWeek”, where “DayOfWeek” must be one of “Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday” and “Saturday”.
Sample Input
1730
1740
1750
1751
-1
Sample Output
2004-09-26 Sunday
2004-10-06 Wednesday
2004-10-16 Saturday
2004-10-17 Sunday
Source
Shanghai 2004 Preliminary
这道题天数很容易出错~~~
 
 
  
   
   #include<stdio.h>  
int main(){  
    char w[7][10]={""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"" ,""Saturday""};  
    int m[2][13]={0,31,28,31,30,31,30,31,31,30,31,30,31,  
                  0,31,29,31,30,31,30,31,31,30,31,30,31};  
    int yd[2]={365,366};  
    long day;  
    int year,month,week;  
    int i,j,flag;  
    while(scanf(""%ld"",&day)&&-1!=day){  
        week=(day+6)%7;//得到星期几   
        year=2000;  
        flag=(0==year%4&&year%100!=0)||0==year%400;//flag=1为闰年   
        ++day;//题目说经过多少天，所以在这里先加1   
        for(;day>yd[flag];){//得到年份、剩余天数   
            day-=yd[flag];   
            year++;  
            flag=(0==year%4&&year%100!=0)||0==year%400;  
        }  
        for(month=1;day>m[flag][month];++month){//得到月份和对应天数   
            day-=m[flag][month];  
        }  
        printf(""%d-%02d-%02d %sn"",year,month,day,w[week]);//%02d很方便          
    }  
} 
   
  
 
  
"
57,"[后缀数组、出现k次的重复子串]Pku3261 -- Milk Patterns_Fstephen的茶几_百度空间

http://acm.pku.edu.cn/JudgeOnline/problem?id=3261
题目大意：给出n个数字组成的一个字符串，求最长的恰好出现k次的重复子串（可重叠）的字符串的长度。
分析：后缀数组一个经典的应用。先二分答案，然后分组。只要某一组包含的后缀数量大于等于k，表示有解。这个不难理解。等完成了论文里面的练习之后，我再写个总结笔记吧。
深刻体会到后缀数组的强大....
note：1、分组时，每次height[i]<k时，第i个后缀是归到下一个组中的。
           2、scanf()返回的值是成功读取了多少个数据，如果文件结束了，返回EOF。一开始不知道这个，结果OLE= =
codes：
#include<stdio.h>
using namespace std;
const int maxn=20010;
int w[maxn*2],wa[maxn],wb[maxn],wv[maxn],sa[maxn],rank[maxn],height[maxn],a[maxn];
int n,m,k;
int cmp(int *r,int a,int b,int l){
    return r[a]==r[b]&&r[a+l]==r[b+l];
}
void da(int *r,int *sa,int n,int m){
     int i,j,p,*x=wa,*y=wb,*t;
     for (i=0;i<m;i++) w[i]=0;
     for (i=0;i<n;i++) w[x[i]=r[i]]++;
     for (i=1;i<m;i++) w[i]+=w[i-1];
     for (i=n-1;i>=0;i--) sa[--w[x[i]]]=i;
     for (p=1,j=1;p<n;j*=2,m=p){
         for (i=n-j,p=0;i<n;i++) y[p++]=i;
         for (i=0;i<n;i++) if (sa[i]>=j) y[p++]=sa[i]-j;
         for (i=0;i<m;i++) w[i]=0;
         for (i=0;i<n;i++) w[wv[i]=x[y[i]]]++;
         for (i=1;i<m;i++) w[i]+=w[i-1];
         for (i=n-1;i>=0;i--) sa[--w[wv[i]]]=y[i];
         for (t=x,x=y,y=t,x[sa[0]]=0,p=1,i=1;i<n;i++)
         x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
         }
     return;
     }
void cal(int *r,int *sa,int n){
     int i,j,k=0;
     for (i=1;i<=n;i++) rank[sa[i]]=i;
     for (i=0;i<n;height[rank[i++]]=k)
         for (k?k--:0,j=sa[rank[i]-1];r[i+k]==r[j+k];k++);
     return;
     }
int check(int x){
    int i,cnt;
   for (i=1;i<=n;i++)
        if (height[i]<x) cnt=1;
        else
            if (++cnt>=k) return 1;
    if (cnt>=k) return 1;
    return 0;        
}                                                
int bin_search(int l,int r){
    int mid;
    for (mid=(r+l)>>1;l<=r;mid=(r+l)>>1)
        if (check(mid)) l=mid+1; else r=mid-1;
    return mid;
}
int main(){
    int i;
    while (scanf(""%d %d"",&n,&k)!=EOF){
          m=0;
          for (i=0;i<n;i++) 
          {
              scanf(""%d"",&a[i]);
              a[i]++;
              m=m>a[i]?m:a[i];
          }
          a[n]=0;
          m++;
          da(a,sa,n+1,m);
          cal(a,sa,n);
          int k=bin_search(0,n);
          printf(""%d\n"",k);
    }
    return 0;
}
"
58,"POJ1256 (C++ compare函数) - bobchou - 博客园

问题：
　　有一个只含大小写字母的字符串，给出所有该字符串的排列，以字典顺序输出。其中 'A'<'a'<'B'<'b'<...<'Z'<'z'。
方法：
　　只需调用C++ STL中 next_permutation() 和 sort() 函数，重点在于编写自定义的compare() 函数。
hint：（compare 函数的编写方法）
 
 
 bool cmp(int a, int b){
      a = ....;                      // 处理a
      b = ....;                      // 处理b
      return (condition);    // 若要增序排列，只需将condition填补为所有可能使a小于b的情况
} 
 

代码：
 
 
 #include<iostream>
#include<algorithm>
#include<string>
using namespace std;
bool cmp(char a, char b){
    if(a <= 'Z' && b <= 'Z')
        return a < b;
    else if(a >= 'a' && b >= 'a')
        return a < b;
    else if(a >= 'a' && b <= 'Z')
        return a - 'a' < b - 'A';
    else if(b >= 'a' && a <= 'Z')
        return a - 'A' <= b - 'a';
}
int main(){
    string input;
    int N;
    cin >> N;
    while(N--){
        cin >> input;
        sort(input.begin(), input.end(), cmp);
        do{
            cout << input << endl;
        }while(next_permutation(input.begin(), input.end(), cmp));
    }
} 
 

"
60,"POJ1176 (规律循环) - czhou0的专栏 - 博客频道 - CSDN.NET

问题：
 
　　有N个开着的灯，和控制这个N个灯的四个开关。四个开关作用不同。第一个开关：flip所有的灯。第二个开关：flip奇数编号的灯。第三个开关：flip偶数编号的灯。第四个开关：flip编号为3 * K + 1 的灯，其中K = 0,1,2....。已知在C次操作后其中几个灯的状态，给出所有灯在这C次操作后所有可能的状态。
 
方法：
 
　　通过观察可以发现，这些灯一共可以分成4种，同种灯无论在何种操作下，状态都是相同的。即：（1）编号为1,7,13,19....的灯。（2）编号为4,10,16,22....的灯。（3）编号为奇数，但是不属于（1）的灯。 （4）编号为偶数，但是不属于（2）的灯。
 
　　　　对于第（1）种灯，唯1,2,4号开关能够控制，且这些开关的作用是等效的。
 
　　　　对于第（2）种灯，唯有1,3号开关能够控制，且这些开关的作用是等效的。
 
　　　　对于第（3）种灯，唯有1,2号开关能够控制，且这些开关的作用是等效的。
 
　　　　对于第（4）种灯，唯有第1,3,4号开关能够控制，且这些开关的作用是等效的。
 
　　同一个开关无论按动多少次，其效果只有两种。即所有奇数次的按动的效果与按动一次相同；所有偶数次的按动与不按动的效果也相同。
 
　　现在只需将这四个开关的按动次数按奇偶枚举（共有2 * 2 * 2 * 2 = 16种情况），然后与已知的C次操作后的灯的状态对比即可，若符合，则为潜在的正确答案。这里说是“潜在”的答案，是因为还需要考虑该开关组合能否在C次操作内完成。不可能的情况共有2种：（1）按动奇数次的开关的个数大于C。（2）按动奇数次的开关的个数与C的奇偶性不同。排除这两种情况之后，便得到了正确答案。
 
附代码：
 
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
using namespace std;
bool isEven(int x){
    return (x % 2 == 0);
}
bool is3K1(int x){
    return ((x - 1) % 3 == 0);
}
int main(){
    int N, C;
    int isOn[4] = {0};
    cin >> N >> C;
    vector<string> result;int temp;
    while(1){
        cin >> temp;
        if(temp == -1)
            break;
        if(is3K1(temp) && isEven(temp)){
            isOn[3] = 1;    
        }else if(is3K1(temp) && ! isEven(temp)){
            isOn[0] = 1;
        }else if(isEven(temp)){
            isOn[1] = 1;    
        }else{
            isOn[2] = 1;    
        }
    }
    while(1){
        cin >> temp;
        if(temp == -1)
            break;
        if(is3K1(temp) && isEven(temp)){
            isOn[3] = -1;    
        }else if(is3K1(temp) && ! isEven(temp)){
            isOn[0] = -1;
        }else if(isEven(temp)){
            isOn[1] = -1;    
        }else{
            isOn[2] = -1;    
        }
    }
    for(int i = 0; i < 16; i++){
        string temp(N, '1');
        bool on[4] = {0};
        if((i & 1) == 0)
            on[0] = 0;
        else
            on[0] = 1;
        if((i & 2) == 0)
            on[1] = 0;
        else
            on[1] = 1;
        if((i & 4) == 0)
            on[2] = 0;
        else
            on[2] = 1;
        if((i & 8) == 0)
            on[3] = 0;
        else
            on[3] = 1;
        if((on[0] + on[1] + on[3]) % 2 == 0){
            if(isOn[0] == -1)
                continue;
        }else{
            if(isOn[0] == 1)
                continue;
        }
        if((on[0] + on[2]) % 2 == 0){
            if(isOn[1] == -1)
                continue;
        }else{
            if(isOn[1] == 1)
                continue;
        }
        if((on[0] + on[1] ) % 2 == 0){
            if(isOn[2] == -1)
                continue;
        }else{
            if(isOn[2] == 1)
                continue;
        }
        if((on[0] + on[2] + on[3]) % 2 == 0){
            if(isOn[3] == -1)
                continue;
        }else{
            if(isOn[3] == 1)
                continue;
        }
        if((on[0] + on[1] + on[2] + on[3]) % 2 != C % 2)
            continue;
        if((on[0] + on[1] + on[2] + on[3]) > C)
            continue;
        if(on[0] == 1){
            for(int i = 0; i < temp.size(); i++)
                if(temp[i] == '0')
                    temp[i] = '1';
                else
                    temp[i] = '0';
        }
        if(on[1] == 1){
            for(int i = 0; i < temp.size(); i += 2){
                if(temp[i] == '0')
                    temp[i] = '1';
                else
                    temp[i] = '0';
            }
        }
        if(on[2] == 1){
            for(int i = 1; i < temp.size(); i += 2){
                if(temp[i] == '0')
                    temp[i] = '1';
                else
                    temp[i] = '0';
            }
        }
        if(on[3] == 1){
            for(int i = 0; i < temp.size(); i += 3)
                if(temp[i] == '0')
                    temp[i] = '1';
                else
                    temp[i] = '0';
        }
        result.push_back(temp);
    }
    sort(result.begin(), result.end());
    for(int i = 0; i < result.size(); i++)
        cout << result[i] << endl;;
}

"
61,"最简单的DP，POJ2760数字三角形。。。_王彪_NEU_新浪博客

 
  2760:数字三角形 
 
 
  
  查看 
   提交 
   统计 
   提示 
   提问 
  
 
 
  
  
    时间限制:
    
   
  
    1000ms
   
  
    
   
   
   内存限制: 
   
  
    65536kB
   
  
  
  
    描述
   
   
    
    
7
3   8
8   1   0
2   7   4   4
4   5   2   6   5
(图1)
 图1给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。
   
 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。
   
  
    输入
   
  
    输入的是一行是一个整数N (1 < N <= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。
   
  
    输出
   
  
    输出最大的和。
   
  
    样例输入
   
   
   
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5

   
  
    样例输出
   
   
   
30
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include
using namespace std;
int main()
{
        int m[100][100],sum[100][100];
        int i,j,k,max;
        max=0;
        cin>>k;
        for(i=0;i<</SPAN>k;i++) { for(j=0;j<=i;j++) { cin>>m[i][j]; sum[i][j]=0; } } sum[0][0]=m[0][0]; for(i=1;i<</SPAN>k;i++) { for(j=0;j<=i;j++) { if((m[i][j]+sum[i-1][j-1])<(m[i][j]+sum[i-1][j]))sum[i][j]=m[i][j]+sum[i-1][j]; else sum[i][j]=m[i][j]+sum[i-1][j-1]; } } for(i=0;i<</SPAN>k;i++) { if(max<</SPAN>sum[k-1][i])max=sum[k-1][i]; } cout<<max<<endl; return 0; }
"
62,"poj1118题，超时，麻烦大哥大姐帮忙改一下..._百度知道

不要用cin 用scanf 如果还不行的话 只能用排序来优化了"
63,"POJ 3544 Journey with Pigs 贪心 - 水 - 博客频道 - CSDN.NET

首先根据村庄离A的距离和单位路程的花费，以及当地猪肉的价格，我们可以把到达每一个村庄卖猪单位重量赚的钱算出来。然后，按收益降序排列，再把猪的重量降序排序，这时，根据排序不等式，就可以达到最大盈利了。
所谓排序不等式：
排序不等式（sequence inequality,又称排序原理
设有两组数 a1 , a2 ,…… an; b1 , b2 ,…… bn 满足 a1 ≤ a2 ≤……≤ an, b1 ≤ b2 ≤……≤ bn ，其中c1,c2,……,cn是b1,b2,……，bn的任一排列，则有
a1* bn + a2 *b{n-1}+ ... + an *b1
≤ a1 *c1 + a2* c2 +……+ an *cn
≤ a1 *b1 + a2 *b2 + ……+an* bn.
当且仅当 a1 = a2 = ... = an 或 b1 = b2 = ... = bn 时等号成立，即反序和等于顺序和。
以上排序不等式也可简记为： 反序和≤乱序和≤同序和.

 /*
ID: sdj22251
PROG: calfflac
LANG: C++
*/
#include <iostream>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <string>
#include <cstring>
#include <cmath>
#include <ctime>
#define LOCA
#define PI acos(-1.0)
using namespace std;
struct village
{
    __int64 price, dis, profit;
    int id;
}p[1001];
struct zhu
{
    __int64 weight;
    int id;
}pig[1001];
bool cmp1(village a, village b)
{
    return a.profit > b.profit;
}
bool cmp2(zhu a, zhu b)
{
    return a.weight > b.weight;
}
int main()
{
#ifdef LOCAL
    freopen(""calfflac.in"",""r"",stdin);
    freopen(""calfflac.out"",""w"",stdout);
#endif
    int n, i;
    __int64 t;
    scanf(""%d%I64d"", &n, &t);
    for(i = 0; i < n; i++)
    {
        scanf(""%I64d"", &pig[i].weight);
        pig[i].id = i + 1;
    }
    sort(pig, pig + n, cmp2);
    for(i = 0; i < n; i++)
    {
        scanf(""%I64d"", &p[i].dis);
    }
    for(i = 0; i < n; i++)
    {
        scanf(""%I64d"", &p[i].price);
        p[i].id = i + 1;
        p[i].profit = p[i].price - p[i].dis * t;
    }
    sort(p, p + n, cmp1);
    int ans[1001];
    for(i = 0; i < n; i++)
    {
        ans[p[i].id] = pig[i].id;
    }
    for(i = 1; i < n; i++)
    printf(""%d "", ans[i]);
    printf(""%d\n"", ans[n]);
	return 0;
}
 
"
66,"谁能够帮忙把POJ1706的源代码编出来啊？谢谢了！_百度知道

#include <stdio.h>
#include <string.h>
#include <ctype.h>
char line[100];       //当前处理的那一行
char ref[3002][83];      //记录Reference description
int orig[1002], now[1002], st[1002]; //分别是原始编号，现在编号，分配空间的起始行
int p, num, tt;
bool empty(char a[])     //判断是否是空行
{
 int i;
 for (i = 0; a[i] != 0; i++)
  if (a[i] != ' ')
   return false;
 return true;
}
int getnum(char a[], int &k)   //从字符数组中获取 数
{
 int tmp = 0;
 for (; isdigit(a[k]); k++)
  tmp = tmp * 10 + a[k] - '0';
 return tmp;
}
int find(int x)       //找原始编号为x的Reference的位置
{
 int i;
 for (i = 0; i < p; i++)
  if (orig[i] == x)
   return i;
 return -1;
}
void proc()        //处理正文
{
 int k, tmp, q;
 for (k = 0; line[k] != 0; k++)
  if (line[k] == '[')    //若引用Reference，则重新给它一个编号
  {
   k++;
   tmp = getnum(line, k);
   if ((q = find(tmp)) == -1) //若没有记录过当前Reference，则分配新的编号
   {
    orig[p] = tmp; now[p] = num; st[p] = 0;
    q = p;
    p++; num++;
   }
   else
    if (now[q] == -1)  //否则若没有分配编号，则分配
    {
     now[q] = num;
     num++;
    }
   printf(""[%d]"", now[q] + 1);
  }
  else
   printf(""%c"", line[k]);  //其他数据正常输出
 printf(""\n"");
}
int main()
{
 bool rec, emptyline, cont;
 int k, tmp, q, i, j;
 tt = p = num = 0; rec = 0; emptyline = 1; cont = 1;
 while (gets(line))
 {
  if (!empty(line))    //非空行
  {
   if (line[0] == '[' && !cont)//若是Reference description的首行则记录
   {
    k = 1;
    tmp = getnum(line, k);
    if ((q = find(tmp)) == -1)
    {
     orig[p] = tmp;
     now[p] = -1;
     st[p] = tt;
     p++;
    }
    else
     st[q] = tt;
    strcpy(ref[tt], line);
    tt++;
    rec = 1;
   }
   else
    if (rec)    //是Reference description的接下去几行
    {
     strcpy(ref[tt], line);
     tt++;
    }
    else     //是正文
    {
     emptyline = 0;
     proc();
    }
  }
  else
  {
   rec = 0; cont = 0;   //若是空行，则多于一个空行只输出一个
   if (!emptyline)
   {
    printf(""\n"");
    emptyline = 1;
   }
  }
 }
 for (i = 0; i < p; i++)    //输出Reference description
 {
  for (j = 0; j < p; j++)   //按照顺序输出
   if (now[j] == i)
    break;
  j = st[j];
  printf(""[%d]"", i + 1);
  k = 1;
  getnum(ref[j], k);
  k++;
  for (; ref[j][k] != 0; k++)
   printf(""%c"", ref[j][k]);
  printf(""\n"");
  j++;
  while (j < tt && ref[j][0] != '[')
  {
   puts(ref[j]);
   j++;
  }
  if (i != p - 1)
   printf(""\n"");
 }
 return 0; 
}"
67,"poj2007 - Rainy Days - 博客园

极坐标排序
注意atan2(y,x)的使用方法，y在前，x在后。返回X轴正方向到原点到（x，y）点的射线的到角。
 

 
 
 View Code  
  
  #include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
#define maxn 55
#define pi acos(-1)
struct Point
{
    int x, y;
} point[maxn];
bool operator <(const Point &a, const Point &b)
{
    return atan2(a.y, a.x) < atan2(b.y, b.x);
}
double cal(double a)
{
    if (a < 0)
        return a + 2 * pi;
    return a;
}
int main()
{
    //freopen(""t.txt"", ""r"", stdin);
    scanf(""%d%d"", &point[0].x, &point[0].y);
    int n = 0;
    while (scanf(""%d%d"", &point[n].x, &point[n].y) != EOF)
        n++;
    sort(point, point + n);
    double temp = 0;
    point[n] = point[0];
    int s;
    for (int i = 0; i < n; i++)
    {
        double a = cal(atan2(point[i + 1].y, point[i + 1].x) - atan2(point[i].y, point[i].x));
        if (a > temp)
        {
            temp = a;
            s = (i + 1) % n;
        }
    }
    printf(""(0,0)\n"");
    for (int i = 0; i < n; i++)
        printf(""(%d,%d)\n"", point[(s + i) % n].x, point[(s + i) % n].y);
    return 0;
} 
  
 

"
68,"POJ3072—Robot Dijkstra实现 - 飞翔的小鸟 - 博客频道 - CSDN.NET

简单的Dijkstra题目，稍微转个弯就可以了，因为要计算由一个点转到另一个点时所需的时间，所以可以设置一个结构体，用个成员变量记载该点到起点的距离，距离是起点到该点的直线距离加上上一个点转向该点的角度（一个角度需时一秒），然后再用Dijkstra求解就很简单了。
 
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
const int maxn=22;
const double pi=atan(1.0)*4;
const double inf=100000000;
bool visit[maxn];
int r,n;
struct node
{
    int x;
    int y;
    double len;           //与起点的距离
    double degree;        //与x轴的夹角
}point[maxn];
double dist(node *p,node *q)  //计算距离
{
    return sqrt((p->x-q->x)*(p->x-q->x)*1.0+(p->y-q->y)*(p->y-q->y)*1.0);
}
double getDegree(node *cur,node *next)       //计算两点连线与x轴的夹角
{
    int x,y;
    double degree;
    x=next->x-cur->x;
    y=next->y-cur->y;
    degree=atan2(double(y),double(x));    //夹角的范围是-pi到pi，不包括-pi
    return degree;
}
double calDegree(node *cur,node *next,double °) //由cur点转到next点转过的角度
{
    double degree,ans;
    degree=getDegree(cur,next);
    deg=degree;
    ans=fabs(degree-cur->degree);
    if(ans>pi)                                 //转角的大小不超过Pi
    ans=2*pi-ans;
    return ans;
}
void update(node *cur,node *next)
{
    double length,tmplen,tmpdeg;
    tmplen=dist(cur,next);
    if(tmplen>r)
    return ;
    length=calDegree(cur,next,tmpdeg)*180/pi+tmplen+cur->len;
    if(length<next->len)
    {
        next->len=length;
        next->degree=tmpdeg;
    }
}
void Dijkstra()
{
    int i,u;
    double min;
    while(!visit[n-1])
    {
        u=-1;
        min=inf;
        for(i=0;i<n;i++)
        if(!visit[i] && point[i].len<min)
        {
            min=point[i].len;
            u=i;
        }
        if(u==-1)
        break;
        visit[u]=true;
        for(i=0;i<n;i++)
        if(!visit[i])
        update(&point[u],&point[i]);
    }
    if(!visit[n-1])
    printf(""impossible\n"");
    else
    printf(""%d\n"",(int)(point[n-1].len+0.5));
}
int main()
{
    int i,j;
    while(scanf(""%d%d"",&r,&n))
    {
        if(r==-1 && n==-1)
        break;
        for(i=0;i<n;i++)
        {
            scanf(""%d%d"",&point[i].x,&point[i].y);
            point[i].len=inf;
        }
        point[0].degree=getDegree(&point[0],&point[n-1]);
        point[0].len=0;
        memset(visit,0,sizeof(visit));
        Dijkstra();
    }
    return 0;
}
"
69,"POJ 3585 一道很好的树DP - ronaflx - 博客园

题目要求给一棵加权无向树，求每个点到叶子节点的最大流量。范围20万。
必须是O(N)的树DP才行。
首先固定一个为根，做一次DFS，求每个节点到其子树的叶子节点的流量和son[i]，以及每个节点对其父亲节点的贡献belong[i]，还有每个点和他父亲节点的边权edge[i]。然后对每个节点做一次记忆化搜索，顺着第一次搜索的边反向搜索。DP的转移方程是
dp[i] = min(dp[father[i]] - belong[i], dege[i])  + son[i];
解题的过程比较坎坷。首先状态转移方程多次修改，导致第一次DFS所要求的东西不明确，所以改了好多次。这是写DP的一大忌讳……没确定转移过程就开始写题
确定转移方程以后，有一种特殊的情况没有处理好，就是当固定的根是个度为1的点时，需要特殊处理。思考问题需要群面。
一下为此题的代码：
 

 
 
 POJ 3585 
  
    1 /*
  2  * =====================================================================================
  3  *
  4  *       Filename:  dp.cpp
  5  *
  6  *    Description:  tree dp problem
  7  *
  8  *        Version:  1.0
  9  *        Created:  2011年07月22日 13时41分18秒
 10  *       Revision:  none
 11  *       Compiler:  gcc
 12  *
 13  *         Author:  ronaflx
 14  *        Company:  hit-ACM-Group
 15  *
 16  * =====================================================================================
 17  */
 18 #include <cstdlib>
 19 #include <cctype>
 20 #include <cstring>
 21 #include <cstdio>
 22 #include <cmath>
 23 #include <ctime>
 24 #include <climits>
 25 #include <algorithm>
 26 #include <functional>
 27 #include <numeric>
 28 #include <vector>
 29 #include <map>
 30 #include <set>
 31 #include <queue>
 32 #include <stack>
 33 #include <bitset>
 34 #include <list>
 35 #include <string>
 36 #include <iostream>
 37 #include <sstream>
 38 #include <fstream>
 39 #include <iomanip>
 40 #include <stdexcept>
 41 #include <utility>
 42 #include <cassert>
 43 #include <complex>
 44 using namespace std;
 45 #define LEFT(i) ((i) << 1)
 46 #define RIGHT(i) (((i) << 1) | 1)
 47 #define MID(i) ((l[i] + r[i]) >> 1)
 48 #define CC(i, v) memset(i, v, sizeof(i))
 49 #define REP(i, l, n) for(int i = l;i < int(n);++i)
 50 #define FOREACH(con, i) for(__typeof(con.begin()) i = con.begin();i != con.end();++i)
 51 const int N = 200000;
 52 const long long INF = (long long) N * N;
 53 vector<pair<int, long long> > adj[N];
 54 long long son[N], dp[N], belong[N], edge[N];
 55 int father[N];
 56 long long DP(int x)
 57 {
 58     if(x == -1) return 0;
 59     if(dp[x] != - 1 && x != 0) return dp[x];
 60     if(x == 0)
 61     {
 62         dp[x] = son[x];
 63         if(adj[x].size() == 1) return adj[x][0].second * 2;
 64         else return dp[x];
 65     }
 66     long long ans = (min(DP(father[x])  - belong[x], father[x] == -1 ? 0 : edge[x]) + son[x]);
 67     dp[x] = ans;
 68     return dp[x];
 69 }
 70 long long dfs(int x, int pre)
 71 {
 72     father[x] = pre;
 73     int isLeaf = true;
 74     FOREACH(adj[x], i)
 75     {
 76         if(i->first == pre) edge[x] = i->second;
 77         else
 78         {
 79             isLeaf = false;
 80             int score = min(i->second, dfs(i->first, x));
 81             son[x] += score;
 82             belong[i->first] = score;
 83         }
 84     }
 85     return (isLeaf ? edge[x] : son[x]);
 86 }
 87 
 88 
 89 int main()
 90 {
 91     int t, n, v, u, c;
 92     scanf(""%d"", &t);
 93     while(t--)
 94     {
 95         scanf(""%d"", &n);
 96         for(int i = 0;i < n;i++) adj[i].clear();
 97         CC(son, 0);
 98         CC(dp, -1);
 99         for(int i = 1;i < n;i++)
100         {
101             scanf(""%d%d%d"", &v, &u, &c);
102             v--, u--;
103             adj[v].push_back(make_pair(u, (long long)c));
104             adj[u].push_back(make_pair(v, (long long)c));
105         }
106         dfs(0, -1);
107         for(int i = 0;i < n;i++)
108             DP(i);
109 //        for(int i = 0;i < n++) printf(""%lld %d %lld\n"", son[i], father[i], dp[i]);
110         printf(""%lld\n"", *max_element(dp, dp + n));
111     }
112     return 0;
113 } 
  
"
71,"poj1016 - 冰上游鱼 - 博客频道 - CSDN.NET

#include<iostream>
#include<stdio.h>
#include<stdlib.h>
#include<fstream>
#include<string>
using namespace std;
string change(string s)
{
	string output="""";
	int len=s.length();
	int count[10]={};
	for(int i=0;i<len;i++)
	{
		count[s[i]-'0']++;
	}
	for(int i=0;i<10;i++)
	{
		if(count[i]>0)
		{
			char temp[33];
		        sprintf(temp,""%d"",count[i]);
			output+=temp;
			output+=char('0'+i);
		}
	}
	return output;
}
int main()
{
	ifstream cin(""input.txt"");
	ofstream cout(""output.txt"");
	string str[16];
	while(cin>>str[0])
	{
		if(str[0]==""-1"")
			break;
		bool flag=false;
		for(int i=1;i<=15;i++)
		{
			str[i]=change(str[i-1]);
		//	cout<<str[i]<<"" ""<<str[i-1]<<endl;
			int m;
			for(m=0;m<i;m++)
			{
				if(str[m]==str[i])
				{
					flag=true;
					break;
				}
			}
			if(m==i-1)
			{
				if(m==0)
					cout<<str[0]<<"" is self-inventorying ""<<endl;
				else
					cout<<str[0]<<"" is self-inventorying after ""<<i-1<<"" steps ""<<endl;
			}
			else if(m<i-1)
			{
				cout<<str[0]<<"" enters an inventory loop of length ""<<i-m<<"" ""<<endl;
			}
			if(flag)
				break;
		}
		if(flag==false)
			cout<<str[0]<<"" can not be classified after 15 iterations""<<endl;
	}	
	return 0;
}

"
72,"poj2756二叉树 -  - 博客频道 - CSDN.NET

出去兴趣做做这些。牛人可以直接无视..
 
/*
		Author:snowflake
		Time:2012/4/9
		desc:poj2756简单题 
*/
/*
结题报告：这题就是找到一个最先能使两个点重合的节点，依次枚举两个数所经历的节点，
直到根节点，然后在对比其内容。 
*/
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
	int x, y;
	while(cin >> x >> y)
	{
		int a[10], b[10], i = 0, j = 0;
		while(x)
		{
			a[i] = x;
			x = (int)floor(x / 2);
			i++;
		}
		while(y)
		{
			b[j] = y;
			y = (int)floor(y / 2);
			j++;
		}
		int ok = 0;
		for(int p = 0; p < i; p++)
		{
			for(int q = 0; q < j; q++)
			{
				if(a[p] == b[q])
				{
					cout << a[p] << endl;
					ok = 1;
				}
			}
			if(ok) break;
		}
	}
	return 0;
}

"
73,"【转】pku1178解题报告_honesty2008_百度空间

http://162.105.81.212/JudgeOnline/problem?id=1178
题意：一个棋盘（8*8），一个王，还有n个马（n不确定），马有马的走法，王有王的走法，还有当王和马走到一个格子上时，马可以带着王走，输入一串字符，字母代表x坐标，数字代表y坐标，问最少经过多少步可以使棋盘上的棋子都到达同一个格子？
分析：先按照马走的线路建图，然后用floyd算出每两个点之间的最小步数，接着就是枚举，第一步枚举可能的汇聚点，第二步枚举一个马带走王的点，最后就是枚举每个马的位置，计算出最小的步数。
代码及部分注释：
#include<stdio.h>
#include<string.h>
#include<math.h>
#define MAX 70
#define INF 1<<29
int sx,sy;
int dx[MAX],dy[MAX];
char ch[MAX*2];
int cnt;
int ix[]={1,1,-1,-1,2,2,-2,-2};
int iy[]={2,-2,2,-2,1,-1,1,-1};
int dis[MAX][MAX];
int max(int a,int b)
{
    if(a>b)return a;
    else return b;
}
bool check(int x,int y)
{
    return (x>=0&&y>=0&&x<8&&y<8);
}
void init()//建图 以马走的路线建图 
{
    int i,j,k,x,y;
   // memset(dis,0,sizeof(dis));
   for(i=0;i<64;i++)
   for(j=0;j<64;j++)
     dis[i][j]=INF;
    for(i=0;i<8;i++)
    for(j=0;j<8;j++)
    for(k=0;k<8;k++)
     {
        x=ix[k]+i;
        y=iy[k]+j;
       if(!check(x,y))continue; 
        dis[i*8+j][x*8+y]=dis[x*8+y][i*8+j]=1;
     }
}
void floyd()
{ 
    int i,j,k;
    for(k=0;k<64;k++)
    for(i=0;i<64;i++)
    for(j=0;j<64;j++)
     {
      if(dis[i][j]>dis[i][k]+dis[k][j])
       dis[i][j]=dis[i][k]+dis[k][j]; 
     } 
for(i=0;i<64;i++)
    dis[i][i]=0;
}
void fun()
{
    int i,j,c,k,tmp,ans=INF,min;
    for(i=0;i<64;i++)//枚举可能的汇集点 
    for(j=0;j<64;j++)//枚举可能的带走王的位置 
     {
        tmp=max(abs(j%8-sx),abs(j/8-sy));//王走的步数 
        min=INF;
    for(c=0;c<cnt;c++)
     {
         k=dx[c]+dy[c]*8;
         tmp+=dis[i][k];//每个马到汇集点的距离 
        if(dis[i][j]+dis[k][j]-dis[i][k]<min)
         min=dis[i][j]+dis[k][j]-dis[i][k];//选择最少的带走王的马 
     }
     tmp+=min;
    if(ans>tmp)ans=tmp; 
     } 
    if(ans==INF)ans=0;
     printf(""%d\n"",ans);
}
int main()
{
    int i;
    while(scanf(""%s"",ch)!=EOF)
     {
         sx=ch[0]-'A';
         sy=ch[1]-'1';
         cnt=0;
        for(i=2;i<strlen(ch);i+=2)
         {
           dx[cnt]=ch[i]-'A';
           dy[cnt++]=ch[i+1]-'1'; 
         }
         init();
         floyd();
         fun();
     }
}
/*
Sample Input
D4A3A8H1H8
Sample Output
10
A1A2A3H2H5H6H7H8C1C2C5C6C7E2E3E4E5E6E7E8
42
*/
"
75,"pku1094 Sorting It All Out(传递闭包+拓扑排序)_Archer&me_百度空间

http://acm.pku.edu.cn/JudgeOnline/problem?id=1094
这个题目意思是说给出n个大写字幕，和m个<的关系，根据这m句话可以得到三种结果：
Sorted sequence determined after xxx relations: yyy...y. 
Sorted sequence cannot be determined. 
Inconsistency found after xxx relations.
第一个结果是说根据m中前k个关系，可以确定下n个字母的由小到大的关系，并输出。
第二个是说不能确定这n个字符的关系。
第三个是说产生矛盾。
用map[i][j]表示i<j的关系（即i,j有边连）。
求传递闭包，当增加一条关系时，对应的改变图的连通性。
首先，我们要判定是否产生矛盾最简单，就是当存在环是即存在map[i][i]=1，可判定。
如果当n个顶点的度都为n-1时，可以判定可以确定这个排列。
其他情况就是Sorted sequence cannot be determined. 的情况了！
#include <iostream>
using namespace std;
int n,m;
int map[30][30];
int reg[100];
int in[30],out[30];
char ans[30];
int stack[30];
void fun()
{
     int i,j;
     for(i='A',j=1;i<='Z';i++,j++)reg[i]=j;
}
void toposort(char *ans)
{
    int i,top=0,u,s=0;
    for(i=1;i<=n;i++)
     if(in[i]==0)stack[top++]=i;
    while(top!=0)
    {
       u=stack[--top];
       ans[s++]=u+64;
       for(i=1;i<=n;i++)
       {
         if(map[u][i])
         {
            in[i]--;
            if(!in[i])stack[top++]=i;
         }
       }
    }
    ans[s]=0;
}
int main()
{
    int i,j,x,y,k,flag1,flag2,flag;
    fun();
    char ch[5];
    while(1)
    {
      flag1=flag2=0;
      memset(map,0,sizeof(map));
      scanf(""%d%d"",&n,&m);
      if(n==0&&m==0)break;
      for(i=1;i<=m;i++)
      {
         flag=1;
         scanf(""%s"",ch);
         x=reg[ch[0]];
         y=reg[ch[2]];
         map[x][y]=1;
         if(x==y)flag1=i;
         memset(in,0,sizeof(in));
         memset(out,0,sizeof(out));
         if(!flag1&&!flag2)
         for(j=1;j<=n;j++)
          for(k=1;k<=n;k++)
          {
             if(j!=x&&k!=y)map[j][k]=map[j][k]||(map[j][x]&&map[y][k]);
             if(j==x&&k!=y)map[j][k]=map[j][k]||map[y][k];
             if(j!=x&&k==y)map[j][k]=map[j][k]||map[j][x];
             if(map[j][k])
             {
               out[j]++;
               in[k]++;
             }
          }
         j=1;
         if(!flag1)
         for(j=1;j<=n;j++)
         {
           if(map[j][j])flag1=i;
           if(in[j]+out[j]!=n-1)flag=0;
         }
         if(flag&&!flag2&&j>n){flag2=i;toposort(ans);}
      }
      if(flag2)
      {
         printf(""Sorted sequence determined after %d relations: %s.\n"",flag2,ans);
         continue;
      }
      if(flag1)
      {
         printf(""Inconsistency found after %d relations.\n"",flag1);
         continue;
      }
      printf(""Sorted sequence cannot be determined.\n"");
    }
    return 0;
}
pku3660 求传递闭包
"
81,"poj3183解题报告_水过境迁…_百度空间

水淋淋的题目，注意边缘数据就成了，炸突起的或者是平的
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int a[50010];
    int n;
    scanf(""%d"",&n);
    for(int i=0;i<n;i++)    scanf(""%d"",&a[i]);
    int i=1;
    if(a[0]>=a[1])
        cout<<""1""<<endl;
    while(i<n)
    {
        if(a[i-1]<=a[i]&&a[i]>=a[i+1])
            cout<<i+1<<endl;
        i++;
    }
    return 0;
}
"
84,"pku3233_chenjiang_百度空间

/* 
* File:   pku3233.cpp
* Author: chenjiang
*第一个矩阵乘法的题目，调试了n久才对啊。
* Created on 2010年7月8日, 下午4:58
*/
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <string.h>
#include <queue>
#include <stack>
#include <algorithm>
#include <cstdio>
#include <map>
#include <bitset>
#include <math.h>
#include <time.h>
#include <vector>
#include <set>
using namespace std;
int n, k, m;
struct matrix
{
    int mat[40][40];
    void Init();
    void print();
    matrix operator+(matrix);
    matrix operator*(matrix);
    matrix pow(int K);
    matrix add(int K);
};
void matrix::Init()
{
    int i,j;
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            mat[i][j]=0;
}
void matrix::print()
{
    int i,j;
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
        {
            if(j<n)
                printf(""%d "",mat[i][j]);
            else
                printf(""%d\n"",mat[i][j]);
        }
}
matrix matrix::operator +(matrix t)
{
    int i,j;
    matrix temp;
    temp.Init();
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            temp.mat[i][j]=mat[i][j]+t.mat[i][j];
            if(temp.mat[i][j]>=m)
                temp.mat[i][j]%=m;
        }
    }
    return temp;
}
matrix matrix::operator *(matrix t)
{
    int i,j,s;
    matrix temp;
    temp.Init();
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            for(s=1;s<=n;s++)
            {
                temp.mat[i][j]+=mat[i][s]*t.mat[s][j];
                if(temp.mat[i][j]>=m)
                    temp.mat[i][j]%=m;
            }
        }
    }
    return temp;
}
matrix matrix::pow(int K)
{
    matrix t=(*this)*(*this);
    if(K==1)
        return (*this);
    else if(K&1)
    {
        return t.pow(K>>1)*(*this);
    }
    else
        return t.pow(K>>1);
}
matrix matrix::add(int K)
{
    if(K==1)
        return (*this);
    else if(K&1)
    {
        return add(K-1)+pow(K);
    }
    else
    {
        matrix t=add(K>>1);
        return t+t*pow(K>>1);
    }
}
/*
* 
*/
int main(int argc, char** argv) {
    matrix t;
    int i, j;
    while (scanf(""%d%d%d"", &n, &k, &m) != EOF) {
        t.Init();
        for (i = 1; i <= n; i++) {
            for (j = 1; j <= n; j++) {
                scanf(""%d"", &t.mat[i][j]);
            }
        }
        t.add(k).print();
    }
    return (EXIT_SUCCESS);
}
"
86,"PKU 3233_一杯茶 一根烟  写代码!_百度空间

题目大意：
求解A^1+A^2+A^3+....+A^(k-1)+A^k（A是N阶方阵）
这个题目有两种算法解决：
算法一:
构造方阵法
设：A^1+A^2+A^3+....+A^(k-1)+A^k==B;
E==N阶单位方阵
则可以构造2*N阶方阵
       B       E
C= O      E
C^(k+1)==A^k   B+E
                O       E
最后我们只要去求C^(k+1)的右上方N矩阵减去一个E就行了！
CODE:
#include<stdio.h>
#include<math.h>
#include<string.h>
#include<time.h>
const int MAX=65;
int N,K,M;
//将一个整数转化为二进制用数组存储
void Change(int n,int *b)
{
    int k=1,j,t;
    while(n)
    {
        b[k++]=n%2;
        n/=2;
    }
    b[0]=k-1;
    for(j=1;j<=k/2;j++)
    {
        t=b[j];
        b[j]=b[k-j];
        b[k-j]=t;
    }
}
//c[][]=(a[][]*b[][])%10000
void Mult(int a[][MAX],int b[][MAX],int c[][MAX])
{
int i,j,k;
for(i=1;i<=2*N;i++)
   for(j=1;j<=2*N;j++)
   {
    int ans=0;
    for(k=1;k<=2*N;k++)
     ans=(ans+a[i][k]*b[k][j])%M;
    c[i][j]=ans;
   }
}
void Copy(int a[][MAX],int b[][MAX])
{
int i,j;
for(i=1;i<=2*N;i++)
   for(j=1;j<=2*N;j++)
    a[i][j]=b[i][j];
}
//A^n%m
void ModPow(int A[][MAX],int k,int ans[][MAX])//init ans[][]=n阶单位矩阵
{
int i;
        int a[105];
int x[MAX][MAX];
int y[MAX][MAX];
Change(k,a);//将n转化为2进制 
for(i=1;i<=a[0];i++)
{
   Copy(x,ans);
   Copy(y,ans);
   Mult(x,y,ans);//ans*=ans;
   if(a[i])
   {
    Copy(x,ans);
    Mult(x,A,ans);//ans*=A;
   }
}
}
int main()
{
int A[MAX][MAX];
int ans[MAX][MAX];
int i,j;
FILE *in;
FILE *out;
in=fopen(""in.txt"",""r"");
out=fopen(""out.txt"",""w"");
while(scanf(""%d%d%d"",&N,&K,&M)!=EOF)
{
   memset(A,0,sizeof(A));
   memset(ans,0,sizeof(ans));
   for(i=1;i<=N;i++)
   for(j=1;j<=N;j++)
   {
     scanf(""%d"",&A[i][j]);
     A[i][j]%=M;
   }
   for(i=1;i<=N;i++)
   A[i][i+N]=1,ans[i][i]=1;
   for(i=N+1;i<=2*N;i++)
   A[i][i]=1,ans[i][i]=1;
   ++K;
         int st=clock();
         ModPow(A,K,ans);//A^K%M
   //最后的矩阵右上子矩阵减去一个N阶的单位矩阵,如果为负数加M再取莫
   for(i=1;i<=N;i++)
   ans[i][i+N]=(ans[i][i+N]-1+M)%M;
   int ed=clock();
   //printf(out,""time=%lf\n"",(double)(ed-st)/CLOCKS_PER_SEC);//检测花费的时间
   for(i=1;i<=N;i++)
   {
    for(j=N+1;j<=2*N-1;j++)
    printf(""%d "",ans[i][j]);
    printf(""%d\n"",ans[i][j]);
   }
}
return 0;
}
/*
2 2 4
0 1
1 1
1 2
2 3
*/  
第2种算法：
思路：2分递归+2分快速幂指数算法(在下面的程序注释中解释的很详细)
关于2分递归算法
下面问题，可能会加深你的理解
例如：计算x^1+x^2+x^3+x^4+....+x^(k-1)^+x^k (x&&k都是整数)
我们可以2分递归解决这个问题
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>
int x,k;
int cal(int n)
{
int i,ans=1;
for(i=1;i<=n;i++)
   ans*=x;
return ans;
}
int MatrixSum(int k)
{
if(k==1)
   return x;
int tnow,temp;
temp=MatrixSum(k/2);
if(k&1)
{
   tnow=cal(k/2+1);
   temp=temp+temp*tnow+tnow;
}
else
{
   tnow=cal(k/2);
   temp=temp+temp*tnow;
}
return temp;
}
//2分递归计算:
//x^1+x^2+x^3+x^4+....+x^(k-1)^+x^k
int main()
{
while(scanf(""%d%d"",&x,&k)!=EOF)
{
   printf(""%d\n"",MatrixSum(k));
}
return 0;
}
CODE
#include<iostream>using namespace std;const int MAX=35;typedef struct Matrix{ int A[MAX][MAX];}Matrix;Matrix E;//单位矩阵Matrix ans;//结果矩阵Matrix init;//初始化矩阵int N,M,K;//z=(x+y)%MMatrix Add(Matrix x,Matrix y){ int i,j; Matrix z; for(i=1;i<=N;i++) for(j=1;j<=N;j++) { z.A[i][j]=x.A[i][j]+y.A[i][j]; z.A[i][j]%=M; } return z;}//Z=(x*y)%M;Matrix Mult(Matrix x,Matrix y){ int i,j,k; Matrix z; for(i=1;i<=N;i++) for(j=1;j<=N;j++) { z.A[i][j]=0; for(k=1;k<=N;k++) z.A[i][j]+=x.A[i][k]*y.A[k][j]; z.A[i][j]%=M; } return z;}//A^expMatrix Cal(int exp){ Matrix p,q; p=init;//p是初始矩阵 q=E;//q是单位矩阵 while(exp!=1) { if(exp&1)//幂指数是奇数 { exp--; q=Mult(p,q); } else//幂指数是偶数 { exp>>=1;//除于2 p=Mult(p,p); } } p=Mult(p,q); return p;}Matrix MatrixSum(int k){ if(k==1) return init;//最底层只有A了,返回A Matrix temp,now; //2分A+A^2+A^3+.....+A^k temp=MatrixSum(k/2);//A+A^2+A^3+.....+A^(k/2) if(k&1)//k为奇数 { now=Cal(k/2+1);//A^(k/2+1) /* temp=temp+temp*now+now==A+A^2+A^3+.....+A^k EG： A^1+A^2+A^3+A^4+A^4+A^5+A^6+A^7 =A^1+A^2+A^3+A^4+A^4*(A^1+A^2+A^3) =temp+now+temp*now */ temp=Add(temp,Mult(temp,now)); temp=Add(now,temp); } else//k为偶数 { now=Cal(k/2);//A^(k/2) /* temp=temp+temp*now==A+A^2+A^3+.....+A^k EG： A^1+A^2+A^3+A^4+A^4+A^5+A^6 =A^1+A^2+A^3+A^3*(A^1+A^2+A^3) =temp+temp*now */ temp=Add(temp,Mult(temp,now)); } return temp;}int main(){ int i,j; while(scanf(""%d%d%d"",&N,&K,&M)!=EOF) { for(i=1;i<=N;i++) for(j=1;j<=N;j++) { scanf(""%d"",&init.A[i][j]); init.A[i][j]%=M; E.A[i][j]=(i==j);//E单位矩阵 } ans=MatrixSum(K); for(i=1;i<=N;i++) { for(j=1;j<=N-1;j++) printf(""%d "",ans.A[i][j]); printf(""%d\n"",ans.A[i][j]); } } return 0;}/*2 2 40 11 11 22 3*/为了曾加程序的可读性，这里对+和*运算符重载应该是个不错的选择

CODE
#include<iostream>
using namespace std;
const int MAX=35;
int N,M,K;
typedef struct Matrix
{
int A[MAX][MAX];
//+号运算符重载
Matrix operator+(const Matrix &y)
{
       int i,j;
    Matrix z;
    for(i=1;i<=N;i++)
    for(j=1;j<=N;j++)
    {
      z.A[i][j]=A[i][j]+y.A[i][j];
         z.A[i][j]%=M;
    }
    return z;
}
//*号运算符重载
Matrix operator*(const Matrix &y)
{
        int i,j,k;
     Matrix z;
     for(i=1;i<=N;i++)
     for(j=1;j<=N;j++)
   {
       z.A[i][j]=0;
       for(k=1;k<=N;k++)
          z.A[i][j]+=A[i][k]*y.A[k][j];
       z.A[i][j]%=M;
   }
     return z;
}
}Matrix;
Matrix E;//单位矩阵
Matrix ans;//结果矩阵
Matrix init;//初始化矩阵
//A^exp
Matrix Cal(int exp)
{
   Matrix p,q;
   p=init;//p是初始矩阵
   q=E;//q是单位矩阵
   while(exp!=1)
   {
    if(exp&1)//幂指数是奇数
    {
     exp--;
     //q=Mult(p,q);
     q=p*q;
    }
    else//幂指数是偶数
    {
     exp>>=1;//除于2
     //p=Mult(p,p);
     p=p*p;
    }
   }
   //p=Mult(p,q);
   p=p*q;
   return p;
}
Matrix MatrixSum(int k)
{
if(k==1)
   return init;//最底层只有A了,返回A
Matrix temp,now;
//2分A+A^2+A^3+.....+A^k
temp=MatrixSum(k/2);//A+A^2+A^3+.....+A^(k/2)
if(k&1)//k为奇数
{
   now=Cal(k/2+1);//A^(k/2+1)
   /*
   temp=temp+temp*now+now==A+A^2+A^3+.....+A^k
   EG：
   A^1+A^2+A^3+A^4+A^4+A^5+A^6+A^7
     =A^1+A^2+A^3+A^4+A^4*(A^1+A^2+A^3)
   =temp+now+temp*now
   */
   temp=temp+temp*now+now;
}
else//k为偶数
{
   now=Cal(k/2);//A^(k/2)
   /*
        temp=temp+temp*now==A+A^2+A^3+.....+A^k
   EG：
   A^1+A^2+A^3+A^4+A^4+A^5+A^6
     =A^1+A^2+A^3+A^3*(A^1+A^2+A^3)
   =temp+temp*now
   */
   temp=temp+temp*now;
}
return temp;
}
int main()
{
int i,j;
while(scanf(""%d%d%d"",&N,&K,&M)!=EOF)
{
   for(i=1;i<=N;i++)
   for(j=1;j<=N;j++)
   {
   scanf(""%d"",&init.A[i][j]);
   init.A[i][j]%=M;
   E.A[i][j]=(i==j);//E单位矩阵
   }
   ans=MatrixSum(K);
   for(i=1;i<=N;i++)
   {
    for(j=1;j<=N-1;j++)
    printf(""%d "",ans.A[i][j]);
    printf(""%d\n"",ans.A[i][j]);
   }
}
return 0;
}
/*
2 2 4
0 1
1 1
1 2
2 3
*/
"
88,"poj2227 The Wedding Juicer_moonlight131_百度空间

这是黑书上的例题，需要用二叉堆，由于本人蒟蒻，不会自己写，只会用优先队列+dfs+bfs水过，希望读者谅解。
#include <stdlib.h>#include <iostream>#include <queue>using namespace std;const int maxn=305;int map[maxn][maxn];int use[maxn][maxn];struct NODE{ int val; int x,y;}R,P;int w,h,ans;priority_queue<NODE>Q;int move[4][2]={-1,0,0,1,1,0,0,-1};bool operator<(const NODE &a,const NODE &b){ return a.val>b.val;}void dfs(int x,int y){ int x0,y0; for(int i=0;i<4;i++) { x0=x+move[i][0]; y0=y+move[i][1]; if(x0>h||x0<1||y0>w||y0<1)continue; if(map[x0][y0]<map[R.x][R.y]) { int tmp=map[x0][y0]; map[x0][y0]=map[R.x][R.y]; if(use[x0][y0])continue; else { ans+=map[R.x][R.y]-tmp; use[x0][y0]=1; P.x=x0;P.y=y0;P.val=map[x0][y0]; Q.push(P); dfs(x0,y0); } } else { if(use[x0][y0])continue; else { use[x0][y0]=1; P.x=x0;P.y=y0;P.val=map[x0][y0]; Q.push(P); } } }}void bfs(){ for(int i=1;i<=w;i++) { R.val=map[1][i]; R.x=1;R.y=i; Q.push(R); use[R.x][R.y]=1; R.val=map[h][i]; R.x=h;R.y=i; Q.push(R); use[R.x][R.y]=1; } for(int i=2;i<h;i++) { R.val=map[i][1]; R.x=i;R.y=1; Q.push(R); use[R.x][R.y]=1; R.val=map[i][w]; R.x=i;R.y=w; Q.push(R); use[R.x][R.y]=1; } while(!Q.empty()) { R=Q.top(); Q.pop(); dfs(R.x,R.y); }}int main(int argc, char** argv) { cin>>w>>h; int s=0; ans=0; for(int i=1;i<=h;i++) for(int j=1;j<=w;j++) { scanf(""%d"",&map[i][j]); } bfs(); printf(""%d\n"",ans); return (EXIT_SUCCESS);}

"
90,"HDU1394 求最小逆序数 - 壹①肆陸的日志 - 网易博客

题意：给你一个循环的序列让你求最小逆序数

思路：我们先把以An为终结点的序列的逆序数求出来

         然后从a1开始枚举每一个终结点， 有 now = pre + gt - lt  （now 表示当前序列逆序数，pre表示前一个序列逆序数，gt表示序列中比当前终结点大的数的个数，lt表示比当前小的数的数目） 

代码：


#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
 int ans , lt, gt, i, j, n, pre, now;
 int seq[10010];
 while(scanf(""%d"",&n)!=EOF)
 {
        ans = 0;
 for(i=1;i<=n;i++)
 {
            scanf(""%d"",&seq[i]);
 }
 for(i=2;i<=n;i++)
 for(j=1;j<i;j++)
 if(seq[j]>seq[i])
                    ans ++;
        pre = ans;
 for(i=1;i<=n-1;i++)
 {
            gt = n - 1 - seq[i];
            lt = seq[i] ;
            now = pre - lt + gt;
 if(now<ans)
                ans = now;
            pre = now;
 }
        printf(""%d\n"",ans);
 }
 return 0;
}"
92,"poj1191______________________新浪博客

看了那本黑书，按照它的思路写了一下，对于动态规划还是陌生啊
#include<iostream>
 #include<cmath>
 #define MIN(a,b) ((a)>(b)?(b):(a))
 #define MAX 10000000
 using namespace std;
 int map[8][8],dp[15][8][8][8][8],sum[8][8][8][8];
 void init()
 {
  int i,j,e,g,h,tmp[8][8][8];
  memset(sum,0,sizeof(sum));
  for(i=0;i<8;i++)
   for(j=0;j<8;j++)
    for(e=j;e<8;e++)
    {
     if(e==j)
      tmp[i][j][j]=map[i][j];
     else
      tmp[i][j][e]=tmp[i][j][e-1]+map[i][e];
    }
  for(i=0;i<8;i++)
   for(j=0;j<8;j++)
    for(e=i;e<8;e++)
     for(g=j;g<8;g++)
     {
      for(h=j;h<=g;h++)
       sum[i][j][e][g]+=tmp[h][i][e];
     }
 }
 int sol(int cut,int x1,int y1,int x2,int y2)
 {
  if(cut==0)
   return sum[x1][y1][x2][y2]*sum[x1][y1][x2][y2];
  if(dp[cut][x1][y1][x2][y2])
   return dp[cut][x1][y1][x2][y2];
  if(x1==x2&&y1==y2&&cut)
   return MAX;
  int i,min,e,g;
  min=MAX;
  for(i=x1;i<x2;i++)
  {
   e=sol(cut-1,x1,y1,i,y2)+sum[i+1][y1][x2][y2]*sum[i+1][y1][x2][y2];
   g=sol(cut-1,i+1,y1,x2,y2)+sum[x1][y1][i][y2]*sum[x1][y1][i][y2];
   min=MIN(min,MIN(e,g));
  }
  for(i=y1;i<y2;i++)
  {
   e=sol(cut-1,x1,y1,x2,i)+sum[x1][i+1][x2][y2]*sum[x1][i+1][x2][y2];
   g=sol(cut-1,x1,i+1,x2,y2)+sum[x1][y1][x2][i]*sum[x1][y1][x2][i];
   min=MIN(min,MIN(e,g));
  }
  dp[cut][x1][y1][x2][y2]=min;
  return min;
 }
 int main()
 {
  int i,j,k,sum1=0,sum2;
  float ave,ss;
  scanf(""%d"",&k);
  for(i=0;i<8;i++)
   for(j=0;j<8;j++)
   {
    scanf(""%d"",&map[i][j]);
    sum1+=map[i][j];
   }
  ave=(float)sum1/(float)k;
  ave*=ave;
  init();
  sum2=sol(k-1,0,0,7,7);
  ss=(float)sum2/(float)k;
  printf(""%.3f\n"",sqrt(ss-ave));
  return 0;
 }
"
93,"【pku2128】lost Cows(模拟版) - lovekid的日志 - 网易博客

Source Code
 
 
  
   
   Problem: 2182 
    
   User: loveKid
   
   
   Memory: 236K 
    
   Time: 375MS
   
   
   Language: C++ 
    
   Result: Accepted
  
 
 
 
 Source Code  
 //直接模拟的时候时间是375ms,但是代码比较简洁~~ 
 #include<stdio.h>
#include<string.h>
const int MAXNUM=8002;
int input[MAXNUM];
void Init(){
 memset(input,0,sizeof(input));
}
int main(){
 //freopen(""C:\\Documents and Settings\\Administrator\\桌面\\in.txt"",""r"",stdin);
 int n,i,j;
 while(scanf(""%d"",&n)!=EOF){
  Init();
  for(i=2;i<=n;i++){
   scanf(""%d"",&input[i]);
   for(j=1;j<i;j++)
    if(input[j]>=input[i])
     input[j]++;
  }
  for(i=1;i<=n;i++)
   printf(""%d\n"",input[i]+1);
 }
}

"
95,"zoj 1024 Calendar Game - I am coming！ - 博客频道 - CSDN.NET

/*
zoj_1024 博弈
引用别人解释：
Tips:
这是一道博弈题，活的胜利的一方必须翻倒2001年11月4日；
下面是观察推论结果，11月4日，11+4=15是奇数。由于无论是加
一天还是加一个月都会改变m+d的奇偶性，除了下面几个特例
2月28日、9月30日和11月30日，显然如果m和d是这三个日子的话
则先行者必胜：
2月28日到3月28日
9月30日到10月1日
11月30日到12月1日
剩下的只有当m+d为偶数时先行者必胜。
这里还要说明的是在中间的过程中会不会遇到这几个特殊情况，答案
是否定的，认真想一下就很快能明白了。
这个MS是01年韩国亚洲赛的题目，看来数学还是王道的啊！
*/
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
    int n,year,month,day;
    scanf( ""%d"",&n );
    while( n-- )
    {
        scanf( ""%d%d%d"",&year,&month,&day );
        if( month==9 && day==30 ) printf( ""YES\n"" );
        else if( month==11 && day==30 ) printf( ""YES\n"" );
        else if( (month+day)%2==0 ) printf( ""YES\n"" );
        else printf( ""NO\n"" );
    }
    return 0;
}
"
96,"pku2480-积性函数，欧拉_110c_百度空间

                                                                                   Longge's problem 
Time Limit: 1000MS 
Memory Limit: 65536K 
Total Submissions: 4184 
Accepted: 1258 

Description
Longge is good at mathematics and he likes to think about hard mathematical problems which will be solved by some graceful algorithms. Now a problem comes: Given an integer N(1 < N < 2^31),you are to calculate ∑gcd(i, N) 1<=i <=N. 

""Oh, I know, I know!"" Longge shouts! But do you know? Please solve it.

Input
Input contain several test case. 

A number N per line.

Output
For each N, output ,∑gcd(i, N) 1<=i <=N, a line

Sample Input
26

Sample Output
315 

1）因为gcd(i,m*n)=gcd(i*m)*gcd(i*n),m,n互质，所以gcd是积性函数
积性函数的和函数也是积性函数,所以所求函数是积性函数
（2）
所以如果我们设所求答案是f(n) 则： f(n) = f(m1)*(m2) 其中，m1*m2 = n 
且m1,m2互质！经过因子分解，那种只要求到f(p^k)就可以利用积性把所有结果
相乘得到最后答案。
还要一个结论： f(n) = sum(p * phi(n/p)) 其中p是n的因子，phi(n/p) 
是从1到n有多少个数和n的gcd是p, 这个结论比较好证明的。
推出来一个公式f(p^r)=r*(p^r-p^(r-1))+p^r;
剩下的用积性函数的性质就可以解决了
一些要注意的细节看代码
#include <cstdlib>
#include <iostream>
using namespace std;
int main(int argc, char *argv[])
{
 long long s,n;
 while(scanf(""%I64d"",&n)!=-1)
 {
    s=1;
    long long x,r;
    for(long long i=2;i*i<=n;i++)
    if(n%i==0) //注意i要定义成long long，要不相乘越界可能出现负数，因为这里超时一次
    {
       x=1;r=0;
       do
       {
         n/=i;
         x*=i;
         r++;
       }while(n%i==0);
       s*=(r+1)*x-r*x/i;//直接利用结论，真方便 
    }
    if(n>1)
    s*=(2*n-1);
    printf(""%I64d\n"",s);
 } 
    system(""PAUSE"");
    return EXIT_SUCCESS;
}
"
103,"pku1160   Post Office    解题报告 - xxm137164869的专栏 - 博客频道 - CSDN.NET

 思路：用opt[i][j]记录把前i个邮局建到前j个村庄中的最优解，用cost[i][j]记录所有在i到j村庄中，建1个邮局的最小代价。显然邮局应该设到中点。让前i个邮局覆盖前j个村庄，第i+1个邮局覆盖第j+1至j+k个村庄(j+k<=n)，则状态转移方程为
 opt[i+1][j+k]=min{opt[i][j]+cost[j+1][j+k];} (k+j<=n)
代码如下：
 
 
  
  
   Code:
   
  
  
  #include<iostream>   
  using namespace std;   
     
  const int Max(305);   
  int data[Max];   
     
  int main()   
  {   
      int op[Max][Max];   
      int n,m;   
      cin>>n>>m;   
      int cost[Max][Max];   
      for(int i=1;i<=n;i++)   
          cin>>data[i];   
      for(int i=1;i<=n;i++)   
      {   
          for(int j=i;j<=n;j++)   
          {   
              int mid;   
              cost[i][j]=0;   
              mid=(i+j)/2;   
              for(int k=i;k<=j;k++)   
                  cost[i][j]+=(data[mid]-data[k])>=0?data[mid]-data[k]:data[k]-data[mid];   
                 
          }   
      }   
      for(int i=0;i<=m;i++)   
      {   
          for(int j=0;j<=n;j++)   
              op[i][j]=3000000;   
      }   
      op[0][0]=0;   
      for(int i=0;i<m;i++)   
      {   
          for(int j=0;j<=n;j++)   
          {   
              if(op[i][j]<3000000)   
              {   
                  for(int k=1;j+k<=n;k++)   
                      if(op[i+1][j+k]>op[i][j]+cost[j+1][j+k])   
                      {   
                          op[i+1][j+k]=op[i][j]+cost[j+1][j+k];   
                      }   
              }   
          }   
      }   
      cout<<op[m][n]<<endl;   
      return 0;   
  }  
  
 

"
104,"poj1740(A New Stone Game+男人八题之一) - 鸟 的 天 空 - 博客频道 - CSDN.NET

      题目链接：http://poj.org/problem?id=1740
      题意：有N堆石子，可以从一堆中取走至少一个石子，然后将此堆剩余的石子的任意多个任意分配到其它的堆中，最后一个取完石子的胜利。两个人都使用最有策略，问是不是先手胜利。
       男人八题中题解：当且仅当N为偶数并且“每个数字出现偶数次”时先手会输；
代码：
 
#include<stdio.h>
#include<string.h>
int numpie[105];
int main()
{
	int N;
	while(scanf(""%d"",&N) && N!=0)
	{
		int i;
		int pie;
		memset(numpie,0,sizeof(numpie));
		for(i=0;i<N;i++)
		{
			scanf(""%d"",&pie);
			numpie[pie]++;
		}
        if(N%2 == 1)
		{
			printf(""1\n"");
			continue;
		}
		for(i=0;i<101;i++)
        {
			if(numpie[i]%2 ==1)
				break;
		}
		if(i==101)
			printf(""0\n"");
		else 
			printf(""1\n"");
	}
	return 0;
} 

"
105,"(调换次序)POJ2013  Symmetric Order_On_the_road_新浪博客

题目：http://poj.org/problem?id=2013
#include <stdio.h>
 #include <stdlib.h>
 int main()
 {
     int n,set=1;
     char str[20][30],s[30];
     while(scanf(""%d"",&n),n)
     {
         for(int i=1;i<=n;i++)
         {
              scanf(""%s"",&str[i]);
         }
         printf(""SET %d\n"",set++);
         if(n%2==0)
         {
             for(int i=1;i<=n;i+=2)
                 printf(""%s\n"",str[i]);
             for(int i=n;i>0;i-=2)
                 printf(""%s\n"",str[i]);
         }
         else
         {
             for(int i=1;i<=n;i+=2)
                 printf(""%s\n"",str[i]);
             for(int i=n-1;i>0;i-=2)
                 printf(""%s\n"",str[i]);
         }
     }
     return 0;
 }
"
106,"pku2100 连续数的平方和 - 笑风生 - 博客频道 - CSDN.NET

 #include <stdio.h>
#include <math.h>
int ret1[10000001];
int ret2[10000001];
int main()
{
	int i, j;
	int cnt = 0;
	__int64 N;
	scanf(""%I64u"", &N);
	__int64 base = 0;
	int r = (int)sqrt((float)N);
	i = 1, j = 0;
	while(i <= r && j <= r)
	{
		if(base == N)
		{
			cnt++;
			ret1[cnt] = i;
			ret2[cnt] = j;
			j++;
			base += (__int64)j*j;
			continue;
		}
		else if(base > N)
		{
			base -= (__int64)i*i;
			i++;
		}
		else
		{
			j++;
			base += (__int64)j*j;
		}
	}
	printf(""%d/n"", cnt);
	for(i = 1; i <= cnt; ++i)
	{
		printf(""%d "", ret2[i]-ret1[i]+1);
		for(j = ret1[i]; j <= ret2[i]; ++j)
			printf(""%d "",j);
		printf(""/n"");
	}
	return 0;
} 
"
107,"pku 1190 搜索好题 - nizhenyang的日志 - 网易博客

搜索顺序的选择
 
由于R和H是从下到上递减，所以体积也是从下到上递减，因此选择从下到上的搜索顺序有利于判断当前情况是否可行。
 
此外，注意到表面积包括每层蛋糕的侧面积和裸露的顶面积。确定了最底层的蛋糕就确定了每层蛋糕裸露的顶面积之和，需要考虑的只剩下每层蛋糕的侧面积。因此这样的搜索顺序有利于判断是否可能出现比已知最优解更优的解
 
我们设当前为第i层蛋糕，上一层蛋糕的半径和高度为lastr,lasth,当前的面积为S,余下的体积为leftv.
 
我们可以用(i,lastr,lasth,leftv,S)表示一个状态.
 
初始状态为(M-1,Rm,Hm,N,R*R*H,R*R+2*R*H),Rm,Hm为第m层的半径和高，R*R*H表示第一层的体积，R*R+2*R*H表示顶面积加侧面积,即当前总面积.
 
目标状态(0,R1,H1,0,S),其中R1,H1为第一层的半径和高，S表示总面积．于是我们的目标是找到一条路径从初始节点到任意目标节点，并且S最小.
 
递归的式子：
 
(i,Ri,Hi,Vi,Si)à(i-1,Ri-1,Hi-1,Vi-1,Si-1)
 
其中必须满足:
 
Ri>Ri-1
 
Hi>Hi-1
 
Vi-1=Vi-Ri*Ri*Hi
 
Si-1=Si+2*Ri*Hi
 
直接的搜索显然是会超时的。因此必须加以优化。
 
1、 切到当前层时表面积比最小的面积大，可以剪枝；
 
2、 如果剩下的体积，比可能切出的最小体积小，剪枝。
 
3、从第K层到M层还需要加上的面积= 
 
。所以，当已经花费的面积
 
时可剪枝，余下的则是写递归程序的问题。
 
#include<iostream>
 
using namespace std;
 
int no1s,mins=10000000,lever,n,m;
 
int n3(int x)
 
{
 
return (x+1)*(x+1)*x*x/4;   // 求和公式
 
}
 
void f(int leftv,int floor,int lastr ,int lasth,int s)
 
{
 
if (  s + 2*leftv/lastr  >=  mins  )
 
return;
 
if( leftv < n3(floor) )
 
return;
 
if(floor==0)
 
{
 
if(leftv==0)
 
mins=s;
 
return;
 
}
 
int r,h,r2,maxh;
 
for(r=lastr-1;r>=floor;r--)
 
{
 
r2=r*r;
 
if(floor==m)
 
s=r2;
 
maxh=(leftv-n3(floor-1))/r2;
 
if(maxh>lasth-1)
 
maxh=lasth-1;
 
for(h=maxh;h>=floor;h--)
 
f(leftv-r2*h,floor-1,r,h,s+2*r*h);
 
}
 
}
 
int main()
 
{
 
cin>>n>>m;
 
int sum=0;
 
f(n, m, 10000, 1000, 0);
 
if(mins>100000000)
 
cout<<0;
 
else
 
cout<<mins<<endl;
 
return 0;
 
}
 
总结：学到了搜索中的状态的设计方法，搜索中的剪枝技巧，递归解决的设计方法
"
108,"pku1129 Channel Allocation_xiao_yu_feng的空间_百度空间

这题和地图涂色问题类似，只要计算最大团中所包含的顶点个数就可以了
#include<stdio.h>
#include<string.h>
int a[28][28];
char str[28];
int x[28],cn,bestn,n;
void backtrack(int p)//找邻接矩阵的最大团，最大团中所含的顶点个数即为answer
{
 int i,flag;
 if(p>n)
 {
   //for(i=1;i<=n;i++)bestx[i]=x[i];
   bestn=cn;
   return ;
 }
    flag=1;
 for(i=1;i<p;i++)
   if(x[i]&&a[p][i]==0)
   {
    //p与i不相连
    flag=0;
    break;
   }
 if(flag)//进入左子树,必须确认从定点i到已选入的顶点集中每一个顶点都有边相连
 {
   x[p]=1;//当且仅当顶点p属于已找到的最大团
   cn++;//当前顶点数
   backtrack(p+1);
   x[p]=0;
   cn--;
 }
 if(cn+n-p>bestn)//右子树，必须确认还有足够多的可选择顶点使得有可能在右子树中找到更大的团
 {
   x[p]=0;
   backtrack(p+1);
 }   
}
int main()
{
 int i,j,len;
 while(scanf(""%d"",&n)!=EOF)
 {
   if(n==0)break;
   memset(a,0,sizeof(a));
   for(i=1;i<=n;i++)
   {
    scanf(""%s"",str);
    len=strlen(str);
    for(j=2;j<len;j++)
     a[i][str[j]-'A'+1]=1;//构造邻接矩阵
   }
        cn=0;bestn=0;
   backtrack(1);
   if(bestn==1)
      printf(""1 channel needed.\n"");
   else
    printf(""%d channels needed.\n"",bestn);
 }
 return 0;
}
"
110,"POJ1273 Drainage Ditches - Zsys Algorithm - 博客频道 - CSDN.NET


 Drainage Ditches
 
 
  
   
    
    Time Limit: 1000MS 
      
    Memory Limit: 10000K 
    
    
    Total Submissions: 25097 
      
    Accepted: 9168 
    
   
  
 
Description
 

 Every time it rains on Farmer John's fields, a pond forms over Bessie's favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie's clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch. 
 
Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network. 
 
Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle. 
 

 
Input
 

 The input includes several cases. For each case, the first line contains two space-separated integers, N (0 <= N <= 200) and M (2 <= M <= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 <= Si, Ei <= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 <= Ci <= 10,000,000) is the maximum rate at which water will flow through the ditch.
 
Output
 

 For each case, output a single integer, the maximum rate at which water may emptied from the pond. 
 
Sample Input
 
5 4
1 2 40
1 4 20
2 4 20
2 3 30
3 4 10
 
Sample Output
 
50 
Source
 

 USACO 93
 

 很单纯的最大流问题，比较简单。
 

 #include<iostream>
using namespace std;
int n,graph[205][205];
int maxflow()
{
    int sum(0);
    for(;;)
    {
        int min(2100000000),queue[2][205],qf=2,qr=1, visited[205];
        queue[0][1]=1, queue[1][1]=0;
        for(int i=1;i<=n;i++)
        {
            visited[i]=0;
        }
        for(;qr<qf;)
        {
            int i;
            for(i=2;i<=n;i++)
            {
                if(not visited[i] and graph[queue[0][qr]][i]>0)
                {
                    queue[0][qf]=i, queue[1][qf++]=qr, visited[i]=1;
                    if(i==n) break;
                }
            }
            qr++;
            if(i==n) break;
        }
        if(queue[0][--qf]!=n) return sum;
        for(int t(qf);t>1;)
        {
            if(graph[queue[0][queue[1][t]]][queue[0][t]]<min and graph[queue[0][queue[1][t]]][queue[0][t]]>0)
            {
                min=graph[queue[0][queue[1][t]]][queue[0][t]];
            }
            t=queue[1][t];
        }
        for(;qf>1;)
        {
            graph[queue[0][queue[1][qf]]][queue[0][qf]]-=min;
            graph[queue[0][qf]][queue[0][queue[1][qf]]]+=min;
            qf=queue[1][qf];
        }
        sum+=min;
    }
}
int main(int argc, char* argv[])
{
    int m;
    while(cin>>m>>n)
    {
        for(int i(1);i<=n;i++)
        {
            for(int j(1);j<=n;j++)
            {
                graph[i][j]=0;
            }
        }
        while(m--)
        {
            int i,j,k;
            cin>>i>>j>>k;
            graph[i][j]+=k;
        }
        cout<<maxflow()<<endl;
    }
    return 0;
}
 
"
111,"POJ3589_泛星_新浪博客


   
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Number-guessing Game
 

Description
Larry likes playing the number-guessing game.
Two players are needed in a game. Suppose they are X and Y, and X presents a number for Y to guess. Firstly, X chooses a number with four different digits, keeping it in mind, and tells Y to start guessing. Every time Y has guessed, X should give out *A*B to show Y how close to the number his answer is. Here the symbol * stands for a number, and the number before A is the number of digits in Y's answer with both correct value and position. The number before B is the number of digits in Y's answer with correct value but incorrect position.
For example, if X chooses the number 5204, and Y guesses 4902, then X should give out 1A2B, in which 1A corresponds for digit 0 with both correct value and position and 2B corresponds for digit 2 and 4 with correct value but incorrect position. Then Y will go on guessing according to 1A2B that X presents him until he gets the totally correct number 5204 (when X shows him 4A0B).
Now you are given two numbers, and what you need to do is just testing how close they are.
Input
The first line of the input is an integer T which indicates the number of test cases. For each test case, input two numbers. Each number contains four different digits.
Output
For each test case, output *A*B stands for how close the two numbers are.
 　
Sample Input
2
5204 4902
0123 3210
Sample Output
1A2B
0A4B
该题需注意可能会有数字的重复
#include<stdio.h>
 main()
 {
  char a[5],b[5],c[4];
  int i,j,n,a1,b1,k;
  scanf(""%d"",&n);
  while(n--)
  {
    a1=0;
    b1=0;
    k=0;
    for(i=0;i<4;i++)c[i]=11;
    scanf(""%s"",a);
    scanf(""%s"",b);
    if(a[0]==b[0]) {c[k++]=a[0];a1++;}
    if(a[1]==b[1]) {c[k++]=a[1];a1++;}
    if(a[2]==b[2]) {c[k++]=a[2];a1++;}
    if(a[3]==b[3]) {c[k++]=a[3];a1++;}  
    for(i=0;i<4;i++)
    { if(a[i]==c[0]||a[i]==c[1]||a[i]==c[2]||a[i]==c[3]) continue;
      for(j=0;j<4;j++)
      { if(b[j]==c[0]||b[j]==c[1]||b[j]==c[2]||b[j]==c[3]) continue;
        if(i==j)continue;
        else if(a[i]==b[j]) {b1++;c[k++]=b[j];}  
      }    
    }
    printf(""��\n"",a1,b1);     
  }     
 }
"
112,"[转载]pku1006 中国剩余定理_晶晶_新浪博客


 
  原文地址：中国剩余定理"">pku1006 中国剩余定理
  作者：星期五
 
 
  
     
   传说西汉大将韩信，由于比较年轻，开始他的部下对他不很佩服。有一次阅兵时，韩信要求士兵分三路纵队，结果末尾多2人，改成五路纵队，结果末尾多3人，再改成七路纵队，结果又余下2人，后来下级军官向他报告共有士兵2395人，韩信立即笑笑说不对（因2395除以3余数是1，不是2），由于已经知道士兵总人数在2300?/FONT>2400之间，所以韩信根据23，128，233，------，每相邻两数的间隔是105，便立即说出实际人数应是2333人（因2333=128+20χ105+105，它除以3余2，除以5余3，除以7余2）。这样使下级军官十分敬佩，这就是韩信点兵的故事。 
   
   
   
 
      简化：已知 n%3=2,n%5=3,n%7=2,求n。 
   
   
 
      再看我们这道题，读入p,e,i,d 4个整数，已知(n+d)%23=p; (n+d)%28=e; (n+d)%33=i ,求n 。 
   
   
 
   
      但是韩信是怎么计算出结果的呢？ 
   
   
 
      原来这个东西叫“中国剩余定理”，《孙子算经》中就有计算方法。 
   
   
 
      韩信应该是这样算的： 
   
   
 
         因为n%3=2,n%5=3,n%7=2且3，5，7互质 
   
   
 
         使5×7被3除余1，用35×2=70； 
   
   
 
          使3×7被5除余1，用21×1=21； 
   
   
 
          使3×5被7除余1，用15×1=15。 
   
   
 
         （70×2+21×3+15×2）%（3×5×7）=23 
   
   
 
      同样，这道题也应该是： 
   
   
 
          使33×28被23除余1，用33×28×6=5544； 
   
   
 
          使23×33被28除余1，用23×33×19=14421； 
   
   
 
          使23×28被33除余1，用23×28×2=1288。 
   
   
 
         （5544×p+14421×e+1288×i）%（23×28×33）=n+d 
   
   
 
          n=（5544×p+14421×e+1288×i-d）%（23×28×33）
   
  
     一般的，若某数x分别被d1、、…、dn除得的余数为r1、r2、…、rn，则可表示为下式：
 x=R1r1+R2r2+…+Rnrn+RD
 其中R1是d2、d3、…、dn的公倍数，而且被d1除，余数为1；
 R1 、R2…、Rn是d1、d2、…、dn-1的公倍数，而且被dn除，余数为1；
 D是d1、d2、…、的最小公倍数；
 R是任意整数，可根据实际需要决定；
 且d1、、…、必须互质，以保证每个Ri(i=1,2，…，n)都能求得.
  #include<stdio.h>
 int main()
 {
  int p,e,i,d,n,t=0;
  while (1){
   scanf(""%d %d %d %d"",&p,&e,&i,&d);
   if (p==-1) break;
   n=(5544*p+14421*e+1288*i)%21252-d;
   if (n<=0) n+=21252;
   printf(""Case %d: the next triple peak occurs in %d days.n"",++t,n);
  }
  return 0;
 }
   
  
    
   
   
 
"
113,"POJ3249（Test for Job） - Oi不回头，菜鸟变大牛 - 博客频道 - CSDN.NET

拓扑排序+打擂台
找一个入度为0的结点进行DFS，直到找到一个出度为0的结点结束并更新ans。
数据结构使用边表。

program POJ3249;
const
	maxn=100001;
	maxm=1000001;
type
	gta=record
		x,y,next:longint;
	end;
var
	b:array [0..maxn] of boolean;
	map:array [0..maxm] of gta;
	c,into,first,f:array [0..maxn] of longint;
	n,m,ans,tot:longint;
procedure init;
var
	i,x1,x2:longint;
begin
	ans:=-maxlongint;	
	fillchar(b,sizeof(b),false);	
	fillchar(f,sizeof(f),200);
	fillchar(map,sizeof(map),0);
	fillchar(first,sizeof(first),0);
	fillchar(into,sizeof(into),0);
	tot:=0;
	readln(n,m);
	for i:=1 to n do readln(c[i]);
	for i:=1 to m do
		begin
			readln(x1,x2);
			inc(into[x2]);
			inc(tot);
			map[tot].x:=x1;
			map[tot].y:=x2;
			map[tot].next:=first[x1];
			first[x1]:=tot;
		end;
end;
procedure DFS(x:longint);		
var
	t,now,y:longint;
begin
	b[x]:=true;//先标记这个点已访问过。
	now:=-maxlongint;
	t:=first[x];//先找与x相连的第一个结点。
	while t<>0 do//把与x相连的所有点遍历一遍。
		begin
			y:=map[t].y;
			if not b[y] then DFS(y);//如果与x相连的这个点没有访问过就访问。
			if f[y]>now then now:=f[y];//如果＞now就更新。
			t:=map[t].next;//访问下一个点。
		end;
	if first[x]=0 then f[x]:=c[x] else f[x]:=now+c[x];//如果这个点的出度为0（终点），值返回这个点的值。
end;	
procedure main;
var
	i:longint;
begin	
	for i:=1 to n do 
		begin
			if into[i]=0 then//如果入度为0，则这个点为起点。进行DFS。
				begin
					DFS(i);
					if f[i]>ans then ans:=f[i];//如果以当前点为起点得到的结果＞ans就更新。（打擂台）
				end;
		end;
end;	
begin
	assign(input,'POJ3249.in'); reset(input);
	assign(output,'POJ3249.out'); rewrite(output);
	while not eof do
		begin
			init;
			main;
			writeln(ans);
		end;
	close(input); close(output);
end.

"
117,"POJ1859_oi111_新浪博客


 The Perfect Symmetry
 
 
  
   
    
    Time Limit: 1000MS 
     
    Memory Limit: 30000K 
    
    
    Total Submissions: 1164 
     
    Accepted: 438 
    
   
  
 

Description
 

 The representatives of NATO countries must be guarded by many bodyguards during the Summit. Each V.I.P. is accompanied by his own bodyguards but is also assigned many other specialists, snipers, etc. To make their work efficient and the guarded person secure as much as possible, the bodyguards must be distributed to various directions from the person.
 
 The optimal placement of bodyguards is such that the V.I.P. stands in the center of symmetry of all guards. Unfortunately, when the V.I.P. moves, it is very hard to reconfigure the bodyguards' positions to reflect the new situation. Most of the Czech specialists are not able to do such reconfigurations in real-time.
 
 Therefore, the Home Affairs Minister Sobeslav Gros has decided to reverse this procedure. The bodyguards take their places first. Then, it is the responsibility of the V.I.P. to find the proper position in the center of symmetry. If the person appears anywhere else, we take no responsibility for his/her security.
 
 Your task is to automate the process. Given a set of N points (bodyguard positions), you are to find its center of symmetry S, where the V.I.P. is relatively safe. More formal description follows.
 
 Let's have a point A and the center of symmetry S. We say that another point A' is the image of the point A according to the center of symmetry S iff S is the center of the line joining points A and A'.
 
 The image of the set of points (X) according to the center S is the set of all images of individual points in that set. The set X is said to possess a center of symmetry, if there exists a point S such that the image of the set X according to the center S is equal to the set X itself.
 
Input
 

 The input consists of several assignments. Each assignment begins with a line containing a single integer number N, 1 <= N <= 20000. It is followed by N lines, each containing two integer numbers Xi and Yi separated with a space, -10
 5 <= |Xi,Yi| <= 10
 5. These are the Cartesian coordinates of the i-th point in the set.
 
 Since no two bodyguards occupy the same place, no point will appear twice in the same assignment. However, note that a bodyguard can be in the same place as the V.I.P.
 
 After the last assignment, there is a line containing zero instead of the number of points. This line should not be processed.
 
Output
 

 For each assignment, output exactly one line. If the given set possesses a center of symmetry, print the text ""V.I.P. should stay at (X,Y)."" where X and Y are the Cartesian coordinates of the center rounded to the nearest number with exactly one digit after the decimal point.
 
 If there is no center of symmetry, output the text: ""This is a dangerous situation!"".
 
Sample Input
8
1 10
3 6
6 8
6 2
3 -4
1 0
-2 -2
-2 4
4
2 1
4 1
5 1
6 1
0
Sample Output
V.I.P. should stay at (2.0,3.0).
This is a dangerous situation!
Source
 

  CTU Open 2002
 

   
 
 

   
 
 

   
 
 

   
 
 

   
 
 

   
 
 

   
 
 

  #include<iostream>
 
 #include<math.h>
 
 #include<stdio.h>
 
 using namespace std;
 
 struct point{int x,y;};
 
 point a[30000];
 
 bool pig(point a,point b)
 
 {
 
  
 if (a.x<b.x) return true;
 
  
 if (a.x==b.x&&a.y<b.y) return true;
 
  
 return false;
 
 }
 
 void swap(point &x,point &y)
 
 {
 
  
 point t=x;
 
  
 x=y;
 
  
 y=t;
 
 }
 
 void dog(int x,int y)
 
 {
 
  
 int x1,y1;
 
  
 point mid;
 
  
 x1=x;
 
  
 y1=y;
 
  
 mid=a[(x+y)/2];
 
  
 do
 
  
 {
 
  
  
 while(pig(a[x],mid)) x++;
 
  
  
 while(pig(mid,a[y])) y--;
 
  
  
 if (x<=y)
 
  
  
 {
 
  
  
  
 swap(a[x],a[y]);
 
  
  
  
 x++;
 
  
  
  
 y--;
 
  
  
 }
 
  
 }
 
  
 while(x<y);
 
  
 if (x<y1) dog(x,y1);
 
  
 if (x1<y) dog(x1,y);
 
 }
 
 int main()
 
 {
 
  
 int n,i,tx,ty;
 
  
 bool d;
 
  
 while(1)
 
  
 {
 
  
  
 scanf(""%d"",&n);
 
  
  
 if (n==0) break;
 
  
  
 for(i=1;i<=n;i++)
 
  
  
  
  scanf(""%d%d"",&a[i].x,&a[i].y);
 
  
  
 dog(1,n);
 
  
 // 
 for(i=1;i<=n;i++)
 
  
 // 
 cout<<a[i].x<<"" 
  
  ""<<a[i].y<<endl;
 
  
  
 if (n%2==0)
 
  
  
 {
 
  
  
  
 tx=a[1].x+a[n].x;
 
  
  
  
 ty=a[1].y+a[n].y;
 
  
  
  
 d=true;
 
  
  
  
 for(i=1;i<=n/2;i++)
 
  
  
  
  if (a[i].x+a[n-i+1].x!=tx||a[i].y+a[n-i+1].y!=ty) {d=false;break;}
 
  
  
  
 if (d==true) printf(""V.I.P. should stay at (%.1lf,%.1lf).\n"",tx/2.0,ty/2.0);
 
  
  
  
 else
 
  
  
  
 printf(""This is a dangerous situation!\n"");
 
  
  
 }
 
  
  
 else
 
  
  
 {
 
  
  
  
 tx=a[(1+n)/2].x*2;
 
  
  
  
 ty=a[(1+n)/2].y*2;
 
  
  
  
 d=true;
 
  
  
  
 for(i=1;i<=n/2;i++)
 
  
  
  
  
  if (a[i].x+a[n-i+1].x!=tx||a[i].y+a[n-i+1].y!=ty) {d=false;break;}
 
  
  
  
  
  
  if (d==true) printf(""V.I.P. should stay at (%.1lf,%.1lf).\n"",tx/2.0,ty/2.0);
 
  
  
  
 else
 
  
  
  
 printf(""This is a dangerous situation!\n"");
 
  
  
 }
 
  
 }
 
  
 cin>>i;
 
  
 return 0;
 
 }
 

"
120,"hdu1049_seoxiaoniu_百度空间

include<iostream>
using namespace std;
intmain()
{
    int n,u,d,i;
    while(cin>>n>>u>>d&&n)
    {
        for(i=0;;i++)
            if((u-d)*i+u>=n)break;
        cout<<i*2+1<<endl;
    }
    return0;
}
"
121,"poj1833 排列 求字典序的下k个序列_hala_acmer_新浪博客

这个题目就是 要清楚求字典序的下一个的算法了，数据n最大1024，所以不能全保存n!个顺序了，至于怎么求下一个 下面三个步骤 

 1 从最右边开始找，找到第一个j，使得arr[j]>arr[j-1];
 

 2 从j到n这个范围找到最小的比arr[j-1]大的数字，交换这个数和arr[j-1];
 

 3 从 arr [j]到arr[n] 排序 sort(arr+j,arr+n+1);
 

 贴代码了
 
 
 
  #include<iostream>
  
 
  #include<cstdio>
  
 
  #include<algorithm>
  
 
  using namespace std;
  
 
  const int maxn=1025;
  
 
  int arr[maxn];
  
 
  int main()
  
 
  {
  
 
   
    
   int T; scanf(""%d"",&T);
  
 
   
    
   int n,i,j,k;
  
 
   
    
   while(T--)
  
 
   
    
   {
  
 
   
    
    
    
   scanf(""%d%d"",&n,&k);
  
 
   
    
    
    
   for(i=1;i<=n;++i)
  
 
   
    
    
    
   scanf(""%d"",&arr[i]);
  
 
   
    
    
    
   while(k--)
  
 
   
    
    
    
   {
  
 
   
    
    
    
    
    
   for(i=n;i>=1;--i)
  
 
   
    
    
    
    
    
   {
  
 
   
    
    
    
    
    
    
    
   if(arr[i]>arr[i-1])
  
 
   
    
    
    
    
    
    
    
    
    
   break;
  
 
   
    
    
    
    
    
   }
  
 
   
    
    
    
    
    
   if(i==1)
  
 
   
    
    
    
    
    
   {
  
 
   
    
    
    
    
    
    
    
   for(i=1;i<=n;++i)
  
 
   
    
    
    
    
    
    
    
   arr[i]=i;
  
 
   
    
    
    
    
    
    
    
   continue;
  
 
   
    
    
    
    
    
   }
  
 
   
    
    
    
    
    
   int min=1025;
  
 
   
    
    
    
    
    
   int index;
  
 
   
    
    
    
    
    
   for(j=i;j<=n;++j)
  
 
   
    
    
    
    
    
   {
  
 
   
    
    
    
    
    
    
    
   if(arr[j]>=arr[i-1]&&arr[j]<min)
  
 
   
    
    
    
    
    
    
    
   {
  
 
   
    
    
    
    
    
    
    
    
    
   min=arr[j];index=j;
  
 
   
    
    
    
    
    
    
    
   }
  
 
   
    
    
    
    
    
   }
  
 
   
    
    
    
    
    
   int t=arr[i-1];
  
 
   
    
    
    
    
    
   arr[i-1]=arr[index];
  
 
   
    
    
    
    
    
   arr[index]=t;
  
 
   
    
    
    
    
    
   sort(arr+i,arr+n+1);
  
 
   
    
    
    
   }
  
 
   
    
    
    
   printf(""%d"",arr[1]);
  
 
   
    
    
    
   for(i=2;i<=n;++i)
  
 
   
    
    
    
   printf("" %d"",arr[i]);
  
 
   
    
    
    
   printf(""\n"");
  
 
   
    
   }
  
 
   
    
   return 0;
  
 
  }
  
 

 

"
123,"POJ2472 n次迪杰斯特拉 - Belong to Sopranos - 博客频道 - CSDN.NET

 一个简单的最短路，之前写过一个等效于floyd（floyd太简单，但人家思想很强大）的DJ，这次又重温一下，不错，依然好用。。。根据floyd的思想和DJ的思想可知，n次DJ算法相当于一次floyd算法：
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
#define buzhun_tou_zhuan_pzjay_wenzhang 0
const int N=1000;
const double pp=-1.00;
double Pzjay[N][N];
bool used[N];
const int nax=101;
void DJ(int n)
{
	int i,j;
	int k,beg;
	double min;
	for(i=1;i<=n;++i)
	{
		memset(used,0,sizeof(used));
		used[i]=true;
		k=n;
		while(k--)
		{
			min=pp;
			for(j=1;j<=n;++j)
				if(!used[j] && Pzjay[i][j]>min)
				{
					min=Pzjay[i][j];
					beg=j;
				}
				used[beg]=true;
				for(j=1;j<=n;++j)
					if(!used[j] && Pzjay[i][j]<Pzjay[i][beg]*Pzjay[beg][j])
						Pzjay[i][j]=Pzjay[i][beg]*Pzjay[beg][j];
		}
	}
}
int main()
{
	int i,j,n,m;
	int tmp;
	while(scanf(""%d"",&n),n)
	{
		scanf(""%d"",&m);
		memset(Pzjay,0,sizeof(Pzjay));
		memset(used,0,sizeof(used));
		while(m--)
		{
			scanf(""%d%d"",&i,&j);
			scanf(""%d"",&tmp);
			Pzjay[j][i]=Pzjay[i][j]=tmp*0.01;
		}
		DJ(n);
		/*for(i=1;i<=n;++i)
		{
			for(j=1;j<=n;++j)
				printf(""%.2lf "",Pzjay[i][j]);
			printf(""/n"");
		}*/	
		printf(""%.6lf percent/n"",100.0*Pzjay[1][n]);
	}
	return buzhun_tou_zhuan_pzjay_wenzhang;
} 
"
124,"poj1006 - 地平线的日志 - 网易博客

Biorhythms



Time Limit:
 1000MS

Memory Limit:
 10000K

Total Submissions:
 68666

Accepted:
 20234

Description

Some people believe that there are three cycles in a person's life that start the day he or she is born. These three cycles are the physical, emotional, and intellectual cycles, and they have periods of lengths 23, 28, and 33 days, respectively. There is one peak in each period of a cycle. At the peak of a cycle, a person performs at his or her best in the corresponding field (physical, emotional or mental). For example, if it is the mental curve, thought processes will be sharper and concentration will be easier. 

Since the three cycles have different periods, the peaks of the three cycles generally occur at different times. We would like to determine when a triple peak occurs (the peaks of all three cycles occur in the same day) for any person. For each cycle, you will be given the number of days from the beginning of the current year at which one of its peaks (not necessarily the first) occurs. You will also be given a date expressed as the number of days from the beginning of the current year. You task is to determine the number of days from the given date to the next triple peak. The given date is not counted. For example, if the given date is 10 and the next triple peak occurs on day 12, the answer is 2, not 3. If a triple peak occurs on the given date, you should give the number of days to the next occurrence of a triple peak. 

Input

You will be given a number of cases. The input for each case consists of one line of four integers p, e, i, and d. The values p, e, and i are the number of days from the beginning of the current year at which the physical, emotional, and intellectual cycles peak, respectively. The value d is the given date and may be smaller than any of p, e, or i. All values are non-negative and at most 365, and you may assume that a triple peak will occur within 21252 days of the given date. The end of input is indicated by a line in which p = e = i = d = -1. 

Output

For each test case, print the case number followed by a message indicating the number of days to the next triple peak, in the form: 

Case 1: the next triple peak occurs in 1234 days. 

Use the plural form ``days'' even if the answer is 1. 

Sample Input

0 0 0 00 0 0 1005 20 34 3254 5 6 7283 102 23 320203 301 203 40-1 -1 -1 -1

Sample Output

Case 1: the next triple peak occurs in 21252 days.Case 2: the next triple peak occurs in 21152 days.Case 3: the next triple peak occurs in 19575 days.Case 4: the next triple peak occurs in 16994 days.Case 5: the next triple peak occurs in 8910 days.Case 6: the next triple peak occurs in 10789 days.

Source


East Central North America 1999


#include <cstdlib>

#include <iostream>

#include <string.h>

#include <stdio.h>

using namespace std;

int main(int argc, char *argv[])

{       long int p,e,i,d;

long int c=0;

while(cin>>p>>e>>i>>d)

{if(p==-1)

break;

        c++;

        long int m=28*33*23;

        long int s=(28*33*6*p%m+23*33*19*e%m+23*28*2*i%m)%m;

        if(s>d)

         cout<<""Case ""<<c<<"": the next triple peak occurs in ""<<s-d<<"" days.""<<endl;

         else

         {

        long int sum;

        sum=d-s;

        sum/=m;

        sum=(sum+1)*m+s;

        sum-=d;

        cout<<""Case ""<<c<<"": the next triple peak occurs in ""<<sum<<"" days.""<<endl;

        }

}

    system(""PAUSE"");

    return EXIT_SUCCESS;

}"
128,"poj1426 - Find The Multiple - 贰圣 - 博客频道 - CSDN.NET

                                      想看更多的解题报告: http://blog.csdn.net/wangjian8006/article/details/7870410
                                      转载请注明出处：http://blog.csdn.net/wangjian8006
题目大意：
              对于一个整数，问大于等于这个整数的一个整数能够被其整除的整数，且这个整数只能包括0和1
解题思路：
              一位一位的确定，比如求被6整除的不为零整数，且整数的每位上是0或1
               从个位，十位，百位。。。一直确定上去，即每次扩展都在末尾加上0或者1
               首先初始为1，因为倍数的最高位必为1
              当倍数很大的时候我们可以利用同余模定理对得到的余数进行优化，字符串可以保存起来，而倍数可以对n取模。
                             （a*b）%n = （a%n *b%n）%n
                            （a+b）%n = （a%n +b%n）%n
               值得注意的是，如果n是偶数,则不用进行计算，直接=ans[i/2]+""0"";
               详解：http://archive.cnblogs.com/a/2122513/
代码：
 
#include <iostream>
#include <string>
#include <queue>
using namespace std;
typedef struct{
	int mod;
	string ans;
}Node;
Node node[210],temp,now;
bool dis[210];
void bfs(int i){
	int x,y;
	queue <Node>q;
	memset(dis,false,sizeof(dis));
	dis[1]=true;
	temp.ans=""1"";
	temp.mod=1;
	q.push(temp);
	while(!q.empty()){
		now=temp=q.front();
		q.pop();
		x=(temp.mod*10+1)%i;
		y=(temp.mod*10)%i;
		if(!x){
			node[i].ans=temp.ans+""1"";
			return ;
		}
		if(!y){
			node[i].ans=temp.ans+""0"";
			return ;
		}
		if(!dis[x]){
			temp.ans=temp.ans+""1"";
			temp.mod=x;
			q.push(temp);
			dis[x]=true;
		}
		if(!dis[y]){
			now.ans=now.ans+""0"";
			now.mod=y;
			q.push(now);
			dis[y]=true;
		}
	}
}
int main(){
	int i,n;
	node[1].ans=""1"";
	for(i=2;i<=200;i++){
		if(i%2==0) node[i].ans=node[i/2].ans+""0"";
		else bfs(i);
	}
	while(scanf(""%d"",&n) && n){
		cout<<node[n].ans<<endl;
	}
	return 0;
} 

"
129,"求树的最小覆盖所有点的点的个数poj3659_CCYJAVA_新浪博客

这个是dfs中用dp，当前点状态取决于其子节点的状态，具体转换如下：

 i,0表示以i为根的子树被覆盖，i点未放置的最小数目

 i,1表示以i为根的子树被覆盖，i点放置的最小数目

 i,2表示i的子树被覆盖，i点未被覆盖的最小数目

 之所以有这三种状态，是因为，一个点被覆盖的方式有三种：该点被放置，该点的子节点放置，该点的父节点放置

 i,0 =sigm(min(j,0;j,1;j,2)且保证至少一个j,1被取到

 i,1 =sigm(min(j,0;j,1;j,2)

 i,2 =sigmj,0

 #include ""stdio.h""

 #include ""string.h""

 #include ""stdlib.h""

 int vd[10001];

 int n,m;

 int arm[20001][2];//记录边

 int index[10001];//记录i节点的邻接边在arm里的索引

 int num[10001][3];//记录以i为根的树，选改节点与不选该节点的最小数目

 int cmp(const void *a,const void *b){

  
 
 
 int *x=(int *)a;

  
 
 
 int *y=(int *)b;

  
 
 
 return x[0]-y[0];

 }

 int min(int a,int b){

  
 
 
 if(a<b)

  
 
 
  
 
 
 return a;

  
 
 
 return b;

 }

 void init(){

  
 
 
 int i,j;

  
 
 
 scanf(""%d"",&n);

  
 
 
 for(i=0;i<n-1;i++){

  
 
 
  
 
 
 int a,b;

  
 
 
  
 
 
 scanf(""%d%d"",&a,&b);

  
 
 
  
 
 
 arm[2*i][0]=a;

  
 
 
  
 
 
 arm[2*i][1]=b;

  
 
 
  
 
 
 arm[2*i+1][0]=b;

  
 
 
  
 
 
 arm[2*i+1][1]=a;

  
 
 
 }

  
 
 
 m=2*n-2;

  
 
 
 memset(vd,0,sizeof(vd));

  
 
 
 memset(index,-1,sizeof(index));

  
 
 
 qsort(arm,m,sizeof(int)*2,cmp);

  
 
 
 for(i=0,j=0;i<m;i++){

  
 
 
  
 
 
 if(i==0||arm[i][0]!=arm[i-1][0]){

  
 
 
  
 
 
  
 
 
 index[arm[i][0]]=i;

  
 
 
  
 
 
 }

  
 
 
 }

 }

 void dfs(int v){

  
 
 
 int i,j,k,t;

  
 
 
 vd[v]=1;

  
 
 
 int isleaf=1;

  
 
 
 int sum1=0;

  
 
 
 int sum0=0;

  
 
 
 int sum2=0;

  
 
 
 int reduce=99999999;

  
 
 
 if(index[v]!=-1){

  
 
 
  
 
 
 for(i=index[v];arm[i][0]==v;i++){

  
 
 
  
 
 
  
 
 
 if(vd[arm[i][1]]==0){

  
 
 
  
 
 
  
 
 
  
 
 
 dfs(arm[i][1]);

  
 
 
  
 
 
  
 
 
  
 
 
 isleaf=0;

  
 
 
  
 
 
  
 
 
  
 
 
 sum1+=min(min(num[arm[i][1]][0],num[arm[i][1]][1]),num[arm[i][1]][2]);

  
 
 
  
 
 
  
 
 
  
 
 
 sum2+=num[arm[i][1]][0];

  
 
 
  
 
 
  
 
 
  
 
 
 //统计sum0=================================================reduce 始终>=0

  
 
 
  
 
 
  
 
 
  
 
 
 sum0+=min(num[arm[i][1]][0],num[arm[i][1]][1]);//先取最小的和

  
 
 
  
 
 
  
 
 
  
 
 
 if(num[arm[i][1]][1]-num[arm[i][1]][0]<reduce){//求需要在sum0上添加的最小值

  
 
 
  
 
 
  
 
 
  
 
 
  
 
 
 if(num[arm[i][1]][1]-num[arm[i][1]][0]>=0)//小于当前最小值且非负，更新之

  
 
 
  
 
 
  
 
 
  
 
 
  
 
 
  
 
 
 reduce=num[arm[i][1]][1]-num[arm[i][1]][0];

  
 
 
  
 
 
  
 
 
  
 
 
  
 
 
 else//取到=1时的了，不用reduce了

  
 
 
  
 
 
  
 
 
  
 
 
  
 
 
  
 
 
 reduce=0;

  
 
 
  
 
 
  
 
 
  
 
 
 }

  
 
 
  
 
 
  
 
 
  
 
 
 //==========================================================

  
 
 
  
 
 
  
 
 
 }

  
 
 
  
 
 
 }

  
 
 
 }

  
 
 
 if(isleaf){

  
 
 
  
 
 
 num[v][1]=1;

  
 
 
  
 
 
 num[v][0]=1;

  
 
 
  
 
 
 num[v][2]=0;

  
 
 
 }else{

  
 
 
  
 
 
 num[v][1]=1+sum1;

  
 
 
  
 
 
 num[v][0]=sum0+reduce;

  
 
 
  
 
 
 num[v][2]=sum2;

  
 
 
 }

 }

 int main(){

  
 
 
 int r;

  
 
 
 init();

  
 
 
 dfs(1);

  
 
 
 r=min(num[1][0],num[1][1]);

  
 
 
 printf(""%d\n"",r);

  
 
 
 scanf(""%d"",&r);

  
 
 
 return 0;

 }

"
131,"POJ 2226 Muddy Fields_Lonely Star-浩宇孤星_百度空间

这个问题转化为 二分图的最小覆盖。等价于求二分图的最大匹配。为了做这道题专门看了下组合数学。原来树上求最大匹配的算法就是　匈牙利算法。
计算二分图的算法有网络流算法和匈牙利算法（目前就知道这两种），其中匈牙利算法是比较巧妙的，具体过程如下（
转自组合数学）：
令g=（x,*,y）是一个二分图，其中x={x1,x2...},y={y1,y2,....}.令m为g中的任意匹配。 
1。将x的所有不与m的边关联的顶点表上￥，并称所有的顶点为未扫描的。转到2。 
2。如果在上一步没有新的标记加到x的顶点上，则停，否则 ，转3 
3。当存在x被标记但未被扫描的顶点时，选择一个被标记但未被扫描的x的顶点，比如xi，用（xi）标 
记y 的所有顶点，这些顶点被不属于m且尚未标记的边连到xi。 
 现在顶点xi 是被扫描的。如果不存在被标记但未被扫描的顶点，转4。 
4。如果在步骤3没有新的标记被标记到y的顶点上，则停，否则转5。 
5。当存在y被标记但未被扫描的顶点时。选择y的一个被标记但未被扫描的顶点，比如yj， 
用（yj）标记x的顶点，这些顶点被属于m且尚未标记的边连到yj。现在，顶点yj是被扫描的。 
如果不存在被标记但未被扫描的顶点则转道2。
由于每一个顶点最多被标记一次且由于每一个顶点最多被扫描一次，本匹配算法在有限步内终止。
贴代码：
Source Code
 Problem: 2226 User: AlbertLiu Memory: 1152K Time: 16MS Language: C++ Result: Accepted 

 
 Source Code //ＤＦＳ增广　和　ＢＦＳ增广#include <iostream>using namespace std;const int maxn=500;char grid[51][51] ;int mapx[51][51] ,mapy[51][51] ;int nx , ny , g[maxn][maxn] , cx[maxn] , cy[maxn] , mk[maxn] ;// cx[i]表示与Xi匹配的Y顶点// cy[i]同理int R , C ;int MaxMatch();int path(int u);int MaxMatchBFS();int main(){ //freopen(""in.txt"",""r"",stdin); scanf( ""%d %d\n"" , &R , &C ); for(int i=0;i<R;++i) for(int j=0;j<=C;++j) grid[i][j]=getchar(); for(int i=0;i<R;++i) // 横着分点 for(int j=0;j<C;++j) { if(grid[i][j]=='*') { while(grid[i][j]=='*') mapx[i][j++]=nx; ++nx; } } for(int j=0;j<C;++j) // 竖着分点 for(int i=0;i<R;++i) { if(grid[i][j]=='*') { while(grid[i][j]=='*') mapy[i++][j]=ny; ++ny; } } for(int i=0;i<R;++i) // 构造二分图 for(int j=0;j<C;++j) if(grid[i][j]=='*') g[ mapx[i][j] ][ mapy[i][j] ] = 1; //cout <<MaxMatch()<< endl; cout <<MaxMatchBFS()<< endl; return 0;}/*DFS增广从某一个X顶点出发，用深度优先的策略寻找增广路，并在找到之后，巧妙地利用递归来修改匹配。优点：实现简洁，理解容易适用：稠密图，由于边多，dfs找增广路很快复杂度：O(n^3)*/int path(int u){ for (int v = 0 ; v < ny ; v++) // 从X中的点u出发，遍历所有相连且未访问的Y点。 if (g[u][v] && !mk[v]) { mk[v] = 1 ; if ( cy[v] == -1 || path(cy[v]) ) // 递归直到有某个Y点不在匹配中，或失败。当找到时则形成一条增广路径 { cx[u] = v ; cy[v] = u ; // 表示X中的u有一条指向Y中的v的匹配 return 1 ; } } return 0 ;}int MaxMatch(){ int res(0) ; memset(cx , 0xff , sizeof(cx)) ; memset(cy , 0xff , sizeof(cy)) ; for (int i = 0 ; i <= nx ; i++) // 深度遍历所有X集合节点，找出所有增广路径 if (cx[i] == -1) { memset(mk , 0 , sizeof(mk)) ; // 防止增光路径回路死循环 res += path(i) ; // 若找到一条增广路径则匹配加1 } return res ;}/*2、BFS增广 复杂度：O(n^3)适用：稀疏二分图，边少，增广路短*/int pred[maxn] , open[maxn] ;int MaxMatchBFS(){ int i , u , v , t , d , e , cur , tail , res(0) ; memset(mk , 0xff , sizeof(mk)) ; memset(cx , 0xff , sizeof(cx)) ; memset(cy , 0xff , sizeof(cy)) ; for (i = 0 ; i < nx ; i++) { pred[i] = -1 ; cur = tail = 0 ; for (open[0] = i ; cur <= tail && cx[i] == -1 ; cur++) { for (u = open[cur] , v = 0 ; v < ny && cx[i] == -1 ; v ++) if (g[u][v] && mk[v] != i) { mk[v] = i ; open[++tail] = cy[v] ; if (open[tail] >= 0) { pred[open[tail]] = u ; continue ; } for (d = u , e = v ; d != -1 ; t = cx[d] , cx[d] = e , cy[e] = d , e = t , d = pred[d]) ; break ; } } if (cx[i] != -1) res++ ; } return res ;} 
参考：http://www.cnblogs.com/jesonpeng/articles/1352713.html
http://hi.baidu.com/scaneelingg/blog/item/b368a1cba775248fc817685b.html
 
"
137,"poj1674 - Rainy Days - 博客园

简单题
 

 
 
 View Code  
  
  
   
    #include 
    <
    iostream
    >
    
#include 
    <
    cstdlib
    >
    
#include 
    <
    cstring
    >
    
#include 
    <
    cstdio
    >
    

    using
     
    namespace
     std;

    #define
     maxn 10005
    

    int
     a[maxn];

    int
     cnt, n;

    int
     findit()
{
 
    for
     (
    int
     i 
    =
     
    1
    ; i 
    <=
     n; i
    ++
    )
 
    if
     (a[i] 
    !=
     i)
 
    return
     i;
 
    return
     
    -
    1
    ;
}

    int
     main()
{
 
    //
    freopen(""D:\\t.txt"", ""r"", stdin);
    

     
    int
     t;
 scanf(
    ""
    %d
    ""
    , 
    &
    t);
 
    while
     (t
    --
    )
 {
 scanf(
    ""
    %d
    ""
    , 
    &
    n);
 
    for
     (
    int
     i 
    =
     
    1
    ; i 
    <=
     n; i
    ++
    )
 scanf(
    ""
    %d
    ""
    , 
    &
    a[i]);
 cnt 
    =
     
    0
    ;
 
    int
     temp 
    =
     
    1
    ;
 
    while
     (
    1
    )
 {
 
    if
     (a[temp] 
    ==
     temp)
 temp 
    =
     findit();
 
    if
     (temp 
    ==
     
    -
    1
    )
 
    break
    ;
 swap(a[temp], a[a[temp]]);
 cnt
    ++
    ;
 }
 printf(
    ""
    %d\n
    ""
    , cnt);
 }
 
    return
     
    0
    ;
}
    
  
"
141,"poj1835 宇航员 三维空间的模拟_hala_acmer_新浪博客

 
  之前一直在wa，本来是用了一个二维数组保存，arr[i][j]，i表示当前的方向代表的数字，j表示需要做的转向，其实仅仅这些信息是不够的，比如在xy平面上，面朝z方向，向左转，这样根本不知道左是哪个方向，而如果一个人面朝的方向和头顶的方向能确定，那么就确定了一个二维平面，所以左边和右边也就定了，这样需要一个6*6的数组保存前方和上方确定下以后左边的方向，下面是代码
 
  #include<iostream>
 
  #include<cstdio>
 
  #include<string>
 
  using namespace std;
 
  int arr[6][6];
 
  char direction[20];
 
  void init()
 
  {
 
      arr[0][1]=2;arr[0][2]=4;arr[0][4]=5;arr[0][5]=1;
 
      arr[1][2]=0;arr[1][5]=3;arr[1][0]=5;arr[1][3]=2;
 
      arr[2][0]=1;arr[2][3]=4;arr[2][1]=3;arr[2][4]=0;
 
      arr[3][1]=5;arr[3][4]=2;arr[3][2]=1;arr[3][5]=4;
 
      arr[4][0]=2;arr[4][3]=5;arr[4][2]=3;arr[4][5]=0;
 
      arr[5][4]=3;arr[5][1]=0;arr[5][0]=4;arr[5][3]=1;
 
  }
 
  void cal(int &x,int &y,int &z,int pos,int step)
 
  {
 
      if(pos==0) x+=step;
 
      else if(pos==1) y+=step;
 
      else if(pos==2) z+=step;
 
      else if(pos==3) x-=step;
 
      else if(pos==4) y-=step;
 
      else if(pos==5) z-=step;
 
  }
 
  int main()
 
  {
 
      init();
 
      int T;scanf(""%d"",&T);
 
      int n,x,y,z,pos,step,head;
 
      while(T--)
 
      {
 
          scanf(""%d"",&n);
 
          x=y=z=pos=0;
 
          head=2;
 
          while(n--)
 
          {
 
              scanf(""%s %d"",direction,&step);
 
              if(direction[0]=='b')
 
              {
 
                  pos=(pos+3)%6;
 
              }
 
              else if(direction[0]=='l')
 
              {
 
                  pos=arr[pos][head];
 
              }
 
              else if(direction[0]=='r')
 
              {
 
                  pos=((arr[pos][head])+3)%6;
 
              }
 
              else if(direction[0]=='u')
 
              {
 
                  int t=pos;
 
                  pos=head;
 
                  head=(t+3)%6;
 
              }
 
              else if(direction[0]=='d')
 
              {
 
                  int t=pos;
 
                  pos=(head+3)%6;
 
                  head=t;
 
              }
 
              cal(x,y,z,pos,step);
 
          }
 
          printf(""%d %d %d %d\n"",x,y,z,pos);
 
      }
 
      return 0;
 
  }
 
"
143,"HDU 4294 Multiple（12年成都） - 窝是爱酱,喵~~~~ - 博客频道 - CSDN.NET

转载请注明出处，谢谢http://blog.csdn.net/acm_cxlove/article/details/7854526       by---cxlove
题目：在K进制下，用最少的不同的数，表示成n的倍数
http://acm.hdu.edu.cn/showproblem.php?pid=4294 
首先要得到一个结论，就是最多用两个数就行了。
证明 ：对于一个数字a，可以构造出的数字有
a,aa,aaa,aaaa,aaaaa,……
每一个数对于n都有一个余数，余数最多有n个，根据鸽巢原理，前n+1个数中，必然有两个余数相等
那么二者之差，必定为n的倍数，形式为a……a0……0。
有这个结论，就简单了
先枚举一个数，然后枚举两个数，BFS即可

#include<iostream>
#include<cstdio>
#include<map>
#include<cstring>
#include<cmath>
#include<vector>
#include<algorithm>
#include<set>
#include<string>
#include<queue>
#define inf 1<<28
#define M 100005
#define N 50005
#define Min(a,b) ((a)<(b)?(a):(b))
#define Max(a,b) ((a)>(b)?(a):(b))
#define pb(a) push_back(a)
#define mem(a,b) memset(a,b,sizeof(a))
#define LL long long
#define MOD 1000000007
using namespace std;
int num[2],m,step[N],pre[N];
int n,c,ope[N];
string s,ans;
bool bfs(){
	queue<int>que;
	mem(step,0);
	for(int i=0;i<m;i++){
		if(!num[i]||step[num[i]%n]) continue;
		pre[num[i]%n]=-1;
		step[num[i]%n]=1;
		ope[num[i]%n]=num[i];
		que.push(num[i]%n);
	}
	while(!que.empty()){
		int u=que.front();
		que.pop();
		if(u==0) return true;
		if(ans.size()&&step[u]>ans.size()) return false;
		for(int i=0;i<m;i++){
			int v=(u*c+num[i])%n;
			if(!step[v]){
				step[v]=step[u]+1;
				ope[v]=num[i];
				pre[v]=u;
				que.push(v);
			}
		}
	}
	return false;
}
void slove(int k){
	if(pre[k]!=-1) slove(pre[k]);
	s+=(char)(ope[k]+'0');
}
bool cmp(string a,string b){
	if(b.size()==0) return true;
	if(a.size()>b.size()) return false;
	if(b.size()>a.size()) return true;
	return a<b;
}
int main(){
	while(cin>>n>>c){
		bool flag=false;ans="""";
		for(int i=1;i<c;i++){
			num[0]=i;m=1;
			if(bfs()){
				flag=true;
				s="""";
				slove(0);
				if(cmp(s,ans))
					ans=s;
			}
		}
		if(!flag){
			for(int i=1;i<c;i++){
				for(int j=0;j<i;j++){
					num[0]=j;num[1]=i;m=2;
					if(bfs()){
				    	s="""";
						slove(0);
						if(cmp(s,ans))
							ans=s;
					}
				}
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
"
145,"poj1730 - Ruansf的专栏 - 博客频道 - CSDN.NET

链接：http://poj.org/problem?id=1730
题意：求x^b的b的最大值。
 
#include<stdio.h>
#include<math.h>
#include<string.h>
typedef __int64 ll;
ll coun(ll n,ll m)
{
	ll i;
	if(m==1)
		return n;
	i=coun(n,m/2);
	i=(i*i);
	if(m%2==1)
		i=i*n;
	return i;
}
ll cmp(ll n)
{
	return n>0?n:(-n);
}
ll pan(ll n)
{
	return n%2==0?2:3;
}
int main()
{
	ll i,j,n,m;
	int res;
	while(scanf(""%I64d"",&n)>0,n)
	{
		m=(ll)sqrt(cmp(n));
		for(i=32,res=1;i>=2&&res==1;i--)
			for(j=pan(n);j<=m;j+=2)
			{
				if(n>0&&coun(j,i)==n)
				{res=i;break;}
				if(n<0&&coun(-j,i)==n)
				{res=i;break;}
			}
		printf(""%d\n"",res);
	}
	return 0;
}
"
147,"poj4047  garden_心自天涯_新浪博客

每个节点记录从它开始的k个数之和，然后收集其中的最大值，使用懒惰标记法。注意细节，写好pushup和pushdown。
#include <iostream>
 #include <cstdio>
 #include <cstring>
 #include <algorithm>
 using namespace std;
#define LS (rt<<1)
 #define RS (rt<<1|1)
 int fa[200005],tem[200005];
 int MAX[600010],lz[600010];
 int kk;
void pushup(int l,int r,int rt)
 {
     MAX[rt] = max(MAX[LS],MAX[RS]);
 }
void pushdown(int l,int r,int rt)
 {
     if(l==r) return;
     lz[LS] += lz[rt];
     lz[RS] += lz[rt];
     MAX[RS] += lz[rt];
     MAX[LS] += lz[rt];
     lz[rt] = 0;
 }
void maketree(int l,int r,int rt)
 {
     lz[rt] = 0;
     if(l==r){
         MAX[rt] = tem[kk++];
         return;
     }
     int m=(l+r)>>1;
     maketree(l,m,LS);
     maketree(m+1,r,RS);
     pushup(l,r,rt);
 }
void update(int s,int t,int sc,int l,int r,int rt)
 {
     int m=(l+r)>>1;
     if(l==r){
         MAX[rt] += sc;
         return;
     }
     if(lz[rt])  pushdown(l,r,rt);
     if(s<=l && t>=r){
         MAX[rt] += sc;
         lz[rt] += sc;
         return;
     }
     if(s<=m){
         update(s,t,sc,l,m,LS);
     }
     if(t>m){
         update(s,t,sc,m+1,r,RS);
     }
     pushup(l,r,rt);
 }
int query(int s,int t,int l,int r,int rt)
 {
     int m=(l+r)>>1;
     if(lz[rt])  pushdown(l,r,rt);
     int ret = -200000000;
     if(s<=l && t>=r) return MAX[rt];
     if(s<=m) ret = max(ret,query(s,t,l,m,LS));
     if(t>m) ret = max(ret,query(s,t,m+1,r,RS));
     return ret;
 }
 int main()
 {
     int num,n,m,k,x,y,tmp,p;
     scanf(""%d"",&num);
     while(num--){
         kk=1;
         memset(lz,0,sizeof(lz));
         memset(MAX,0,sizeof(MAX));
         tem[1] = 0;
         scanf(""%d%d%d"",&n,&m,&k);
         for(int i=1; i<=n; i++) scanf(""%d"",fa+i);
         for(int i=1; i<=k; i++){
             tem[1] += fa[i];
         }
         for(int i=2; i<=n-k+1; i++){
             tem[i] = tem[i-1] +fa[i+k-1] - fa[i-1];
         }
         maketree(1,n-k+1,1);
         while(m--){
             scanf(""%d%d%d"",&p,&x,&y);
             if(p==2){
                 printf(""%d\n"",query(x,y-k+1,1,n-k+1,1));
             }
             else if(p==0){
                 if(x<k){
                     update(1,x,y-fa[x],1,n-k+1,1);
                 }
                 else if(x>n-k+1){
                     update(x-k+1,n-k+1,y-fa[x],1,n-k+1,1);
                 }
                 else{
                     update(x-k+1,x,y-fa[x],1,n-k+1,1);
                 }
                 fa[x] = y;
             }
             else if(p==1){
                 if(x<k){
                     update(1,x,fa[y]-fa[x],1,n-k+1,1);
                 }
                 else if(x>n-k+1){
                     update(x-k+1,n-k+1,fa[y]-fa[x],1,n-k+1,1);
                 }
                 else{
                     update(x-k+1,x,fa[y]-fa[x],1,n-k+1,1);
                 }
                 if(y<k){
                     update(1,y,fa[x]-fa[y],1,n-k+1,1);
                 }
                 else if(y>n-k+1){
                     update(y-k+1,n-k+1,fa[x]-fa[y],1,n-k+1,1);
                 }
                 else{
                     update(y-k+1,y,fa[x]-fa[y],1,n-k+1,1);
                 }
                 tmp = fa[x];
                 fa[x] = fa[y];
                 fa[y] = tmp;
             }
         }
     }
     return 0;
 }
"
148,"Pku1868 Antiarithmetic? - cristiano_faith的日志 - 网易博客

 
Description
A permutation of n is a bijective function of the initial n natural numbers: 0, 1, ... n-1. A permutation p is called antiarithmetic if there is no subsequence of it forming an arithmetic progression of length bigger than 2, i.e. there are no three indices 0 <= i < j < k < n such that (pi , pj , pk) forms an arithmetic progression. 
For example, the sequence (2, 0, 1, 4, 3) is an antiarithmetic permutation of 5. The sequence (0, 5, 4, 3, 1, 2) is not an antiarithmetic permutation as its first, fifth and sixth term (0, 1, 2) form an arithmetic progression; and so do its second, forth and fifth term (5, 3, 1). 
Your task is to check whether a given permutation of n is antiarithmetic. 
 
Input
There are several test cases, followed by a line containing 0. Each test case is a line of the input file containing a natural number 3 <= n <= 10000 followed by a colon and then followed by n distinct numbers separated by whitespace. All n numbers are natural numbers smaller than n. 
 
Output
For each test case output one line with yes or no stating whether the permutation is antiarithmetic or not. 
 
Sample Input

3: 0 2 1   5: 2 0 1 3 4  6: 2 4 3 5 0 1  0   
Sample Output

yes  no  yes   
Source
Waterloo local 2004.09.25
 
题意：给出整数n的1~n-1的排列，若排列中按顺序出现等差数列，则输出NO，否则yes
 
思路：输入排列时，每输入一个数用num数组记录其位置下标，若出现等差数列，0<=i<j<k<n，则num[k]>num[j]>num[i]||num[k]<num[j]<num[i]

My code：
 #include <stdio.h >
 int num[10003]={0};
 int n;
 int i;
 int j;
 int k;
 int temp;
int solve()
 {
     for (i=0;i<=n-2;i++)
     {
         for (j=i+1;j<=(n+i)/2;j++)
         {
             k=j+j-i;
             if (k>=n)
             {
                 break;
             }
             else if((num[k]>num[j]&&num[j]>num[i])||(num[k]<num[j]&&num[j]<num[i]))
             {
                 return 1;
             }
         }
     }
     return 0;
 }
 int main()
 {
    while (1)
     {
         scanf(""%d:"",&n);
         if (n==0)
         {
             break;
         }
         memset(num,0,sizeof(num));
         for (i=0;i<n;i++)
         {
             scanf(""%d"",&temp);
             num[temp]=i;
         }
         if (solve())
             printf(""no\n"");
         else
             printf(""yes\n"");
     }
    return 0;
 } 
 
"
152,"HDU3068 && PKU3974（回文算法manacher）_cchun_百度空间

求字符串中包含的最长回文
HDU3068
/*
name:cchun
PROG:HDU3068
algorithm:manacher
*/
#include<iostream>
#include<string>
#include<string.h>
#define Min(a,b) a>b? b:a
const int MAX=110005;
using namespace std;
char str2[MAX*3],str1[MAX];
int nn;
int rad[MAX*3];
void init()
{
 int i;
 str2[0]='$';
 str2[1]='#';
 int len1=strlen(str1);
 for(i=0;i<len1;i++)
  str2[i*2+2]=str1[i],str2[i*2+3]='#';
 str2[(i-1)*2+4]='\0';
 nn=(i-1)*2+4;
}
void manacher()
{
 int mx=0,id=0;
 int len2=strlen(str2);
 for(int i=1;i<nn;i++)
 {
  if(mx>i)
   rad[i]=Min(rad[2*id-i],mx-i);
  else
   rad[i]=1;
  for(;str2[i-rad[i]]==str2[i+rad[i]];rad[i]++)
   ;
  if(rad[i]+i>mx)
  {
   mx=rad[i]+i;
   id=i;
  }
 }
}
int main(void)
{
 int i;
 while(scanf(""%s"",str1)!=EOF)
 {
  init();//预处理
  manacher();
  int max=0;
  int len2=strlen(str2);
  for(i=0;i<nn;i++)
  {
   if(max<rad[i])
    max=rad[i];
  }
  cout<<max-1<<endl;
 }
 return 0;
}
PKU3974
/*
name:cchun
PROG:PKU3974
algorithm:manacher
*/
#include<iostream>
#include<string>
#include<string.h>
#define Min(a,b) a>b? b:a
const int MAX=1000005;
using namespace std;
char str2[MAX*3],str1[MAX];
int nn;
int rad[MAX*3];
void init()
{
 int i;
 str2[0]='$';
 str2[1]='#';
 int len1=strlen(str1);
 for(i=0;i<len1;i++)
  str2[i*2+2]=str1[i],str2[i*2+3]='#';
 str2[(i-1)*2+4]='\0';
 nn=(i-1)*2+4;
}
void manacher()
{
 int mx=0,id=0;
 int len2=strlen(str2);
 for(int i=1;i<nn;i++)
 {
  if(mx>i)
   rad[i]=Min(rad[2*id-i],mx-i);
  else
   rad[i]=1;
  for(;str2[i-rad[i]]==str2[i+rad[i]];rad[i]++)
   ;
  if(rad[i]+i>mx)
  {
   mx=rad[i]+i;
   id=i;
  }
 }
}
int main(void)
{
 int i,cas_c=1;
 while(scanf(""%s"",str1),strcmp(str1,""END""))
 {
  cout<<""Case ""<<cas_c++<<"": "";
  init();//预处理
  manacher();
  int max=0;
  int len2=strlen(str2);
  for(i=0;i<nn;i++)
  {
   if(max<rad[i])
    max=rad[i];
  }
  cout<<max-1<<endl;
 }
 return 0;
}
"
154,"zoj1041  poj1106  Transmitters_xiao_mifan_新浪博客

Description
 

 In a wireless network with multiple transmitters sending on the same frequencies, it is often a requirement that signals don't overlap, or at least that they don't conflict. One way of accomplishing this is to restrict a transmitter's coverage area. This problem uses a shielded transmitter that only broadcasts in a semicircle.
 
 A transmitter T is located somewhere on a 1,000 square meter grid. It broadcasts in a semicircular area of radius r. The transmitter may be rotated any amount, but not moved. Given N points anywhere on the grid, compute the maximum number of points that can be simultaneously reached by the transmitter's signal. Figure 1 shows the same data points with two different transmitter rotations.
 
 
 
   poj1106  Transmitters"" title=""zoj1041  poj1106  Transmitters"">
  
 
 All input coordinates are integers (0-1000). The radius is a positive real number greater than 0. Points on the boundary of a semicircle are considered within that semicircle. There are 1-150 unique points to examine per transmitter. No points are at the same location as the transmitter.
 
Input
 

 Input consists of information for one or more independent transmitter problems. Each problem begins with one line containing the (x,y) coordinates of the transmitter followed by the broadcast radius, r. The next line contains the number of points N on the grid, followed by N sets of (x,y) coordinates, one set per line. The end of the input is signalled by a line with a negative radius; the (x,y) values will be present but indeterminate. Figures 1 and 2 represent the data in the first two example data sets below, though they are on different scales. Figures 1a and 2 show transmitter rotations that result in maximal coverage.
 

Output
 

 For each transmitter, the output contains a single line with the maximum number of points that can be contained in some semicircle.
 

Sample Input
25 25 3.5
7
25 28
23 27
27 27
24 23
26 23
24 29
26 29
350 200 2.0
5
350 202
350 199
350 198
348 200
352 200
995 995 10.0
4
1000 1000
999 998
990 992
1000 999
100 100 -2.5
Sample Output
3
4
4
利用向量叉积
#include<stdio.h>
 #include<math.h>
 int x[1010],y[1010];
 int main()
 {
 int x1,y1,a,b,i,j,n,k,num,max,ans;
 double r;
 while(scanf(""%d%d%lf"",&x1,&y1,&r),r>=0)
 {
 r=r*r;
 scanf(""%d"",&n);
 j=0;
 for(i=0;i<n;i++)
 {
 scanf(""%d%d"",&a,&b);
 if((x1-a)*(x1-a)+(y1-b)*(y1-b)<=r)
 {
 x[j]=a-x1;
 y[j]=b-y1;
 j++;
 }
 }
 max=0;
 for(i=0;i<j;i++)
 {
 num=1;ans=1;
 for(k=0;k<j;k++)
 if(i!=k)
 {
 if(x[i]*y[k]-x[k]*y[i]>=0)
 num++;
 if(x[i]*y[k]-x[k]*y[i]<=0)
 ans++;
 }
 if(num>max)max=num;
 if(ans>max)max=ans;
 }
 printf(""%d\n"",max);
 }
 return 0;
 }
"
158,"poj2181--Jumping Cows（DP）_易川_新浪博客

Description
Farmer John's cows would like to jump over the moon, just like the cows in their favorite nursery rhyme. Unfortunately, cows can not jump.
 The local witch doctor has mixed up P (1 <= P <= 150,000) potions to aid the cows in their quest to jump. These potions must be administered exactly in the order they were created, though some may be skipped.
 Each potion has a 'strength' (1 <= strength <= 500) that enhances the cows' jumping ability. Taking a potion during an odd time step increases the cows' jump; taking a potion during an even time step decreases the jump. Before taking any potions the cows' jumping ability is, of course, 0.
 No potion can be taken twice, and once the cow has begun taking potions, one potion must be taken during each time step, starting at time 1. One or more potions may be skipped in each turn.
 Determine which potions to take to get the highest jump.
Input
 

 * Line 1: A single integer, P
 
 * Lines 2..P+1: Each line contains a single integer that is the strength of a potion. Line 2 gives the strength of the first potion; line 3 gives the strength of the second potion; and so on.
 
 
 Output
 

 * Line 1: A single integer that is the maximum possible jump.
 
Sample Input
8
 7
 2
1
 8
 4
 3
 5
 6
Sample Output
17
////////////////////////////////////////////////////////////
题意是有P瓶魔法药水，能让牛每次跳的高度相应的增加或减少。有头牛每跳一步喝一瓶，当它跳的是第奇数步，跳的高度增加a[i],如果是第偶数步，跳得高度就减少a[i].问怎样合理安排，让牛跳得更高？
·                # include<stdio.h>
·                # include<string.h>
·                int h1[200000],h2[200000];//h1[],h2[]分别记录喝第i瓶药水时，如果是奇数步时的高度和是偶数步时的高度!!!
·                int a[200000];
·                int main()
·                {
·                      int i,p,max1,max2;
·                      scanf(""%d"",&p);
·                      for(i=1;i<=p;i++)
·                            scanf(""%d"",&a[i]);
·                      memset(h1,0,sizeof(h1));
·                      memset(h2,0,sizeof(h2));
·                      for(i=1;i<=p;i++)
·                      {
·                            if(i==1)
·                            {
·                                  h1[i]=a[i];
·                                  h2[i]=0;
·                            }
·                            else
·                            {
·                                  h1[i]=h2[i-1]+a[i];//如果是奇数步，那该步的高度为前偶数步+a[i];
·                                  if(h1[i]<h1[i-1])
·                                        h1[i]=h1[i-1];
·                                  h2[i]=h1[i]-a[i];如果是偶数步，那该步的高度为前奇数步-a[i];
·                                  if(h2[i]<h2[i-1])
·                                        h2[i]=h2[i-1];
·                            }
·                 
·                      }
·                      max1=max2=-1;
·                      for(i=1;i<=p;i++)
·                      {
·                            if(max1<h1[i])
·                                  max1=h1[i];
·                            if(max2<h2[i])
·                                  max2=h2[i];
·                      }
·                      if(max1<max2)
·                            max1=max2;
·                      printf(""%d\n"",max1);
·                      return 0;
·                }
"
160,"Poj3567/Bzoj1023 Cactus 仙人掌图的直径 | [IOI2008] Island ---树上DP+环上单调队列_Poetize Space_百度空间

这两个题主体思路差不多，都是在树上树状DP、环上单调队列优化的DP。只不过前者的图是一棵仙人掌，后者的图是一棵外/内向树。
前者题目描述很直接：求仙人掌直径；后者仔细分析可以发现，答案就是各个连通分量内最长链之和。
设F[i]表示点i为根的子树中最长链有多长。
对于这两个题，图中的边实际上只有两种：1.割边，也就是在树上的边。2.非割边，也就是在环上的边（双连通分量内部的边）。
对于割边(u,v)，如果u是v的父亲，首先用F[v]+F[u]+w(u,v)更新ans，因为此时还没有用F[v]更新F[u]，所以F[u]一定是从另一个儿子转移来的；然后再用F[v]+w(u,v)更新F[u]。
对于环上两点(u,v)，我们用F[u]+F[v]+dist(u,v)更新ans，对于Cactus一题，还要用F[v]+dist(u,v)更新某个环在DFS树上的最高点u。
Cactus这题，我们需要在Tarjan的过程中找出割边并且用上述方法更新，同时找出所有的环，当这个环上的所有点的F[]值都被更新完之后，立即对这个环进行处理。具体做法是：对于一个点x，如果存在一条边(x,y)，并且在DFS树中x不是y的父亲，并且dfn[x]<dfn[y]，说明x和y是一个环上两个相邻的点，并且在DFS树中二者没有相邻，因此此时环上(x……y)这些点都已经DFS过了，就可以对这个环进行处理了。
Island这题，首先遍历一遍图，找出各个连通分量并标记，对于每个连通分量都用变量维护最长链。然后利用拓扑序自底向上BFS，处理完所有的树边，此时就只剩下一个个环了。
那么接下来两者面临的就是同一个问题：在O(n)时间内处理一个环。
我们要用到单调队列优化的DP。首先把环拆成链放到一个数组里，然后把数组扩大一倍（也就是复制一遍接到后边），这样就相当于一个环了。然后对于决策i和j，当前循环到的点+1时，决策i和j距离当前循环到的点的距离同时+1，因此如果某时刻i比j优，那么下一时刻i仍然比j优，所以决策单调。跟据题目的不同要留，Cactus这题当队头决策和当前点相距超过半个环长时删掉队头，Island这题相距达到一个环长时删掉队头决策。
具体问题详见代码，代码还是比较容易看懂的，代码长度两道题都排第一。。
POJ3567 / Bzoj1023 Cactus
#include<iostream>
#include<cstdio>
using namespace std;
const int u=50010,w=200010;
int ver[w],next[w],head[u],dfn[u],low[u],fa[u],f[u],q[u*2],a[u*2];
int n,m,tot,num,ans,i,j,k,x,y;
void add(int x,int y)
{
 ver[++tot]=y; next[tot]=head[x]; head[x]=tot;
}
void dp(int x,int y)
{
 int m,i,l,r,p;
 for(m=0;y!=x;y=fa[y]) a[++m]=f[y];
 for(a[++m]=f[x],i=1;i<m;i++) a[m+i]=a[i];
 l=r=q[1]=1; p=m/2;
 for(i=2;i<=m+p;i++)
 {
  while(l<=r&&i-q[l]>p) l++;
  ans=max(ans,a[q[l]]+a[i]+i-q[l]);
  while(l<=r&&a[q[r]]+i-q[r]<=a[i]) r--;
  q[++r]=i;
 }
 for(i=1;i<m;i++) f[x]=max(f[x],a[i]+min(i,m-i));
}
void tarjan(int x)
{
 dfn[x]=low[x]=++num;
 for(int i=head[x];i;i=next[i])
  if(fa[x]!=ver[i])
   if(!dfn[ver[i]])
   {
    fa[ver[i]]=x;
    tarjan(ver[i]);
    low[x]=min(low[x],low[ver[i]]);
    if(dfn[x]<low[ver[i]])
    {
     ans=max(ans,f[x]+f[ver[i]]+1);
     f[x]=max(f[x],f[ver[i]]+1);
    }
   }
   else low[x]=min(low[x],dfn[ver[i]]);
 for(int i=head[x];i;i=next[i])
  if(fa[ver[i]]!=x&&dfn[x]<dfn[ver[i]]) dp(x,ver[i]);
}
int main()
{
 cin>>n>>m;
 for(i=1;i<=m;i++)
 {
  scanf(""%d%d"",&k,&x);
  for(j=1;j<k;j++)
  {
   scanf(""%d"",&y);
   add(x,y); add(y,x);
   x=y;
  }
 }
 tarjan(1);
 cout<<ans<<endl;
 return 0;
}
 Bzoj1791 [IOI2008] Island
#include<iostream>
#include<cstdio>
using namespace std;
const int u=1000010;
int ver[2*u],edge[2*u],next[2*u],head[u],du[u],c[u],v[u],q[2*u];
long long f[u],d[u],a[2*u],b[2*u],ans;
int n,m,tot,t,i,x,y;
void add(int x,int y,int z)
{
 ver[++tot]=y; edge[tot]=z; next[tot]=head[x]; head[x]=tot; du[y]++;
}
void bfs(int s,int t)
{
 int l,r,i;
 q[l=r=1]=s; c[s]=t;
 while(l<=r)
 {
  for(i=head[q[l]];i;i=next[i])
   if(!c[ver[i]]) {q[++r]=ver[i]; c[ver[i]]=t;}
  l++;
 }
}
void topsort()
{
 int l=1,r=0,i,x,y;
 for(i=1;i<=n;i++)
  if(du[i]==1) q[++r]=i;
 while(l<=r)
 {
  for(i=head[x=q[l]];i;i=next[i])
   if(du[y=ver[i]]>1)
   {
    d[c[x]]=max(d[c[x]],f[x]+f[y]+edge[i]);
    f[y]=max(f[y],f[x]+edge[i]);
    if((--du[y])==1) q[++r]=y;
   }
  l++;
 }
}
void dp(int t,int x)
{
 int m=0,i,l=0,r,y=x;
 do{
  a[++m]=f[y]; du[y]=1;
  for(i=head[y];i;i=next[i])
   if(du[ver[i]]>1)
    {y=ver[i]; b[m+1]=b[m]+edge[i]; break;}
 }while(i);
 if(m==2)
 {
  for(i=head[y];i;i=next[i])
   if(ver[i]==x) {l=max(l,edge[i]);}
  d[t]=max(d[t],f[x]+f[y]+l);
  return;
 }
 for(i=head[y];i;i=next[i])
  if(ver[i]==x) {b[m+1]=b[m]+edge[i]; break;}
 for(i=1;i<m;i++) {a[m+i]=a[i]; b[m+i]=b[m+1]+b[i];}
 q[l=r=1]=1;
 for(i=2;i<2*m;i++)
 {
  while(l<=r&&i-q[l]>=m) l++;
  d[t]=max(d[t],a[i]+a[q[l]]+b[i]-b[q[l]]);
  while(l<=r&&a[q[r]]+b[i]-b[q[r]]<=a[i]) r--;
  q[++r]=i;
 }
}
int main()
{
 cin>>n;
 for(i=1;i<=n;i++)
 {
  scanf(""%d%d"",&x,&y);
  add(i,x,y); add(x,i,y);
 }
 for(i=1;i<=n;i++)
  if(!c[i]) bfs(i,++t);
 topsort();
 for(i=1;i<=n;i++)
  if(du[i]>1&&!v[c[i]])
  {
   v[c[i]]=1;
   dp(c[i],i);
   ans+=d[c[i]];
  }
 cout<<ans<<endl;
 return 0;
}
"
161,"pku1274（基本的二分图最大匹配） - 弓虽子 - 博客频道 - CSDN.NET

http://162.105.81.212/JudgeOnline/problem?id=1274
题意：有m头奶牛和n个牛棚，其中每头奶牛只愿意进它愿意进的牛棚。也许每头牛只愿进一个棚，也许一个棚只容纳一头牛。现在给定m头年和n个牛棚，并且给定每头牛愿意进的牛棚编号，请让你设计一种牛对棚的方案，使牛——棚的匹配数最大，并输出这个最大匹配值。
思路：其实这题就是求一个二分图最大匹配。
下面是用邻接矩阵写的AC~
#include<iostream>
using namespace std;
const int maxn = 201;
const int maxm = 201;
int uN, vN;
bool g[maxn][maxn];
int xM[maxn], yM[maxn];
bool chk[maxn];
bool find(int u)
{
	int v;
	for(v=1; v<=vN; v++)
		if(g[u][v] && !chk[v])
		{
			chk[v] = true;
			if(yM[v] == -1 || find(yM[v]))
			{
				yM[v] = u; xM[u] = v;
				return true;
			}
		}
	return false;
}
int MaxMatch()
{
	int u, ret = 0;
	memset(xM, -1, sizeof(xM));
	memset(yM, -1, sizeof(yM));
	for(u=1; u<=uN; u++)
		if(xM[u] == -1)
		{
			memset(chk, false, sizeof(chk));
			if(find(u))
				ret++;
		}
	return ret;
}
int main()
{
	int i, j, k, x, y;
	int ans;
	while(cin>>uN>>vN)		//0ms
	//while(scanf(""%d%d"",&uN,&vN) != EOF)  //16ms
	{
		memset(g, false, sizeof(g));
		for(x=1; x<=uN; x++)
		{
			cin>>k;
			//scanf(""%d"",&k);
			for(j=1; j<=k; j++)
			{
				cin>>y;
				//scanf(""%d"",&y);
				g[x][y] = true;
			}
		}
		ans = MaxMatch();
		cout<<ans<<endl;
		//printf(""%d/n"",ans);
	}
	return 0;
} 
但是用链表写的就超时：
#include<iostream>
using namespace std;
const int maxn = 201;
const int maxm = 201;
struct gtype
{
	int x, y, next;
};
gtype g[maxm];
int first[maxn];
int link[maxn];
bool used[maxn];
int n, m, tot;
void add(int x, int y)
{
	tot++;
	g[tot].x = x;
	g[tot].y = y;
	g[tot].next = first[x];
	first[x] = tot;
}
bool find(int s)
{
	int temp;
	temp = first[s];
	while(temp != -1)
	{
		if( !used[g[temp].y])
		{
			used[g[temp].y] = true;
			if(link[g[temp].y]==0 || find(link[g[temp].y]))
			{
				link[g[temp].y] = s;
				return true;
			}
		}
		temp = g[temp].next;
	}
	return false;
}
int main()
{
	int i, j, k, x, y;
	int ans;
	while(scanf(""%d%d"",&n, &m) != EOF)
	{
		for(x=1; x<=n; x++)
		{
			scanf(""%d"",&k);
			for(j=1; j<=k; j++)
			{
				scanf(""%d"",&y);
				add(x, y);
			}
		}
		memset(link, 0, sizeof(link));
		for(i=1; i<=n; i++)
		{
			memset(used, false, sizeof(used));
			find(i);
		}
		ans = 0;
		for(i=1; i<=n; i++)
		{
			if(link[i] != 0)
				ans++;
		}
		printf(""%d/n"",ans);
	}
	return 0;
} 
"
164,"poj 2790 dfs - 天逸南爵的专栏 - 博客频道 - CSDN.NET

#include<iostream>
#include<cstdio>
using namespace std;
//dfs
//给定一个n*m矩阵0-1矩阵，每行代表1个人，每列代表一个事件，这个矩阵代表了每个人是否参加了某个事件
//找一个事件排列，使得每个人参加事件连续 枚举+回溯
const int maxn=400;
int n,m,len;
char map[maxn][maxn];
int sum[maxn];//sum[i]表示第i个参与的事件总数
int s[maxn];//保存排列
int cnt[maxn];///置换后的每个人参加的事件数
bool use[maxn];///use[i]表示第i列是否有
bool check(int x)///检查该列
{
    int i,ans=0;
    for(i=0; i<n; i++)
    {
        if(map[i][x]==0)///i不参加x列活动
        {
            if(cnt[i]>0&&cnt[i]<sum[i])///i 已经参加活动 ；x活动不能被参加
            return 0;
        }
    }
    return 1;
}
bool dfs(int x)
{
    if(x==m)return 1;
    int i,j;
    for(i=1; i<m; i++) ///枚举每一列
    {
        if(use[i]==0&&check(i))
        {
            for(j=0; j<n; j++)
            {
                cnt[j]+=map[j][i];
            }
            s[x]=i;
            use[i]=1;
            if(dfs(x+1))return 1;
            use[i]=0;
            for(j=0; j<n; j++)cnt[j]-=map[j][i];
        }
    }
    return 0;
}
int main()
{
    int i,j,k;
    while(scanf(""%d%d"",&n,&m)!=EOF)
    {
        for(i=0; i<n; i++)
        {
            sum[i]=0;
            scanf(""%s"",map[i]);
            for(j=0; j<m; j++)
            {
                map[i][j]-='0';
                sum[i]+=map[i][j];
            }
        }
        for(i=0; i<n; i++)cnt[i]=map[i][0];
        s[0]=0;
        dfs(1);
        for(i=0; i<m; i++)printf(""%d\n"",s[i]);
    }
    return 0;
}
"
167,"POJ2038 - hongshundi的专栏 - 博客频道 - CSDN.NET

摘要：水题，用了next_permutation
#include <iostream>
 #include <algorithm>
 #include <string>
 using namespace std; 
 const int size = 100;
 const int length = 5;
 int array[length];
 string data[size+1];
 int n = 0;
 int calDist()
 {
     int dist = 0;    
     for(int i=1; i<=n; i++){
         for(int j=0; j<length; j++){
             for(int k=j+1; k<length; k++){
                 int index_1 = 0; 
                 int index_2 = 0;
                 for(int s=0; s<length; s++){
                     if(data[i].at(s) == array[j]){
                         index_1 = s;    
                     }    
                     if(data[i].at(s) == array[k]){
                         index_2 = s;
                     }
                 }
                 if(index_1 > index_2){
                     dist++;
                 }
             }
         }            
     }
     return dist;
 }
 int main()
 {
     while( cin >> n ){
         if( n == 0 ){
             break;
         }
         for(int i=1; i<=n; i++){
             cin >> data[i]; 
         }    
         int min_value = 100 * 10;
         for(int i=0; i<length; i++){
             array[i] = 'A'+i;    
         }
         string median_str = ""ABCDE"";    
         min_value = min(min_value, calDist());
         while( next_permutation(array, array+length) ){
             int value = calDist();
             if( value < min_value ){
                 min_value = value;
                 median_str.clear();
                 char buf[10];    
                 for(int i=0; i<length; i++){
                     sprintf(buf, ""%c"", array[i]);
                     median_str += buf;    
                 }
             }    
         }    
         cout << median_str << "" is the median ranking with value "" << min_value << ""."" << endl;    
     }
 }
"
173,"[pku1716]Integer Intervals - lovekid的日志 - 网易博客

Source Code
 
 
  
   
   Problem: 1716 
    
   User: loveKid
   
   
   Memory: 248K 
    
   Time: 0MS
   
   
   Language: C++ 
    
   Result: Accepted
  
 
 
 
 Source Code  
 //贪心...周赛卡住了... 
 #include<stdio.h>
#include<algorithm>
using namespace std;
int n;
struct lovekid{
 int start,end;
}kid[10002];
bool cmp(lovekid t1,lovekid t2){
 return t2.end>t1.end;
} 
 int main(){
 int i,currentS,currentE,ans;
 //freopen(""C:\\Documents and Settings\\Administrator\\桌面\\in.txt"",""r"",stdin);
 while(scanf(""%d"",&n)!=EOF){
  for(i=0;i<n;i++)
   scanf(""%d%d"",&kid[i].start,&kid[i].end);
  sort(kid,kid+n,cmp);
  currentS=kid[0].end-1;
  currentE=kid[0].end;
  for(ans=2,i=1;i<n;i++){
   if(kid[i].start<=currentS)continue;
   else if(kid[i].start<=currentE){
    ans++;
    currentS=currentE;
    currentE=kid[i].end;
   }
   else {
    ans+=2;
    currentS=kid[i].end-1;
    currentE=kid[i].end;
   }
   }
  printf(""%d\n"",ans);
 }
return 0;
}

"
174,"poj2703-Maximum Area Covered by Rectangles_abentu_新浪博客

    这道题的意思稍微绕了一点，其实读懂之后发现也不难：给出一些矩形，已知他们一定可以分成一些集合：每个集合里面的矩形的宽（矩形的短边边长）都相等，而且任何两个集合之间的矩形不存在覆盖关系（所谓覆盖关系就是一个矩形的长和宽大于另一个矩形的长和宽）。现在让你把这些矩形沿着xoy放在第一象限（横着数着两种方法），求矩形覆盖的最大面积。
    一个显而易见的事实，是每个集合里只要选出两个最大的矩形就好了，剩下的矩形都不用。而这两个矩形必然一个竖着一个横着放，至于这些被选出来的矩形应该怎么放，其实做一个小小的贪心就好了。严谨的话可以在写代码之前先证明一下（这个证明不是很难）不管怎么放只要一竖一横（如果一个集合只有一个矩形就随便怎么放都可以），整个图形覆盖的面积不变。这样的话这道题就简单了。
    水过~
代码：
#include <iostream>
 #include <cmath>
 #include <algorithm>
 #include <memory>
 #include <string>
 using namespace std;
 #define MAXN 1000+10
 struct rec
 {
     int x, y;
 }a[MAXN];
 bool operator < (rec a, rec b) {
     if (a.x < b.x) return true;
     if (a.x > b.x) return false;
     if (a.y > b.y) return true;
     else return false; 
 }
 int n;
 int main()
 {
     int i, w0, w, h1, h2, ans;
     while (cin >> n && n != -1) {
         for (i = 0; i < n; i++) cin >> a[i].x >> a[i].y;
         sort(a, a+n);
         ans = w0 = 0;
         for (i = 0; i < n; i++) {
             w = a[i].x; h1 = a[i].y;
             h2 = a[i+1].y; ans += (w - w0) * (w - w0);
             ans += (w - w0) * (h1 - w);
             ans += (w - w0) * (h2 - w);
             while (i+1 < n && w == a[i+1].x) i++;
             w0 = w;
         }
         cout << ans << endl;
     }
 return 0;
 }
"
179,"POJ3481 double queue——treap做法_lovedream_新浪博客

 记得校赛的时候包菜牛说过手打平衡树，现在终于会平衡树了，试了一下，果然很水……写了个treap，很无聊的TLE了一下就过了
#include<stdio.h>
 #include<string.h>
 #include<time.h>
 #include<stdlib.h>
int key1[1000010],key2[1000010],fa[1000010],ch[1000010][2],root;
inline void rotate(int n)
 {
     int t=fa[n];
     bool isr=(ch[t][1]==n);
    ch[t][isr]=ch[n][!isr],fa[ch[n][!isr]]=t;
     fa[n]=fa[t],fa[t]=n,ch[n][!isr]=t,ch[fa[n]][ch[fa[n]][1]==t]=n;
     if(!fa[n])
         root=n;
 }
 inline void insert(int k,int p)
 {
     int t=root;
     ch[k][0]=ch[k][1]=0;
     if(!root)
     {
         root=k;
         return ;
     }
    while(1)
     {
         if(p<key1[t])
         {
             if(!ch[t][0])
             {
                 ch[t][0]=k;
                 fa[k]=t;
                 break;
             }
             t=ch[t][0];
         }
         else
         {
             if(!ch[t][1])
             {
                 ch[t][1]=k;
                 fa[k]=t;
                 break;
             }
             t=ch[t][1];
         }
     }
     while(root-k&&key2[k]>key2[fa[k]])
         rotate(k);
 }
int get1()
 {
     if(!root)
         return 0;
     int t=root;
     if(!ch[root][0]&&!ch[root][1])
     {
         root=0;
         return t;
     }
     while(ch[t][1])
         t=ch[t][1];
     ch[fa[t]][1]=ch[t][0],fa[ch[t][0]]=fa[t];
     if(t==root)
         root=ch[t][0];
     return t;
 }
int get2()
 {
     if(!root)
         return 0;
     int t=root;
     if(!ch[root][0]&&!ch[root][1])
     {
         root=0;
         return t;
     }
     while(ch[t][0])
         t=ch[t][0];
     ch[fa[t]][0]=ch[t][1],fa[ch[t][1]]=fa[t];
     if(t==root)
         root=ch[t][1];
     return t;
 }
int main()
 {
     int r,k,p;
     srand(time(0));
    while(scanf(""%d"",&r),r)
     {
         if(r==1)
         {
             scanf(""%d%d"",&k,&p);
             key1[k]=p,key2[k]=rand();
             insert(k,p);
         }
         else if(r==2)
             printf(""%d\n"",get1());
         else
             printf(""%d\n"",get2());
     }
 }
"
183,"POJ 2418 Hardwood Species(排序二叉树) - Alasky的日志 - 网易博客

//不用平衡技术的后果...果断1313MS


 //一般我的代码会相对比较长，因为我自己写栈。。初学者还是多自己写写吧。。。


 



 
  #include ""stdio.h""
 
 
  #include ""string.h""
 
 
  #include ""malloc.h""
 
 
  #include ""stdlib.h""
 
 
  

 
 
  #define SIZE 30
 
 
  #define STACKSIZE 10000
 
 
  #define EQ(a, b) (!strcmp((a), (b)))
 
 
  #define RT(a, b) (strcmp((a), (b)) > 0)
 
 
  #define LT(a, b) (strcmp((a), (b)) < 0)
 
 
  

 
 
  typedef struct BSTNode{
 
 
   int n;
   
  //amount of the tree of this type
 
 
   char key[SIZE+1];
   
  //tree name
 
 
   BSTNode *lchild, *rchild;
 
 
  }BSTNode, *BSTree;
 
 
  

 
 
  BSTree root;
 
 
  int total;
   
  //树的总数
 
 
  

 
 
  //____________得，自己再写一个栈，The fact is that it only costs a few time. 
 
 
  typedef struct SNode{
 
 
   BSTree *base;
 
 
   BSTree *top;
 
 
   int stacksize;
 
 
  }SqStack;
 
 
  

 
 
  bool InitStack(SqStack &S){
 
 
   
  //初始化一个栈
 
 
   if (!(S.base = (BSTree*)malloc(STACKSIZE*sizeof(BSTree)))) exit(0);
 
 
   S.top = S.base;
 
 
   S.stacksize = STACKSIZE;
 
 
   return true;
 
 
  }
  //InitStack
 
 
  bool Push(SqStack &S, BSTree e){
 
 
   if (S.top - S.base >= S.stacksize){
 
 
   S.base = (BSTree *)realloc(S.base, (S.stacksize + STACKSIZE)*sizeof(BSTree));
 
 
   if (!S.base) exit(0);
 
 
   S.top = S.base + S.stacksize;
 
 
   S.stacksize += STACKSIZE;
 
 
   }
 
 
   *S.top++ = e;
 
 
   return true;
 
 
  }
  //Push
 
 
  bool Pop(SqStack &S, BSTree &e){
 
 
   if (S.top == S.base)
 
 
   return false;
 
 
   e = *(--S.top);
 
 
   return true;
 
 
  }
  //Pop
 
 
  bool EmptyStack(SqStack &S){
 
 
   if (S.top == S.base)
 
 
   return true;
 
 
   else return false;
 
 
  }
  //EmptyStack
 
 
  

 
 
  bool SearchBST(BSTree T, char *key, BSTree f, BSTree &p){
 
 
   
  //在二叉树中查找key，查找成功，对应n值+1；否则
 
 
   //p值返回应该插入的结点的双亲
 
 
   if (!T) {p = f; return false;}
 
 
   else if (EQ(key, T->key)) {T->n++; return true;}
 
 
   else if (LT(key, T->key)) return SearchBST(T->lchild, key, T, p);
 
 
   else return SearchBST(T->rchild, key, T, p);
 
 
  }
  //SearchBST
 
 
  bool InsertBST(BSTree &T, char *e){
 
 
   
  //查找e.key，如果存在n值+1；否则插入
 
 
   BSTNode *p;
 
 
   if (!SearchBST(T, e, NULL, p)){
 
 
   BSTNode *s = (BSTree)malloc(sizeof(BSTNode));
 
 
   s->n = 1;
 
 
   strcpy(s->key, e);
 
 
   s->lchild = s->rchild = NULL;
 
 
   
 
 
   if (!p) T = s;
 
 
   else if (LT(e, p->key)) p->lchild = s;
 
 
   else p->rchild = s;
 
 
   return true;
 
 
   }
 
 
   return false;
 
 
  }
  //InsertBST
 
 
  //从小到大输出需要中序遍历
 
 
  bool InOrdTraverse(BSTree T){
 
 
   
  //中序遍历排序二叉树，虽然这里我没有引入平衡二叉树的结构，但勉强来一次吧。。
 
 
   //damn it!!我突然发现，Stack is in demand。。。。。more time will elaps~~~~
 
 
   SqStack S;
 
 
   InitStack(S);
 
 
   while (T || !EmptyStack(S)){
 
 
   if (T){
 
 
   Push(S, T);
 
 
   T = T->lchild;
 
 
   }
 
 
   else{
 
 
   Pop(S, T);
 
 
   printf(""%s %.4lf\n"", T->key, (double)T->n/total*100);
 
 
   T = T->rchild;
 
 
   }
 
 
   }
 
 
   return true;
 
 
  }
  //InOrdTraverse
 
 
  

 
 
  int main(){
 
 
   char s[SIZE+1];
 
 
   total = 0;
 
 
   while (gets(s)){
 
 
   total++;
 
 
   InsertBST(root, s);
   
 
 
   }
 
 
   InOrdTraverse(root);
 
 
   return 0;
 
 
  }
 
"
186,"pku 2987 Firing 最大权闭合图 dinic模板实现最小割_SZW的空间_百度空间

/**

problem: 公司要炒一些员工的鱿鱼, 若A被炒了, 那A的所有下属也会跟着被炒, 下属关系具有传递性,且可能构成环, 即A是B的下属, B又间接是A的下属, 炒掉每个人公司会得到一笔收益, 收益可能为负, 问在收益最大的前提下, 最少要炒掉哪些人, 以及最大收益是多少. ——copy

具体解法我就不说了，在刘汝佳黑书上的“航天计划”是一个类型。

我讲一下注意点：首先是数据类型，中间结果会超过int，可用long long 代替；其次，数据量比较大，宁可开大点，也不要斤斤计较.我就为此付出了好几次tle，我也不知道为什么是tle,害得我找不出错误。

*/

#include <stdio.h>

#include <iostream>

#include <string.h>

#include <memory.h>

using namespace std;

const int inf = 1000000000;       // max of cost

const int N=5005;

const int E=200005;

struct edge

{

int x, y, nxt;

int c;

} bf[E];

int ne, head[N], cur[N], ps[N], dep[N];

bool flag[N];

inline void addedge(int x, int y, int c)

{   // add an arc(x -> y, c); vertex: 0 ~ n-1;

bf[ne].x = x; bf[ne].y = y; bf[ne].c = c;

bf[ne].nxt = head[x]; head[x] = ne++;

bf[ne].x = y; bf[ne].y = x; bf[ne].c = 0;

bf[ne].nxt = head[y]; head[y] = ne++;

}

long long flow(int n, int s, int t)

{

long long res = 0;

int tr;

int i, j, k, f, r, top;

while (1)

{

memset(dep, -1, n * sizeof(int));

for (f = dep[ps[0] = s] = 0, r = 1; f != r; )

for (i = ps[f++], j = head[i]; j; j = bf[j].nxt)

{

if (bf[j].c && -1 == dep[k = bf[j].y])

{

dep[k] = dep[i] + 1; ps[r++] = k;

if (k == t) { f = r; break; }

}

}

if (-1 == dep[t]) break;

memcpy(cur, head, n * sizeof(int));

for (i = s, top = 0; ; )

{

if (i == t)

{

for (k = 0, tr = inf; k < top; ++k)

if (bf[ps[k]].c < tr)

tr = bf[ps[f = k]].c;

for (k = 0; k < top; ++k)

bf[ps[k]].c -= tr, bf[ps[k]^1].c += tr;

res += tr;

i = bf[ps[top = f]].x;

}

for  (j=cur[i];  cur[i];  j  =  cur[i]  =  bf[cur[i]].nxt)

if  (bf[j].c  &&  dep[i]+1  ==  dep[bf[j].y])  break;

if (cur[i])

{

ps[top++] = cur[i];

i = bf[cur[i]].y;

}

else

{

if (0 == top) break;

dep[i] = -1; i = bf[ps[--top]].x;

}

}

}

return res;

}

void dfs(int v)

{

flag[v]=true;

for(int i=head[v];i!=0;i=bf[i].nxt)  //循环写错，错误难找，害人阿

{

if(!flag[bf[i].y] && bf[i].c>0)

{

//printf(""%d %d\n"",bf[i].y,bf[i].c);

dfs(bf[i].y);

}

}

}

int main()

{

int s,t,a,b,c;

int n,m;

long long sum;

while(scanf(""%d%d"",&n,&m)!=EOF)

{

//init

memset(head,0,sizeof(head));

memset(flag,false,sizeof(flag));

ne=2;

 //build graph

s=0;t=n+1;sum=0;

for(int i=1;i<=n;i++)

{

scanf(""%d"",&c);

if(c>0)

addedge(s,i,c),sum+=c;

else

addedge(i,t,-c);

}

for(int i=0;i<m;i++)

{

scanf(""%d%d"",&a,&b);

addedge(a,b,inf);

}

long long rec=flow(n+2,0,n+1);

int cnt=0;

dfs(0);

for(int i=1;i<=n;i++)

if(flag[i])  cnt++;

printf(""%d %lld\n"",cnt,sum-rec);

}

return 0;

}

"
189,"pku2777 Count Color - Beetlebum - 博客园

思路：用位图记录区间已涂上的颜色
 

 
 #include 
 <
 iostream
 >
 
 
 using
  
 namespace
  std;
 
 #define
  clr(x) memset(x,0,sizeof(x))
 
 
 #define
  max(a,b) (a>b?a:b)
 
 
 #define
  min(a,b) (a<b?a:b)
 
 
 #define
  MAXN 100002
 
 
 struct
  Node{
     
 int
  l,r;
     __int64 s;
 }nod[MAXN
 *
 3
 ];
 inline 
 bool
  single(__int64 a){
     
 return
  (((a
 -
 2
 ) 
 &
  a)
 ==
 0
 );
 }
 
 void
  init(
 int
  tag,
 int
  l,
 int
  r){
     nod[tag].l
 =
 l;
     nod[tag].r
 =
 r;
     nod[tag].s
 =
 2
 ;
     
 if
 (l
 ==
 r){
         
 return
 ;
     }
     init(tag
 *
 2
 ,l,(l
 +
 r)
 /
 2
 );
     init(tag
 *
 2
 +
 1
 ,(l
 +
 r)
 /
 2
 +
 1
 ,r);
 }
 
 void
  query(
 int
  tag,
 int
  l,
 int
  r,__int64 
 &
 ss){
     
 if
 (l
 <=
 nod[tag].l 
 &&
  nod[tag].r
 <=
 r){
         ss
 |=
 nod[tag].s;
         
 return
 ;
     }
     
 if
 (single(nod[tag].s)){
 //
 若该结点所示区间为单色，则其儿子所示区间也为单色，故无需再查看以该结点为根的树
 
 
         ss
 |=
 nod[tag].s;
         
 return
 ;
     }
     
 if
 (l
 <=
 nod[tag
 *
 2
 ].r)
         query(tag
 *
 2
 ,l,r,ss);
     
 if
 (r
 >=
 nod[tag
 *
 2
 +
 1
 ].l)
         query(tag
 *
 2
 +
 1
 ,l,r,ss);
 }
 
 void
  paint(
 int
  tag,
 int
  l,
 int
  r,
 int
  c){
 //
 将[l,r]涂成颜色c
 
 
     
 if
 (l
 <=
 nod[tag].l 
 &&
  nod[tag].r
 <=
 r){
         nod[tag].s
 =
 (
 1
 <<
 c);
         
 return
 ;
     }
     
 if
 (nod[tag].s
 ==
 (
 1
 <<
 c))
 //
 若该区间已被染成颜色c则无需再染
 
 
         
 return
 ;
     
 if
 (single(nod[tag].s)){
 //
 若该区间为单色，则在上一次改变中，其儿子没有被改变，又因为需要进入该区间的子树，所以必须先将儿子更新为单色
 
 
         nod[tag
 *
 2
 ].s
 =
 nod[tag].s;
         nod[tag
 *
 2
 +
 1
 ].s
 =
 nod[tag].s;
     }
     
 if
 (l
 <=
 nod[tag
 *
 2
 ].r)
         paint(tag
 *
 2
 ,l,r,c);
     
 if
 (r
 >=
 nod[tag
 *
 2
 +
 1
 ].l)
         paint(tag
 *
 2
 +
 1
 ,l,r,c);
     nod[tag].s
 =
 nod[tag
 *
 2
 ].s
 |
 nod[tag
 *
 2
 +
 1
 ].s;
 }
 
 int
  main(){
     
 int
  L,T,O,i,j,x,y,z,cnt;
     
 char
  ch[
 3
 ];
     __int64 ss;
     
 while
 (scanf(
 ""
 %d%d%d
 ""
 ,
 &
 L,
 &
 T,
 &
 O)
 !=
 EOF){
         init(
 1
 ,
 1
 ,L);
         
 for
 (i
 =
 0
 ;i
 <
 O;i
 ++
 ){
             scanf(
 ""
 %s
 ""
 ,ch);
             
 if
 (ch[
 0
 ]
 ==
 '
 C
 '
 ){
                 scanf(
 ""
 %d%d%d
 ""
 ,
 &
 x,
 &
 y,
 &
 z);
                 
 if
 (x
 >
 y){
                     
 int
  t
 =
 x;
                     x
 =
 y;
                     y
 =
 t;
                 }
                 paint(
 1
 ,x,y,z);
             }
             
 else
 {
                 scanf(
 ""
 %d%d
 ""
 ,
 &
 x,
 &
 y);
                 
 if
 (x
 >
 y){
                     
 int
  t
 =
 x;
                     x
 =
 y;
                     y
 =
 t;
                 }
                 ss
 =
 0
 ;
                 query(
 1
 ,x,y,ss);
                 cnt
 =
 0
 ;
                 
 for
 (j
 =
 1
 ;j
 <=
 T;j
 ++
 ){
                     
 if
 (ss
 &
 (
 1
 <<
 j))
                         cnt
 ++
 ;
                 }
                 printf(
 ""
 %d\n
 ""
 ,cnt);
             }
         }
     }
     
 return
  
 0
 ;
 }
"
190,"poj 3333_foreverlin_百度空间

#include<iostream>

using namespace std;

int n,sum;

//dfs,从1到n有序的检查 dfs

//这么想如果能回到比当前小的编号，那当然回去划算啦

//如果这点的跳跃点比当前大，且值比顺序走又多肯定不会选择跳跃 

typedef struct Node

{

    int d;//正常的查询 

    int td;//玩trick了他检查所需的时间

    int tc;//到下个房间去    

    }Node;

Node num[101]; 

bool s[101]; 

int b[101];

void dfs(int x,int c)

{

     if(x==n+1)

     {        

        if(c>sum)sum=c;

        return ;       

        }

     if(!s[x])

     {

        s[x]=1;      

        if((num[x].tc<x)||(b[num[x].tc]+num[x].d-b[x]-num[num[x].tc].d<num[x].td))      

        {

           dfs(num[x].tc,c+num[x].td);                                        

           }

        s[x]=0;         

        }

     if(s[x]==1||num[x].tc>=x)       

     {

        dfs(x+1,c+num[x].d); 

        }      

     } 

int main()

{

    int i,j,k,t;

    scanf(""%d"",&t);

    while(t--)

    {

          scanf(""%d"",&n);    

          for(i=1;i<=n;i++)

          {

              scanf(""%d%d%d"",&num[i].d,&num[i].td,&num[i].tc);

              s[i]=0;             

              }

          b[1]=0;        

          for(i=2;i<=n;i++)//记录顺序找的代价 

          {

              b[i]=b[i-1]+num[i-1].d;             

              }

          sum=0;

          dfs(1,0);

          printf(""%d\n"",sum);            

          }

    return 0;

    }

"
194,"pku1178解题报告_....._百度空间

http://162.105.81.212/JudgeOnline/problem?id=1178
题意：一个棋盘（8*8），一个王，还有n个马（n不确定），马有马的走法，王有王的走法，还有当王和马走到一个格子上时，马可以带着王走，输入一串字符，字母代表x坐标，数字代表y坐标，问最少经过多少步可以使棋盘上的棋子都到达同一个格子？
分析：先按照马走的线路建图，然后用floyd算出每两个点之间的最小步数，接着就是枚举，第一步枚举可能的汇聚点，第二步枚举一个马带走王的点，最后就是枚举每个马的位置，计算出最小的步数。
代码及部分注释：
#include<stdio.h>
#include<string.h>
#include<math.h>
#define MAX 70
#define INF 1<<29
int sx,sy;
int dx[MAX],dy[MAX];
char ch[MAX*2];
int cnt;
int ix[]={1,1,-1,-1,2,2,-2,-2};
int iy[]={2,-2,2,-2,1,-1,1,-1};
int dis[MAX][MAX];
int max(int a,int b)
{
    if(a>b)return a;
    else return b;
}
bool check(int x,int y)
{
    return (x>=0&&y>=0&&x<8&&y<8);
}
void init()//建图 以马走的路线建图 
{
    int i,j,k,x,y;
   // memset(dis,0,sizeof(dis));
   for(i=0;i<64;i++)
   for(j=0;j<64;j++)
    dis[i][j]=INF;
    for(i=0;i<8;i++)
    for(j=0;j<8;j++)
    for(k=0;k<8;k++)
    {
       x=ix[k]+i;
       y=iy[k]+j;
       if(!check(x,y))continue; 
       dis[i*8+j][x*8+y]=dis[x*8+y][i*8+j]=1;
    }
}
void floyd()
{ 
    int i,j,k;
    for(k=0;k<64;k++)
    for(i=0;i<64;i++)
    for(j=0;j<64;j++)
    {
      if(dis[i][j]>dis[i][k]+dis[k][j])
      dis[i][j]=dis[i][k]+dis[k][j]; 
    } 
for(i=0;i<64;i++)
   dis[i][i]=0;
}
void fun()
{
    int i,j,c,k,tmp,ans=INF,min;
    for(i=0;i<64;i++)//枚举可能的汇集点 
    for(j=0;j<64;j++)//枚举可能的带走王的位置 
    {
       tmp=max(abs(j%8-sx),abs(j/8-sy));//王走的步数 
       min=INF;
    for(c=0;c<cnt;c++)
    {
        k=dx[c]+dy[c]*8;
        tmp+=dis[i][k];//每个马到汇集点的距离 
        if(dis[i][j]+dis[k][j]-dis[i][k]<min)
        min=dis[i][j]+dis[k][j]-dis[i][k];//选择最少的带走王的马 
    }
    tmp+=min;
    if(ans>tmp)ans=tmp; 
    } 
    if(ans==INF)ans=0;
    printf(""%d\n"",ans);
}
int main()
{
    int i;
    while(scanf(""%s"",ch)!=EOF)
    {
        sx=ch[0]-'A';
        sy=ch[1]-'1';
        cnt=0;
        for(i=2;i<strlen(ch);i+=2)
        {
          dx[cnt]=ch[i]-'A';
          dy[cnt++]=ch[i+1]-'1'; 
        }
        init();
        floyd();
        fun();
    }
}
/*
Sample Input
D4A3A8H1H8
Sample Output
10
A1A2A3H2H5H6H7H8C1C2C5C6C7E2E3E4E5E6E7E8
42
*/
"
195,"pku2430 Lazy Cows - ccsu_001的专栏 - 博客频道 - CSDN.NET

题目链接：http://162.105.81.212/JudgeOnline/problem?id=2430
题意简述：求用最少的矩形把给定的点完全覆盖。
解题思路：状态dp。设0表示值覆盖一格，1表示覆盖两格但是属于同一矩形，2表示覆盖两格不属于同一矩形。
代码：
#include<stdio.h>
#include<algorithm>
using namespace std;
#define min(a,b) (a<b?a:b)
const int inf=(1<<30);
const int Len=1024;
struct node{
       int x,y;
}P[Len];
bool cmp(node a,node b)
{
     return a.y<b.y;
}
int dp[Len][Len][5];
int main()
{
    int n,k,b;
    while(scanf(""%d%d%d"",&n,&k,&b)!=EOF)
    {
         for(int i=1;i<=n;++i)
             scanf(""%d%d"",&P[i].x,&P[i].y);
         sort(P+1,P+1+n,cmp);
         dp[1][1][0]=1,dp[1][1][1]=2,dp[1][1][2]=inf,dp[1][2][2]=2;
         for(int i=2;i<=n;++i)
             for(int j=1;j<=k&&j<=i;++j)
                 for(int p=0;p<3;++p)
                 {
                      int Min=inf;
                      if(p==0)
                      {
                           if(j>1) for(int e=0;e<3;++e) Min=min(Min,dp[i-1][j-1][e]+1);
                           if(i>j)
                           {
                               int l=P[i].y-P[i-1].y;
                               if(P[i].x==P[i-1].x) Min=min(Min,dp[i-1][j][0]+l);
                               Min=min(Min,dp[i-1][j][2]+l);
                           }
                           dp[i][j][p]=Min;
                           continue;
                      }
                      if(p==1)
                      {
                           if(j>1) for(int e=0;e<3;++e) Min=min(Min,dp[i-1][j-1][e]+2);
                           if(i>j)
                           {
                               int l=P[i].y-P[i-1].y;
                               Min=min(Min,dp[i-1][j][1]+2*l);
                           }
                           dp[i][j][p]=Min;
                           continue;
                      }
                      if(j>2) for(int e=0;e<3;++e) Min=min(Min,dp[i-1][j-2][2]+2);
                      int l=P[i].y-P[i-1].y;
                      if(j>1) Min=min(Min,dp[i-1][j-1][0]+1+l);
                      if(i>j) Min=min(Min,dp[i-1][j][2]+2*l);
                      dp[i][j][p]=Min;
                 }
         int ans=inf;
         for(int i=0;i<3;++i)
             ans=min(dp[n][k][i],ans);
         printf(""%d/n"",ans);
    }
    return 0;
}
"
196,"POJ 3090 Visible Lattice Points_JJing_新浪博客

欧拉函数的一个应用，求出互质的点。。。
Description
A lattice point (x, y) in the first quadrant (x and y are integers greater than or equal to 0), other than the origin, is visible from the origin if the line from (0, 0) to (x, y) does not pass through any other lattice point. For example, the point (4, 2) is not visible since the line from the origin passes through (2, 1). The figure below shows the points (x, y) with 0 ≤ x, y ≤ 5 with lines from the origin to the visible points.
 
 
  3090 Visible Lattice Points"">
  
 
Write a program which, given a value for the size, N, computes the number of visible points (x, y) with 0 ≤ x, y ≤ N.
Input
The first line of input contains a single integer C (1 ≤ C ≤ 1000) which is the number of datasets that follow.
Each dataset consists of a single line of input containing a single integer N (1 ≤ N ≤ 1000), which is the size.
Output
For each dataset, there is to be one line of output consisting of: the dataset number starting at 1, a single space, the size, a single space and the number of visible points for that size.
Sample Input
4
2
4
5
231
Sample Output
1 2 5
2 4 13
3 5 21
4 231 32549
3090 Visible Lattice Points"" title=""POJ 3090 Visible Lattice Points"">
#include<stdio.h>
#define M 1005
int phi[M];
void oula(){//欧拉函数
 int i,j;
 for(i=0;i<M;++i) {
  if (i%2)phi[i]=i;
  else phi[i]=i/2;
 }
 for(i=3;i<M;i+=2) {
  if(phi[i]==i){
   for(j=i;j<M;j+=i) {
    phi[j]=phi[j]/i*(i-1);
   }
  }
 }
}
int main(){
 int cas,n,v=1;
 int i,sum;
 oula();
 scanf(""%d"",&cas);
 while(cas--){
  scanf(""%d"",&n);
  sum=0;
  for(i=0;i<=n;i++){
   sum+=phi[i];  
  }
  printf(""%d %d %d\n"",v++,n,sum*2+1);
 }
 return 0;
}
"
