4,"POJ 1655 Balancing Act - 浙西贫农 - 博客园

实际上，这个题不难，状态很好写：balace[i]=max(size[j],N-size[i])，其中i是j的父节点，size[i]表示以节点i为根节点所构成子树的节点总数。
一遍dfs就可以搞定。题目里给的数据是告诉你每两个节点之间有一条边，而不是父子节点关系。。。
 

 
 
 View Code  
  
   1 #include <iostream>
 2 #include <cstdio>
 3 #include <vector>
 4 #define MAX 0xffffff
 5 using namespace std;
 6 
 7 vector <int> G[20001];
 8 int balance[20001];
 9 bool visit[20001];
10 int n,t;
11 
12 int max(int a,int b)
13 {
14     return a > b ? a : b;
15 }
16 
17 int min(int a,int b)
18 {
19     return a < b ? a : b;
20 }
21 
22 int dfs(int v)
23 {
24     visit[v] = true;
25     int sum = 1,temp;
26     for(vector<int>::size_type i = 0;i < G[v].size();i++)
27     {
28         int u = G[v][i];
29         if(visit[u])
30             continue;
31 
32         temp = dfs(u);
33         sum += temp;
34         balance[v] = max(balance[v],temp);
35     }
36     balance[v] = max(balance[v],n - sum);
37     return sum;
38 }
39 int main()
40 {
41     scanf(""%d"",&t);
42     while(t--)
43     {
44         int i,p,q;
45         scanf(""%d"",&n);
46         for(i = 1;i <= n;i++)
47         {
48             G[i].clear();
49             balance[i] = -1;
50             visit[i] = false;
51         }
52         for(i = 1;i < n;i++)
53         {
54             scanf(""%d%d"",&p,&q);
55             G[p].push_back(q);
56             G[q].push_back(p);
57         }
58 
59         dfs(1);
60         int flag,ans = MAX;
61         for(i = 1;i <= n;i++)
62         {
63             if(balance[i] < ans)
64             {
65                 ans = balance[i];
66                 flag = i;
67             }
68         }
69         printf(""%d %d\n"",flag,ans);
70     }
71     return 0;
72 } 
  
"
6,"POJ 1063 - ACM-King伟的日志 - 网易博客

        又是一道经典题，数塔的DP思想极容易理解，是一个学DP很好的开端例子，毕竟不是每个人都可以马上理解投0-1背包。
#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;
int main()
{
 int n,a[100][100],b[100][100],t;
 scanf(""%d"",&n);
 for(int i=0;i<n;i++)
  for(int j=0;j<=i;j++)
   scanf(""%d"",&a[i][j]);
 for(int i=0;i<n;i++)
  b[n-1][i]=a[n-1][i];
 for(int i=n-2;i>=0;i--)
  for(int j=0;j<=i;j++)
   {
    b[i][j]=b[i+1][j]+a[i][j];
    t=b[i+1][j+1]+a[i][j];
    if(t>b[i][j])
     b[i][j]=t;
   }
 printf(""%d\n"",b[0][0]);
 system(""pause"");
 return 0; 
}
       代码短，记得DP自下而上，有点把平常思维倒过来的味道，逆着想就差不多可以了。例如先假设当问题的最优解得出来了，那么得出最优解的上一步也必须是最优的，一步步向上找，那个专业一点的名词叫什么来的???貌似是“最优子结构”。
"
7,"poj 1251; zoj 1406 Jungle Roads[ MST ] - 小猴子、 - 博客园

题目连接 http://poj.org/problem?id=1251
代码
 
 
 #include<stdio.h>
#include<stdlib.h>
#include<string.h>
int parent[257];
int n, m;
struct node {
	char u, v;
	int w;
};
struct node a[101];
int cmp(const void *a, const void *b)
{
	struct node c = *(struct node *)a;
	struct node d = *(struct node *)b;
	return c.w - d.w;
}
int Find(int x)
{
	int s = x;
	while( parent[s] >= 0 ) {
		s = parent[s];
	}
	while(s != x) {
		int tmp = parent[x];
		parent[x] = s;
		x = tmp;
	}
	return s;
}
int Union(int R1, int R2) 
{
	int r1 = Find(R1);
	int r2 = Find(R2);
	if(r1 == r2) return 0;
	int tmp = parent[r1] + parent[r2];
	if(parent[r1] > parent[r2]) {
		parent[r1] = r2;
		parent[r2] = tmp;
	} else {
		parent[r2] = r1;
		parent[r1] = tmp;
	}
	return 1;
}
int Kruskal()
{
	int ans = 0;
	int edge = 0;
	for(int i = 0; i < m; i++) {
		int R1 = a[i].u;
		int R2 = a[i].v;
		if(Union(R1, R2)) {
			ans += a[i].w;
			edge++;
		}
		if(edge >= n-1) break;
	}
	return ans;
}
int main()
{
	while(scanf(""%d%*c"", &n), n) {
		char c;
		int t;
		m = 0;
		for(int i = 0; i < n-1; i++) {
			scanf(""%c %d%*c"", &c, &t);
			for(int j = 0; j < t; j++) {
				char cc;
				int w;
				scanf(""%c %d%*c"", &cc, &w);
				a[m].u = c;
				a[m].v = cc;
				a[m].w =w;
				m++;
			} 
		}
		memset(parent, -1, sizeof(parent));
		qsort(a, m, sizeof(struct node), cmp);
		printf(""%d\n"", Kruskal());
	}
	return 0;
}
　　上面代码在ｚｏｊ上ＡＣ，但是在ｐｏｊ上会ＲＥ或ＴＬＥ，主要是输入的问题，把输入改成下面的代码就可以了，其实我也不知道为什么这么改。
 
 
 for(int i = 0; i < n-1; i++) {
			scanf("" %c %d"", &c, &t);
			for(int j = 0; j < t; j++) {
				char cc;
				int w;
				scanf("" %c %d"", &cc, &w);
				a[m].u = c;
				a[m].v = cc;
				a[m].w =w;
				m++;
			} 
		}
　　
"
10,"【转】pku 1191 棋盘分割 （动态规划）_沧海桑田 . 蓝色空间_百度空间

Time Limit:1000MS Memory Limit:10000K Total Submissions:3151 Accepted:1146 
Description
将一个８*８的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的部分继续如此分割，这样割了(n-1)次后，连同最后剩下的矩形棋盘共有n块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行)
原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成n块矩形棋盘，并使各矩形棋盘总分的均方差最小。
均方差，其中平均值，xi为第i块矩形棋盘的总分。
请编程对给出的棋盘及n，求出O'的最小值。
Input
第1行为一个整数n(1 < n < 15)。
第2行至第9行每行为8个小于100的非负整数，表示棋盘上相应格子的分值。每行相邻两数之间用一个空格分隔。
Output
仅一个数，为O'（四舍五入精确到小数点后三位）。
Sample Input
3 1 1 1 1 1 1 1 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 0 3
Sample Output
1.633
Source
----------------------------------------------------------------------------------------------动态规划练习题刚刚开始的时候，考虑到每个状态需要记录的信息需要开一个5维的数组（左上角左边i1,j1;右下角坐标i2,j2;当前切割到第几次），有点被吓懵了，所以这道题晾了很久，刚刚才做出来。还有个原因就是腾讯赛上，有道PAPERCUT，本质上跟棋盘分割是相同的，可提交了n次，都是WA，为了验证我的思路是正确的，所以拿这道题来检测一下，事实证明之前是出了点逻辑上的错误。除了上面的5维数组外，还需开个4维数组来保存分割后的每个子棋盘的总分的平方。均方差公式比较复杂，联立题目给的两个式子，化简之后，就可以得到题目要求的就是每块子棋盘的总分最小。对于一个棋盘，可以横着切割，也可以竖直切割。切割完，会得到两块子棋盘，如果此时还切不够n次的话，就继续递归，对两块子棋盘进行切割，找出最小的切割方式。子棋盘的最小分割导致整个棋盘的最小分割，符合最优子结构。----------------------------------------------------------------------------------------------源码如下：#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
double f[10][10][10][10][20];
double s[10][10][10][10];
double a[10][10];
double cal(int i1,int j1,int i2,int j2)
{
if(s[i1][j1][i2][j2]>=0)
return s[i1][j1][i2][j2];
int i,j;
double sum=0;
for(i=i1;i<=i2;i++)
{
for(j=j1;j<=j2;j++)
{
sum+=a[i][j]; }
}
s[i1][j1][i2][j2]=sum*sum;
return s[i1][j1][i2][j2];
}
double ge(int i1,int j1,int i2,int j2,int k)
{
if(k==1)//
return cal(i1,j1,i2,j2);
if(f[i1][j1][i2][j2][k]>=0)
return f[i1][j1][i2][j2][k];
int i,j;
double ff=0;
double mini=999999999999999;
for(i=i1;i<i2;i++)
{
ff=__min((ge(i1,j1,i,j2,k-1)+cal(i+1,j1,i2,j2)),(ge(i+1,j1,i2,j2,k-1)+cal(i1,j1,i,j2)));
if(ff<mini)
mini=ff;
}
for(j=j1;j<j2;j++)
{
ff=__min((ge(i1,j1,i2,j,k-1)+cal(i1,j+1,i2,j2)),(ge(i1,j+1,i2,j2,k-1)+cal(i1,j1,i2,j)));
if(ff<mini)
mini=ff;
}
f[i1][j1][i2][j2][k]=mini;
return f[i1][j1][i2][j2][k];}
int main()
{
//freopen(""1.txt"",""r"",stdin);
double n;
int i,j;
double x;
double min=0;
double sum=0;
scanf(""%lf"",&n);
memset(a,0,sizeof(a));
memset(f,-1,sizeof(f));
memset(s,-1,sizeof(s));
for(i=1;i<=8;i++)
{
for(j=1;j<=8;j++)
{
scanf(""%lf"",&a[i][j]);
sum+=a[i][j];
}
}
x=sum/n;
min=ge(1,1,8,8,n);
printf(""%.3lf\n"",sqrt(min/n-(x*x)));
return 0;
}
"
21,"poj 2181 - 宇宙吾心 - 博客园

题意：最大子序列，奇数项加，偶数项减。
dp解
代码：

 
 #include<iostream>
#include<fstream>
using namespace std;
int dp[150001][2][2];
int n;
int a[150001];
void read(){
//	ifstream cin(""in.txt"");
	int i,j,k;
	cin>>n;
	for(i=1;i<=n;i++)
		cin>>a[i];
	dp[1][0][0]=0;
	dp[1][0][1]=-9999999;
	dp[1][1][1]=a[1];
	dp[1][1][0]=-9999999;
	for(i=2;i<=n;i++)
	{
		dp[i][0][0]=max(dp[i-1][0][0],dp[i-1][1][0]);
		dp[i][0][1]=max(dp[i-1][0][1],dp[i-1][1][1]);
		dp[i][1][0]=max(dp[i-1][0][1],dp[i-1][1][1])-a[i];
		dp[i][1][1]=max(dp[i-1][0][0],dp[i-1][1][0])+a[i];
	}
	cout<<max(max(dp[n][0][0],dp[n][0][1]),max(dp[n][1][0],dp[n][1][1]))<<endl;
}
int main(){
	read();
	return 0;
}
"
23,"poj 1351 Number of locks - scorpiocj的专栏 - 博客频道 - CSDN.NET

dp[i][j][k][s]表示当前到第i把锁,高度为j,是否出现高度差为3（k=1表示出现过，0表示没有出现过),使用高度的种数为s的方案数
类似于按位DP的思想，记忆化求解
dfs的时候枚举第i+1位选择的高度，并和当前s状态比较，记录出现高度的种数
代码：

#include<iostream>
#include<memory.h>
#include<string>
#include<cstdio>
#include<algorithm>
#include<math.h>
#include<stack>
#include<queue>
#include<vector>
#include<map>
#include<ctime>
using namespace std;
long long dp[50][5][2][4];
int n;
long long dfs(int i,int now,int j,int s,int m)
{
	if(i>=n)
	{
		if(j&&m>=3)
			return 1;
		else	
			return 0;
	}
	if(dp[i][now][j][m]!=-1)
		return dp[i][now][j][m];
	long long ans=0;
	int tmp;
	for(int k=1;k<=4;k++)
	{
		if((s&(1<<(k-1)))==0)
			tmp=m+1;
		else
			tmp=m;
		if(tmp>3)
			tmp=3;
		ans+=dfs(i+1,k,(now!=0&&abs(k-now)==3)||j,s|(1<<(k-1)),tmp);
	}
	dp[i][now][j][m]=ans;
	return ans;
}
int main()
{
	int i,j;
	while(scanf(""%d"",&n)!=EOF)
	{
		if(n==-1)
			break;
		memset(dp,-1,sizeof(dp));
		dfs(0,0,0,0,0);
		printf(""%d: %lld\n"",n,dp[0][0][0][0]);
	}
	return 0;
}

"
24,"poj 2013 Symmetric Order - martinblack954的日志 - 网易博客

题目链接：http://poj.org/problem?id=2013
题意：有一个按长度从小到大排列的单词列表，现需要对这个列表的单词进行二次排序。排序规则是，原序列单词两个两个分成一组。然后第一组的第一个单词为新序列的整数第一个单词，第二个单词为新序列的倒数第一个单词；第二组的第一个单词为新序列的整数第二个单词，第二个单词为新序列的倒数第二个单词，以此类推。问该单词列表二次排序后的序列。
思路：模拟。按题目描述的二次排序方式，用一个循环变量直接正数倒数去进行二次赋值即可。
PS：我实现的时候，以为输入是无序的，还冒泡排序了一下。。。- -
#include ""stdio.h""
#include ""malloc.h""
#include ""string.h""
#include <algorithm>
using namespace std;
#define M 18
char *s[M];
int n;
void bub()
{
 int i,j;
 char *t;
 for(i=0;i<n;i++)
 {
  for(j=0;j<n-i-1;j++)
  {
   if(strlen(s[j])>strlen(s[j+1]))
   {
    t=s[j],s[j]=s[j+1],s[j+1]=t;
   }
  }
 }
}
int main()
{
 int i,t=1,j,m;
 char *s2[M],str[M*2];
 while(scanf(""%d"",&n)>0&&n>0)
 {
  for(i=0;i<n;i++)
  {
   free(s[i]);
   scanf(""%s"",str);
   s[i]=(char *)malloc((strlen(str)+1)*sizeof(char));
   for(j=0;j<=strlen(str);j++)
    s[i][j]=str[j];
  }
  //bub();
  for(i=0;i<n/2;i++)
  {
   s2[i]=s[i*2];
   s2[n-i-1]=s[i*2+1];
  }
  if(n%2==1)
   s2[n/2]=s[n-1];
  printf(""SET %d\n"",t);
  t++;
  for(i=0;i<n;i++)
  {
   printf(""%s\n"",s2[i]);
  }
 }
 return 0;
}
"
28,"POJ 2506 递推_石家庄二中2011级OI_百度空间

好像状压DP啊，可惜不是。。
题意：你这题看不懂就回去读小学英语去吧。。
递推：由于当前状态根i-2之前的无关，所以只需考虑i-1和i-2,。
假设i-1方案数已经算好，此时只能添加1个竖着的。
假设i-2方案数已经算好，此时能添加两个横着的和一个2*2的，为什么没有两个竖着的？因为i-1的时候已经算过竖着的了。
注意N有0的时候，要输出1，我因为这WA了两次。。
配上高精度计算。。
（代码仅供参考和学习，请不要直接粘贴刷AC数，期待你写出更好的代码）
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
int n;
struct H
{int a[100],len;}f[310];
inline H operator + (const H &x,const H &y)
{
int l=max(x.len,y.len);
H z;
memset(z.a,0,sizeof z.a);
for(int i=1;i<=l;i++)
{
z.a[i]+=x.a[i]+y.a[i];
z.a[i+1]=z.a[i]/10;
z.a[i]%=10;
}
if(z.a[l+1]) l++;
z.len=l;
return z;
}
inline H mut(H x)
{
for(int i=1;i<=x.len;i++)
x.a[i]*=2;
for(int i=1;i<=x.len;i++)
{
x.a[i+1]+=x.a[i]/10;
x.a[i]%=10;
}
if(x.a[x.len+1]) x.len++;
return x;
}
int main()
{
f[0].a[1]=1;f[0].len=1;
f[1].a[1]=1;f[1].len=1;
for(int i=2;i<=250;i++)
f[i]=f[i-1]+mut(f[i-2]);
while(scanf(""%d"",&n)+1)
{
for(int i=f[n].len;i>=1;i--)
printf(""%d"",f[n].a[i]);
printf(""\n"");
}
return 0;
}
"
33,"POJ 1491 简单模拟_石家庄二中2011级OI_百度空间

都是英语阅读理解。
题意：给出n（<=50）个数和计算公式6/pi^2=x/y，其中y为数对的个数，x为互质的数对的个数。输出pi的计算结果。如果x==0，输出No estimate for this data set.
直接模拟吧，没有可说的。。
（代码仅供参考和学习，请不要直接粘贴刷AC数，期待你写出更好的代码）
#include<cstdio>
#include<cmath>
int n,a[100];
inline int gcd(int x,int y)
{
if(!y) return x;
return gcd(y,x%y);
}
int main()
{
while(scanf(""%d"",&n),n)
{
for(int i=1;i<=n;i++)
scanf(""%d"",&a[i]);
int cnt=0;
for(int i=1;i<=n;i++)
for(int j=i+1;j<=n;j++)
if(gcd(a[i],a[j])==1)
cnt++;
if(cnt) printf(""%.6lf\n"",sqrt(6.0*n*(n-1)/2/cnt));
else printf(""No estimate for this data set.\n"");
}
return 0;
}
"
36,"poj 1827_foreverlin_百度空间

#include<iostream>
#include<queue> 
using namespace std;
const int maxn=50001;
//贪心+并查集
//题目描述：一共有x个盒子，一个盒子有一个数，一个数只能放在一个盒子里
//有n个怪兽，每个随机检起一张卡片，打开获得的数字为d[i]，不能改变且不能再打开其他盒子，d[i]范围[1,m]
//如果第i个怪兽获得数字d[i]，他只能打开编号<=d[i]的盒子，一个盒子只能给一个怪兽，一个怪兽只能由一个盒子
//jim有权利去分配，他知道第i个怪兽的能力为s[i]，问题要使得所有没有获得盒子的怪兽的s[i]之和sum最小
//首先我们按s从大到小排序，如果s相同，那么按d的值从大到小，这样做是为了尽量先把s大的安顿好，因为惹不起
//每次都采取靠后原则，俗话说的好，物尽其用，这里的数字也是一样，然后用并查集保留下当前最近的那个祖先 
bool use[maxn];
int n,m;
int a[maxn];
typedef struct node
{
    int d,s;
    node(){};
    node(int dd,int ss){d=dd;s=ss;}    
    }node;
node p[maxn];
bool cmp(node x,node y)
{
    if(x.s!=y.s)return x.s>y.s;
    return x.d>y.d; 
    }
int find(int x)
{
    if(a[x]!=x)a[x]=find(a[x]);
    return a[x];
    }        
void unit(int x,int y)
{
    x=find(x);y=find(y);
    a[x]=y; 
    }    
int main()
{
    int i,j,k,sum,x;
    while(scanf(""%d%d"",&n,&m)!=EOF)
    {
          if(n==0&&m==0)break;                         
          for(i=1;i<=n;i++)scanf(""%d"",&p[i].d);
          for(i=1;i<=n;i++)scanf(""%d"",&p[i].s);
          for(i=1;i<=m;i++)use[i]=0;
          sort(p+1,p+n+1,cmp);
          for(i=0;i<=m+1;i++)a[i]=i;
          sum=0;
          for(i=1;i<=n;i++)
          {
              x=find(p[i].d);
//              cout<<""x=""<<x<<endl;
//              cout<<""sum=""<<sum<<endl;system(""pause"");
              if(x==0)sum+=p[i].s;              
              else
              {
                 use[x]=1; 
                 if(use[x-1])unit(x,x-1);
                 else a[x]=a[x-1];          
                 }             
              }                        
          printf(""%d\n"",sum);    
          }   
    return 0;
    }
"
38,"poj 1417 状态并查集+背包dp_C_down_新浪博客

这题纠结了几天， 不解释的30+ 才A 掉，  
之前一直runtime 搞得我一直都很无语，疯狂提交找是哪里出了问题， 后来静下来后， 把程序有读了几遍终于找到了错误所在， 不是栈溢出， 也不是。。。 

 其实就是少了个符号  
 搞得数组溢出。。。
 

 

 

 好吧，辛辛苦苦敲了两百多行， 没有看别人的，其实做了 poj 1112 team them up 和 poj 1733 这题就没问题，要的是无限的耐心，和纠结再纠结...
 

 

 
 
 
  True Liars
  
  
   
    
     
     Time Limit: 1000MS 
      
     Memory Limit: 10000K 
     
     
     Total Submissions: 1428 
      
     Accepted: 402 
     
    
   
  
  Description
 
 
  After having drifted about in a small boat for a couple of days, Akira Crusoe Maeda was finally cast ashore on a foggy island. Though he was exhausted and despaired, he was still fortunate to remember a legend of the foggy island, which he had heard from patriarchs in his childhood. This must be the island in the legend. In the legend, two tribes have inhabited the island, one is divine and the other is devilish, once members of the divine tribe bless you, your future is bright and promising, and your soul will eventually go to Heaven, in contrast, once members of the devilish tribe curse you, your future is bleak and hopeless, and your soul will eventually fall down to Hell. 
  
  
 In order to prevent the worst-case scenario, Akira should distinguish the devilish from the divine. But how? They looked exactly alike and he could not distinguish one from the other solely by their appearances. He still had his last hope, however. The members of the divine tribe are truth-tellers, that is, they always tell the truth and those of the devilish tribe are liars, that is, they always tell a lie. 
  
  
 He asked some of them whether or not some are divine. They knew one another very much and always responded to him ""faithfully"" according to their individual natures (i.e., they always tell the truth or always a lie). He did not dare to ask any other forms of questions, since the legend says that a devilish member would curse a person forever when he did not like the question. He had another piece of useful informationf the legend tells the populations of both tribes. These numbers in the legend are trustworthy since everyone living on this island is immortal and none have ever been born at least these millennia. 
  
  
 You are a good computer programmer and so requested to help Akira by writing a program that classifies the inhabitants according to their answers to his inquiries. 
  
  

  
  Input
 
 
  The input consists of multiple data sets, each in the following format : 
  
  
 n p1 p2 
  
  
 xl yl a1 
  
  
 x2 y2 a2 
  
  
 ... 
  
  
 xi yi ai 
  
  
 ... 
  
  
 xn yn an 
  
  
 The first line has three non-negative integers n, p1, and p2. n is the number of questions Akira asked. pl and p2 are the populations of the divine and devilish tribes, respectively, in the legend. Each of the following n lines has two integers xi, yi and one word ai. xi and yi are the identification numbers of inhabitants, each of which is between 1 and p1 + p2, inclusive. ai is either yes, if the inhabitant xi said that the inhabitant yi was a member of the divine tribe, or no, otherwise. Note that xi and yi can be the same number since ""are you a member of the divine tribe?"" is a valid question. Note also that two lines may have the same x's and y's since Akira was very upset and might have asked the same question to the same one more than once. 
  
  
 You may assume that n is less than 1000 and that p1 and p2 are less than 300. A line with three zeros, i.e., 0 0 0, represents the end of the input. You can assume that each data set is consistent and no contradictory answers are included. 
  
  

  
  Output
 
 
  For each data set, if it includes sufficient information to classify all the inhabitants, print the identification numbers of all the divine ones in ascending order, one in a line. In addition, following the output numbers, print end in a line. Otherwise, i.e., if a given data set does not include sufficient information to identify all the divine members, print no in a line.
  
  Sample Input
2 1 1
1 2 no
2 1 no
3 2 1
1 1 yes
2 2 yes
3 3 yes
2 2 1
1 2 yes
2 3 no
5 4 3
1 2 yes
1 3 no
4 5 yes
5 6 yes
6 7 no
0 0 0
 
  Sample Output
no
no
1
2
end
3
4
5
6
end
 
  Source
 
 
  Japan 2002 Kanazawa
  
 

 

  
 
  #include<stdio.h>
  
 
  #include<string>
  
 
  #include<string.h>
  
 
  #include<iostream>
  
 
  using namespace std;
  
 
  #define N 606
  
 
  

  
 
  struct node
  
 
  {
  
 
  int to,next;
  
 
  }edge[1010];
  
 
  

  
 
  int n,p1,p2;
  
 
  int bin[N],num[N],mark[N],prt[N];
  
 
  int dp[N][N],cnt1[1010][2],pre[1010][2],path[N][N];
  
 
  int  cnt,tcnt;
  
 
  

  
 
  void init()
  
 
  {
  
 
  cnt=0; tcnt=0;
  
 
  for(int i=1;i<=p1+p2;i++)
  
 
  {
  
 
  bin[i]=i;
  
 
  }
  
 
  memset(num,0,sizeof(num));
  
 
  memset(mark,-1,sizeof(mark));
  
 
  memset(dp,0,sizeof(dp));
  
 
  memset(pre,-1,sizeof(pre));
  
 
  memset(path,0,sizeof(path));
  
 
  memset(cnt1,0,sizeof(cnt1));
  
 
  memset(prt,0,sizeof(prt));
  
 
  }
  
 
  

  
 
  int find(int x)
  
 
  {
  
 
  if(x==bin[x]) return x;
  
 
  int s;
  
 
  s=bin[x];
  
 
  bin[x]=find(s);
  
 
  num[x]=num[s]^num[x];
  
 
  return bin[x];
  
 
  }
  
 
  

  
 
  void merge(int x,int y,int v)
  
 
  {
  
 
  int a,b;
  
 
  a=find(x);
  
 
  b=find(y);
  
 
  if(a==b) return ;
  
 
  bin[a]=b;
  
 
  num[a]=num[x]^num[y]^v;
  
 
  }
  
 
  

  
 
  void add_edge (int u,int v,int flag)
  
 
  {
  
 
  edge[cnt].to=v;
  
 
  edge[cnt].next=pre[u][flag];
  
 
  pre[u][flag]=cnt++;
  
 
  }
  
 
  

  
 
  void fuc()
  
 
  {
  
 
  for(int i=1;i<=p1+p2;i++)
  
 
  bin[i]=find(i);
  
 
  }
  
 
  

  
 
  int main()
  
 
  {
  
 
  string c=""yes"",tmp;
  
 
  int x,y,v,len,ttmp;
  
 
  while(scanf(""%d%d%d"",&n,&p1,&p2)!=EOF&&(n+p1+p2))
  
 
  {
  
 
  init();
  
 
  len=p1+p2;
  
 
  for(int i=0;i<n;i++)
  
 
  {
  
 
  scanf(""%d%d"",&x,&y);
  
 
  cin>>tmp;
  
 
  if(tmp==c) v=0;
  
 
  else v=1;
  
 
  merge(x,y,v);
  
 
  }
  
 
  fuc();
  
 
  tcnt=0;
  
 
  for(int i=1;i<=len;i++)
  
 
  {
  
 
  if(mark[bin[i]]==-1)
  
 
  {
  
 
  mark[bin[i]]=tcnt;
  
 
  add_edge(tcnt,i,num[i]);
  
 
  tcnt++;
  
 
  }
  
 
  else
  
 
  {
  
 
  add_edge(mark[bin[i]],i,num[i]);
  
 
  }
  
 
  }
  
 
  for(int i=0;i<tcnt;i++)
  
 
  {
  
 
  for(int p=pre[i][0];p!=-1;p=edge[p].next) cnt1[i][0]++;
  
 
  for(int p=pre[i][1];p!=-1;p=edge[p].next) cnt1[i][1]++;
  
 
  }
  
 
  dp[0][ cnt1[0][0] ]=1;
  
 
  path[0][ cnt1[0][0] ]=0;
  
 
  if(dp[0][ cnt1[0][1] ]==1)
  
 
  {
  
 
  dp[0][cnt1[0][1]]=0;
  
 
  printf(""no\n"");
  
 
  continue;
  
 
  }
  
 
  else
  
 
  {
  
 
  dp[0][cnt1[0][1]]=1;
  
 
  path[0][cnt1[0][1]]=1;
  
 
  }
  
 
  for(int i=1;i<tcnt;i++)
  
 
  {
  
 
  for(int j=p1;j>=0;j--)
  
 
  {
  
 
  dp[i][j]=0;
  
 
  ttmp=j-cnt1[i][0];
  
 
  if(ttmp>=0&&dp[(i-1)][ttmp])
  
 
  {
  
 
  dp[i][j]=1;
  
 
  path[i][j]=0;
  
 
  }
  
 
  ttmp=j-cnt1[i][1];
  
 
  if(ttmp>=0&&dp[(i-1)][ttmp])
  
 
  {
  
 
  path[i][j]=1;
  
 
  dp[i][j]=1;
  
 
  }
  
 
  }
  
 
  }// find  now and catch them
  
 
  int ff=0;
  
 
  int ttmp=p1;
  
 
  if(dp[tcnt-1][ttmp]==0)
  
 
  {
  
 
  printf(""no\n"");
  
 
  continue;
  
 
  }
  
 
  for(int i=tcnt-1;i>0;i--)
  
 
  {
  
 
  if(dp[i-1][ttmp-cnt1[i][0]]==1&&dp[i-1][ttmp-cnt1[i][1]]==1)
  
 
  {
  
 
  ff=1;
  
 
  break;
  
 
  }
  
 
  if(dp[i-1][ttmp-cnt1[i][0]]==1)
  
 
  {
  
 
  ttmp-=cnt1[i][0];
  
 
  continue;
  
 
  }
  
 
  if(dp[i-1][ttmp-cnt1[i][1]]==1)
  
 
  {
  
 
  ttmp-=cnt1[i][1];
  
 
  continue;
  
 
  }
  
 
  ff=1; break;
  
 
  }
  
 
  if(ff==1)
  
 
  {
  
 
  printf(""no\n"");
  
 
  continue;
  
 
  }
  
 
  ttmp=p1;
  
 
  int mm=0;
  
 
  for(int i=tcnt-1;i>=0;i--)
  
 
  {
  
 
  if(path[i][ttmp]==1)
  
 
  {
  
 
  mm=1;
  
 
  ttmp-=cnt1[i][1];
  
 
  }
  
 
  else
  
 
  {
  
 
  mm=0;
  
 
  ttmp-=cnt1[i][0];
  
 
  }
  
 
  for(int p=pre[i][mm];p!=-1;p=edge[p].next)
  
 
  prt[edge[p].to]=1;
  
 
  }
  
 
  for(int i=1;i<=len;i++)
  
 
  if(prt[i]==1)
  
 
  printf(""%d\n"",i);
  
 
  printf(""end\n"");
  
 
  }
  
 
  return 0;
  
 
  }
  
 
  

"
45,"poj 4001 Xiangqi - fire__ice的专栏 - 博客频道 - CSDN.NET

题目链接：http://poj.org/problem?id=4001
题意：给出象棋的一个状态，判断是否是死棋。
模拟题。。。
开始用scanf()，WA了，改成cin就对了，输入格式不对。

#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define clr(a,b) memset(a,b,sizeof(a))
const int d[4][2] = {-1,0,1,0,0,-1,0,1};
int G[15][15],sc,sr,n;
bool judgeG(int x,int y)
{
    return (x < 4 && x > 0 && y < 7 && y > 3);
}
bool judgeH(int xH,int yH,int xG,int yG)
{
    if(xH-2 > 0 && xG == xH-2 && (yG==yH-1 || yG==yH+1)) return !G[xH-1][yH] ;
    if(xH+2 < 11 && xG == xH+2 && (yG==yH-1 || yG==yH+1)) return !G[xH+1][yH];
    if(yH-2 > 0 && yG == yH-2 && (xG==xH-1 || xG==xH+1)) return !G[xH][yH-1] ;
    if(yH+2 < 10 && yG == yH+2 && (xG==xH-1 || xG==xH+1)) return !G[xH][yH+1];
    return false;
}
bool solve()
{
    bool flag = true;
    int x,y;
    for(int i = 0;i < 4;++i)
    {
        bool flag1 = false;
        x = sc + d[i][0];
        y = sr + d[i][1];
        if(!judgeG(x,y)) continue;
        //判断车和帅
        for(int j = x+1,k = x-1;j<11 || k>0;++j,--k)
        {
            if(j < 11)
            {
                if(G[j][y])
                {
                    if(G[j][y]==1 || G[j][y] == 4)
                    flag1 = true;
                    j = 11;
                }
            }
            if(k > 0)
            {
                if(G[k][y])
                {
                    if(G[k][y]==1 || G[k][y] == 4)
                    flag1 = true;
                    k = 0;
                }
            }
        }
        for(int j = y+1,k = y-1;k>0 || j < 10;++j,--k)
        {
            if(j < 10)
            {
                if(G[x][j])
                {
                    if(G[x][j] == 1 || G[x][j] == 4)
                    flag1 = true;
                    j = 10;
                }
            }
            if(k > 0)
            {
                if(G[x][k])
                {
                    if(G[x][k] == 1 || G[x][k] == 4)
                    flag1 = true;
                    k = 0;
                }
            }
        }
        if(flag1) continue;
        //判断马
        for(int j = 1;j < 11;++j)
        for(int k = 1;k < 10;++k)
        {
            if(G[j][k] == 2 && judgeH(j,k,x,y))
            flag1 = true;
        }
        if(flag1) continue;
        //判断炮
        int cnt = 0;
        for(int j = x-1;j > 0;--j)
        {
            if(G[j][y] == 3 && cnt == 1) flag1 = true;
            if(G[j][y]) cnt++;
        }
        cnt = 0;
        for(int j = x+1;j < 11;++j)
        {
            if(G[j][y] == 3 && cnt == 1) flag1 = true;
            if(G[j][y]) cnt++;
        }
        cnt = 0;
        for(int j = y-1;j > 0;--j)
        {
            if(G[x][j] == 3 && cnt == 1) flag1 = true;
            if(G[x][j]) cnt++;
        }
        cnt = 0;
        for(int j = y+1;j < 10;++j)
        {
            if(G[x][j] == 3 && cnt == 1) flag1 = true;
            if(G[x][j]) cnt++;
        }
        if(flag1) continue;
        flag = false;
        break;
    }
    return flag;
}
int main()
{
   // freopen(""1.txt"",""r"",stdin);
    while(cin>>n>>sc>>sr && n+sc+sr)
    {
        clr(G,0);
        char ch;
        int x,y;
        for(int i = 0;i < n;++i)
        {
            cin>>ch>>x>>y;
            if(ch == 'R') G[x][y] = 1;
            if(ch == 'H') G[x][y] = 2;
            if(ch == 'C') G[x][y] = 3;
            if(ch == 'G') G[x][y] = 4;
        }
        printf(solve()?""YES\n"":""NO\n"");
    }
    return 0;
}

"
46,"pku 1166 The Clocks - skywalker_sun的专栏 - 博客频道 - CSDN.NET

在最优解中，每种转法最多只能转3次，因为当一种转法转到第4次时针就恢复了原来的样子，相当于没转；时针最多只有4^9个状态，之前是用bfs做的，但是这样要开很大的空间记录路径，后来看了网上牛人们的分析，其实完全可以暴力枚举来做的；
ps：请未满18岁的同学在父母的指导下观看此代码（哈哈，代码很暴力）
#include <cstdio>
#include <string>
#include <vector>
using namespace std;
void add(int &t, int bit, int val)
{
	int loc = 1;
	bit = 9-bit;
	for (int i = 0; i < bit; ++i)
		loc *= 10;
	t += loc * val;
	if (t/loc%10 > 3)
	{
		t -= loc*4;
	}
}
// 用opstr[]保存操作字符串 
string opstr[] = {"""", ""ABDE"", ""ABC"", ""BCEF"", ""ADG"" , ""BDEFH"", ""CFI"", ""DEGH"", ""GHI"", ""EFHI""};
int adj(int t, const string &str) // 返回t进过操作opstr[i]的结果 
{
	for (size_t i = 0; i < str.size(); ++i)
	{
		add(t, str[i] - 'A' + 1, 1);
	}
	return t;
}
void push(vector<int> &v, int val, int times)
{
	for (int i = 0; i < times; ++i)
	{
		v.push_back(val);
	}
}
vector<int> vec;
void violence(int org)
{
	int least = 0x7FFFFFFF;
	for (int a = 0; a < 4; ++a)	{
		for (int b = 0; b < 4; ++b)	{
			for (int c = 0; c < 4; ++c)	{
				for (int d = 0; d < 4; ++d)	{
					for(int e = 0; e < 4; ++e) {
						for (int f = 0; f < 4; ++f) {
							for (int g = 0; g < 4; ++g) {
								for (int h = 0; h < 4; ++h) {
									for (int i = 0; i < 4; ++i) {
										if (org==000000000)
										{
											int sum = a+b+c+d+e+f+g+h+i;
											if (sum < least)
											{
												least = sum;
												vec.clear();
												push(vec, 1, a);
												push(vec, 2, b);
												push(vec, 3, c);
												push(vec, 4, d);
												push(vec, 5, e);
												push(vec, 6, f);
												push(vec, 7, g);
												push(vec, 8, h);
												push(vec, 9, i);
												// 因为push的顺序是从高位到低位的，所以这样得到的刚好是最先的顺序 
											}
										}
										org = adj(org, opstr[9]);
									}
									org = adj(org, opstr[8]);
								}
								org = adj(org, opstr[7]);
							}
							org = adj(org, opstr[6]);
						}
						org = adj(org, opstr[5]);
					}
					org = adj(org, opstr[4]);
				}
				org = adj(org, opstr[3]);
			}
			org = adj(org, opstr[2]);
		}
		org = adj(org, opstr[1]);
	}
}
int main()
{
	int temp;
	int org = 0;
	for (int i = 1; i <= 9; ++i)
	{
		scanf(""%d"", &temp);
		add(org, i, temp);
        // 之前是用bfs作的，所以被迫把状态压缩到一个int里面保存，这里不用这样，但是懒得改了 
	}
	violence(org);
	bool first = false;
	for (size_t i = 0; i < vec.size(); ++i)
	{
		if(first) printf("" "");
		first = 1;
		printf(""%d"", vec[i]);
	}
	printf(""/n"");
	system(""pause"");
	return 0;
}
哈哈！9层循环，暴爽！
"
47,"poj 2440 DNA_chenwenwen0210_百度空间

题目大意：要求01串的种数，01里面不能出现101，111这两种子串。输入长度N（1<=N<=10^8）,要求输出满足要求的串的数目。
解题报告：一看到这种数据范围就想到了DP加矩阵优化。
n<3的时候输出2^n
当n>2的时候
可以先用DP表示dp[i][j]代表长度为i最后两位的01，状态是j的种数目。
0<=j<4
然后由当前的j后面加上一个0或者1，可以推出i+1的对应种数
状态之间的转移图如下：
当长度为2的时候有初始状态
00，01，10，11
可以构造一个矩阵满足上图的递推式。
矩阵A如下：
矩阵B=
A*B就推出了dp[i+1][j]的状态。

#include<stdio.h>
#include<algorithm>
#include<stdlib.h>
using namespace std;
const int MAX=4;
const int MOD=2005;
void multi(int a[MAX][MAX],int b[MAX][MAX],int n,int m)
{
    int c[MAX][MAX]={0};
    int i,j,k;
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            for(k=0;k<n;k++)
            {
                c[i][j]+=a[i][k]*b[k][j];
            }
            c[i][j]%=m;
        }
    }
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            a[i][j]=c[i][j];
        }
    }
}
int main()
{
    int n;
    while(scanf(""%d"",&n)!=EOF)
    {
        if(n<3)
        {
            printf(""%d\n"",1<<n);
            continue;
        }
        n-=2;
        int ret[MAX][MAX]={
            {1,0,0,0},
            {0,1,0,0},
            {0,0,1,0},
            {0,0,0,1}
        };
        int tmp[MAX][MAX]={
            {1,0,1,0},
            {1,0,0,0},
            {0,1,0,1},
            {0,1,0,0}
        };
        while(n)
        {
            if(n&1)multi(ret,tmp,MAX,MOD);
            multi(tmp,tmp,MAX,MOD);
            n>>=1;
        }
        int ans=0;
        int i,j;
        for(i=0;i<MAX;i++)
        {
            for(j=0;j<MAX;j++)
            {
                ans+=ret[i][j];
            }
        }
        printf(""%d\n"",ans%MOD);
    }
    return 0;
}
/*
638 5 851
*/

"
53,"POJ 1002 487-3279 - ZZB的日志 - 网易博客

 
  
   
   Time Limit: 2000MS 
    
   Memory Limit: 65536K
   
   
   Total Submissions: 151338 
    
   Accepted: 25810
  
 


 
Description
Businesses like to have memorable telephone numbers. One way to make a telephone number memorable is to have it spell a memorable word or phrase. For example, you can call the University of Waterloo by dialing the memorable TUT-GLOP. Sometimes only part of the number is used to spell a word. When you get back to your hotel tonight you can order a pizza from Gino's by dialing 310-GINO. Another way to make a telephone number memorable is to group the digits in a memorable way. You could order your pizza from Pizza Hut by calling their ``three tens'' number 3-10-10-10. 

The standard form of a telephone number is seven decimal digits with a hyphen between the third and fourth digits (e.g. 888-1200). The keypad of a phone supplies the mapping of letters to numbers, as follows: 

A, B, and C map to 2 

D, E, and F map to 3 

G, H, and I map to 4 

J, K, and L map to 5 

M, N, and O map to 6 

P, R, and S map to 7 

T, U, and V map to 8 

W, X, and Y map to 9 

There is no mapping for Q or Z. Hyphens are not dialed, and can be added and removed as necessary. The standard form of TUT-GLOP is 888-4567, the standard form of 310-GINO is 310-4466, and the standard form of 3-10-10-10 is 310-1010. 

Two telephone numbers are equivalent if they have the same standard form. (They dial the same number.) 

Your company is compiling a directory of telephone numbers from local businesses. As part of the quality control process you want to check that no two (or more) businesses in the directory have the same telephone number. 

 
Input
The input will consist of one case. The first line of the input specifies the number of telephone numbers in the directory (up to 100,000) as a positive integer alone on the line. The remaining lines list the telephone numbers in the directory, with each number alone on a line. Each telephone number consists of a string composed of decimal digits, uppercase letters (excluding Q and Z) and hyphens. Exactly seven of the characters in the string will be digits or letters. 

 
Output
Generate a line of output for each telephone number that appears more than once in any form. The line should give the telephone number in standard form, followed by a space, followed by the number of times the telephone number appears in the directory. Arrange the output lines by telephone number in ascending lexicographical order. If there are no duplicates in the input print the line: 

No duplicates. 

 
Sample Input

12  4873279  ITS-EASY  888-4567  3-10-10-10  888-GLOP  TUT-GLOP  967-11-11  310-GINO  F101010  888-1200  -4-8-7-3-2-7-9-  487-3279   
Sample Output

310-1010 2  487-3279 4  888-4567 3 
Source
East Central North America 1999
//字符串处理
//题意：主要是输入若干字符串，转化为XXX-XXXX这样的标准格式，然后查看那些是相同的，并按字典序输出这些串及重复个数
//程序如下：

#include<iostream>  #include<algorithm>  #include<string>  #include<set>  #include<map>  using namespace std;      int main()  {          set<string>s1,s2;          set<string>::iterator it;   map<string,int>m;   string s;   char str[20],ch[20];   int n,i,j,k;          scanf(""%d"",&n);   getchar();   for(i=0;i<n;i++)   {      gets(ch);            for(j=0,k=0;ch[j]!='\0';j++)      {         switch(ch[j])      {      case'-':case'Z':case'Q':break;      case'A':case'B':case'C':str[k++]='2';break;      case'D':case'E':case'F':str[k++]='3';break;      case'G':case'H':case'I':str[k++]='4';break;      case'J':case'K':case'L':str[k++]='5';break;      case'M':case'N':case'O':str[k++]='6';break;      case'P':case'R':case'S':str[k++]='7';break;      case'T':case'U':case'V':str[k++]='8';break;      case'W':case'X':case'Y':str[k++]='9';break;      default:str[k++]=ch[j];break;      }      if(k==3) str[k++]='-';      }      str[k]='\0';      s=str;      it=s1.find(s);      if(it!=s1.end())      {         m[s]++;      s2.insert(s);      }      else      s1.insert(s);   }   if(!s2.empty())   {      for(it=s2.begin();it!=s2.end();it++)             cout<<*it<<' '<<m[*it]+1<<endl;   }   else      cout<<""No duplicates.""<<endl;   s1.clear();   s2.clear();   m.clear();   return 0;  }"
55,"POJ 1013 - XtestW的日志 - 网易博客

       1013 一开始的算法是even时每个赋值为0，即必为真币，不是“even”的时候，重的赋值1，轻的赋值为-1（初始化所有为-2）

最后扫描一遍，-1,1中必有一个只出现一次的，那个就是假币，后来WA。。。。。。

       改了算法，初始化为0，even赋值为1000，必为真币，不是even的重的加1，轻的减1，然后最后扫描一遍，不是1000的中得绝对值最大的那个是假币，正的重，负的轻，AC鸟~

#include <stdio.h>

#include <string.h>

#include <math.h>

int main()

{

    int  a[12];

    char str1[10];

    char str2[10];

    char str3[5];

    char *str="""";//must 

    char s[100];

    int tt,mm;

   int n,i,j,k,min,flag;

   scanf(""%d"",&n);

   for (i=0;i<n;i++)

   {

       for (j=0;j<12;j++)

       {

           a[j]=0;

       }

       for (j=0;j<3;j++)

       {

           scanf(""%s %s %s"",str1,str2,str3);

         if (!strcmp(str3,""even""))

         {

             for (k=0;k<strlen(str1);k++) 

                 a[str1[k]-'A']=1000;

             for (k=0;k<strlen(str2);k++) 

                 a[str2[k]-'A']=1000;

         }

         if (!strcmp(str3,""up""))

         {

             for (k=0;k<strlen(str1);k++) 

                 if (a[str1[k]-'A']!=1000) 

                     a[str1[k]-'A']++;

             for (k=0;k<strlen(str2);k++) 

                 if (a[str2[k]-'A']!=1000) 

                     a[str2[k]-'A']-- ;

         }

         if (!strcmp(str3,""down""))

         {

             for (k=0;k<strlen(str1);k++) 

                 if (a[str1[k]-'A']!=1000) 

                     a[str1[k]-'A']--;

             for (k=0;k<strlen(str2);k++) 

                 if (a[str2[k]-'A']!=1000) 

                     a[str2[k]-'A']++ ;

         }

       }

       k=0;

       for (j=0;j<12;j++)

       {

           if (a[j]==1000) continue;

           if (k<abs(a[j])) {

               k=abs(a[j]);

               flag=j;

           }

       }

       if (a[flag]>0) 

           str=""heavy"";

           else

           str=""light"";

       printf(""%c is the counterfeit coin and it is %s.\n"",flag+'A',str);

   }

    return 0;

}"
59,"POJ 1091 跳蚤 - bobten2008的专栏 - 博客频道 - CSDN.NET

 

 跳蚤
 
 
  
   
    
    Time Limit: 1000MS 
      
    Memory Limit: 10000K 
    
    
    Total Submissions: 3977 
      
    Accepted: 1002 
    
   
  
 
Description
 

 Z城市居住着很多只跳蚤。在Z城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有N+1个自然数。其中最后一个是M，而前N个数都不超过M，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数S，然后向左，或向右跳S个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。 
 
比如当N=2，M=18时，持有卡片(10, 15, 18)的跳蚤，就可以完成任务：他可以先向左跳10个单位长度，然后再连向左跳3次，每次15个单位长度，最后再向右连跳3次，每次18个单位长度。而持有卡片(12, 15, 18)的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。 
 
当确定N和M后，显然一共有M^N张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。 
 
Input
 

 两个整数N和M(N <= 15 , M <= 100000000)。
 
Output
 

 可以完成任务的卡片数。
 
Sample Input
 
2 4 
Sample Output
 
12 
Hint
 

 这12张卡片分别是： 
 
(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4), 
 
(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4) 
 
Source
 

 HNOI 2001
 

/*
http://acm.pku.edu.cn/JudgeOnline/problem?id=1091
这题考虑到了数论和组合数学的相关知识，题目大意是给定给定两个整数n和m, 求出长度为n+1的满足条件的数列data的个数，数列要求如下：
1)1 <= data[i] <= m, for 1<=i<=n
2)data[n+1] = m;
3)这个n+1个数满足: 存在整数 x1, x2, ..., xn, xn + 1, 满足 x1 * data[1] + x2 * data[2] + ... + xn+1 * data[n + 1] = 1;
根据数论的知识，n个数的最大公约数规定为这n个数线性和的最小自然数，所以此题就是要求最大公约数为1的数列的个数
由于data[n + 1] = m, 是已知的，所以这题可以用组合数学鸽巢原理的知识来解，步骤如下：
1）求出m的所有质约数，假设有k个如果这n + 1个数的最大公约数不是1，m至少含有一个质约数，这个质约数也是前n个数的约数
2）序列的总个数为 m ^ n;
3）设t(n)表示 能够整除 任意n个m的质约数且<=m的数的个数
利用容斥原理可知公约数不为1的数列的个数为 f = t(1) - t(2) + t(3) - ... + (-1) ^ (k - 1) t(k)
4) 符合要求的序列个数为 m ^ n - f
代码如下:
*/
#include <iostream>
#define MAX_T 120000
using namespace std;
__int64 mCDSeq[MAX_T + 1];
__int64 curCDSeq[MAX_T + 1];
__int64 curRes, totalCDNum;
__int64 n, m;
__int64 myPow(__int64 x, __int64 y)
{
    __int64 res = 1;
    for(__int64 i = 1; i <= y; i++)
        res *= x;
    return res;
}
void getCurVal(__int64 curPos, __int64 curNum, __int64 totalNum)
{
    __int64 i;
    if(curNum == totalNum)
    {
        __int64 tempVal = m;
        for(i = 0; i < totalNum; i++)
            tempVal /= curCDSeq[i];
        curRes += myPow(tempVal, n);
    }
    else
    {
        for(i = curPos; i < totalCDNum; i++)
        {
            curCDSeq[curNum] = mCDSeq[i];
            getCurVal(i + 1, curNum + 1, totalNum);
        }
    }
}
//寻找质约数
void getDivisor()
{
    __int64 i;
    __int64 tempM = m;
    totalCDNum = 0;
    for(i = 2; i * i <= tempM; i++)
    {
        if(tempM % i == 0)
        {
            while(tempM % i == 0)
                tempM /= i;
            mCDSeq[totalCDNum++] = i;
        }
    }
    if(tempM != 1)
        mCDSeq[totalCDNum++] = tempM;
    __int64 res = myPow(m, n);
    for(i = 0; i < totalCDNum; i++)
    {
        curRes = 0;
        getCurVal(0, 0, i + 1);
        if(i % 2 == 0)
            res -= curRes;
        else
            res += curRes;
    }
    printf(""%I64d/n"", res);
    //cout<<res<<endl;
}
int main()
{
    scanf(""%I64d%I64d"", &n, &m);
    getDivisor();
    return 0;
} 
"
64,"poj 3244 Difference between Triplets - celia01 - 博客园

3244 一个数学题
Difference between Triplets
 
For every pair of triplets, Ta = (Ia, Ja, Ka) and Tb= (Ib, Jb, Kb), we define the difference value between Ta and Tbas follows:
 
D(Ta, Tb) = max {Ia − Ib, Ja − Jb, Ka − Kb} − min {Ia − Ib, Ja − Jb, Ka − Kb}
 
Now you are given N triplets, could you write a program to calculate the sum of the difference values between every unordered pair of triplets?
给出N个三元组，将给出的三元组两两组合，分别求出D(Ta, Tb)的值。
若任意两个三元组为Ta = (Ia, Ja, Ka) and Tb= (Ib, Jb, Kb),
 
则：D(Ta, Tb) = max {Ia − Ib, Ja − Jb, Ka − Kb} − min {Ia − Ib, Ja − Jb, Ka − Kb}
最后求所有D(Ta, Tb)和的值
这道题有个很关键的公式，知道的就很容易做出来了
//公式max(a,b,c)-min(a,b,c)=(|a-b|+|b-c|+|a-c|)/2.
把a、b、c想成是数轴上的三个点就很容易得出上述公式了。
然而求出所有的|a-b|+|b-c|+|a-c|，再求和也不是简单的问题，所以进而继续化简得：
max {Ia − Ib, Ja − Jb, Ka − Kb} − min {Ia − Ib, Ja − Jb, Ka − Kb}
=(|(Ia − Ib)—( Ja – Jb)|+|(Ja – Jb)—(Ka − Kb)|+|( Ka − Kb)-( Ia − Ib)|)/2
= (|(Ia – Ja)—(Ib—Jb)|+|(Ja − Ka)—(Jb − Kb)|+| (Ka – Ia)—( Ka − Ib)|)/2
 
如果令a=( Ii – Ji),b=( Ji – Ki),c=( Ki – Ii),原问题等价为(|ai-aj|+|bi-bj|+|ci-cj|)/2，对于每个含a、b、c的绝对值式子可以分开求：
例如，根据ai，aj的大小即可知道在最后的求和式中贡献了多少次加法和减法。
将x数组排序，对于第xi个，他前面的比它小，所以在和i点比较时i点贡献了i次加，对后面的n-i个点向他们贡献了n-i次减法
 
 
  1 #include<iostream>
 2 #include<cstdio>
 3 #include<cstring>
 4 #include<cmath>
 5 #include<algorithm>
 6 #define see(x) cout<<#x<<"":""<<x<<endl;
 7 #define N 200010
 8 using namespace std;
 9 long long x[N], y[N], z[N];
10 
11 int main(){ 
12     int i, j, k, l, n, m;
13     long long a, b, c, sum;
14     while(~scanf(""%d"",&n)&&n){
15 
16         sum = 0;
17         for(i=0;i<n;i++){
18             scanf(""%lld%lld%lld"",&a,&b,&c);
19             x[i]=a-b;y[i]=b-c;z[i]=a-c;
20         }
21         sort(x,x+n); sort(y,y+n); sort(z,z+n);
22         for(i=0;i<n;i++){
23             sum += ((i-(n-1-i))*(x[i]+y[i]+z[i]));
24         }
25         cout<<sum/2<<endl;
26     }
27     return 0;
28 }  
 

 
"
78,"POJ 3286 How many 0's? / 2282 The Counting Problem 排列组合统计数字 -  - 博客频道 - CSDN.NET

比如算4123中有多少个2
按位统计,,,先算各位,,个位是2的情况有413种,,,因为各位左边可以0~412,,,而右边没有数字,,,
然后是十位,,,十位是2的有41*10 + 1*4种,,当左边从0~40时,,,右边可以从0~9,,,而左边为41时,,右边只能从0~3
然后是百位,,,,百位有4*100种,,,,即左边从0~3,,右边从0~99
千位有  1*1000,,,左边没有数字,,,右边0~999,,,,
上面是计算1~9,,,,计算0的时候比较特殊,,,,原因是除了0这一个数字之外,,,,0不能做开头,,,
可以看到在求1~9的个数的时候,,,都是分为2部分相乘,,,这样0的处理也很简单,,只需把相乘的左半部分-1,,,,
POJ 3286 题意：输入m,n，求[m,n]之间的所有数中0出现的次数。
 
#include<cstdio>
#include<algorithm>
using namespace std;
#define lint __int64
lint b[12] = { 1, 10, 100, 1000, 10000, 100000, 1000000,
10000000, 100000000, 1000000000, 10000000000, 100000000000 };
lint count ( lint n )
{
    lint left, m, sum = 0;
    for ( int i = 1; i < 12; i++ )
    {
        left = n / b[i] - 1;
        sum += left * b[i-1];
        m = (n % b[i] - n % b[i-1]) / b[i-1]; //求出从第到高的第i位上的具体数字
        if ( m > 0 ) sum += b[i-1];
        else if ( m == 0 ) sum += n % b[i-1] + 1;
        if ( n < b[i] ) break;
    }
    return sum;
}
int main()
{
    lint m, n;
    while ( scanf(""%I64d%I64d"",&m,&n) && (n>=0) )
        printf(""%I64d\n"",count(n)-count(m-1));
    return 0;
}
POJ 2282 题意：输入m,n，求[m,n]之间的所有数中0,1,2,3,4,5,6,7,8,9出现的次数。
 
#include<cstdio>
#include<algorithm>
using namespace std;
#define lint __int64
int b[9] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000 };
lint count ( int n, int id )
{
    lint left, m, sum = 0;
    for ( int i = 1; i < 9; i++ )
    {
        left = n / b[i] - (id==0);
        sum += left * b[i-1];
        m = (n % b[i] - n % b[i-1]) / b[i-1]; //求出从第到高的第i位上的具体数字
        if ( m > id ) sum += b[i-1];
        else if ( m == id ) sum += n % b[i-1] + 1;
        if ( n < b[i] ) break;
    }
    return sum;
}
int main()
{
    int x, y;
    while ( scanf(""%d%d"",&x,&y) && (x||y) )
    {
        if ( x > y ) swap(x,y);
        for ( int i = 0; i <= 9; i++ )
            printf(""%I64d "",count(y,i)-count(x-1,i));
        printf(""\n"");
    }
    return 0;
}
"
79,"Floyd,,,,poj 2241_我爱橙子_百度空间

#include <iostream>
using namespace std;
const int N=200;
int mat[N][N],n;
struct node
{
    int x,y,w;
}a[N];
int main()
{
    int kk=1;
    while(scanf(""%d"",&n),n)
    {
        int i,j,k,x,y,z,id=0;
        for(i=1;i<=n;i++)
        {
            scanf(""%d%d%d"",&x,&y,&z);
            a[++id].x=x,a[id].y=y,a[id].w=z;
            a[++id].x=x,a[id].y=z,a[id].w=y;
            a[++id].x=y,a[id].y=x,a[id].w=z;
            a[++id].x=y,a[id].y=z,a[id].w=x;
            a[++id].x=z,a[id].y=x,a[id].w=y;
            a[++id].x=z,a[id].y=y,a[id].w=x;
        }
        for(i=1;i<=id;i++)
            for(j=1;j<=id;j++)
                mat[i][j]=-(1<<29);
        for(i=1;i<=id;i++)
            for(j=1;j<=id;j++)
                if(a[i].x>a[j].x&&a[i].y>a[j].y)
                    mat[i][j]=a[i].w;
        for(k=1;k<=id;k++)
            for(i=1;i<=id;i++)
                for(j=1;j<=id;j++)
                    if(mat[i][j]<mat[i][k]+mat[k][j])
                        mat[i][j]=mat[i][k]+mat[k][j];
        int ans=0;
        for(i=1;i<=id;i++)
            for(j=1;j<=id;j++)
                if(ans<mat[i][j]+a[j].w)
                    ans=mat[i][j]+a[j].w;
        printf(""Case %d: maximum height = %d\n"",kk++,ans);
    }
    return 0;
}
"
80,"【POJ 3204】【Ikki's Story I - Road Reconstruction】【求关键边】_AekdyCoin的空间_百度空间

【题目地址】


http://acm.pku.edu.cn/JudgeOnline/problem?id=3204

【题目大意】

求关键边，关键边定义为 :通过增加某个边的容量使得网络的最大流增加

如下图

【My Solution】

定义 F(a -> b) 表示 a -> b的路中流流量的最小值

那么如果(x,y) 为符合条件的边，则必须满足上图

于是我们从S,T分别开始 DFS标记，之后枚举边即可

PS:

(1) 
S开始DFS,能流就流

(2) T开始的话，
也只能流就流 (具体参见代码)

(3) 考虑的边的流量大于0才继续

【程序代码】

#include<iostream>

#include<stdio.h>

#include<string.h>

using namespace std;

const int maxn = 505;

const int maxm = 20005;

const int inf = 0x3f3f3f3f;

int l,head[maxn],d[maxn],now[maxn],vh[maxn],pre[maxn],preh[maxn];

struct Edge{int v,f,p;}e[maxm];

void init(){

 l = 1;

 memset(head, 0, sizeof head);

 memset(d, 0, sizeof d) ;

} 

void add(int a,int b,int c){

 Edge &A = e[++l];A.v=b;A.f=c;A.p=head[a];head[a]=l;

 Edge &B = e[++l];B.v=a;B.f=0;B.p=head[b];head[b]=l;

}

int sap(int n,int s,int t){

 int i,x,y,k,ans = 0, f;

 for(i = 0; i < n; ++ i) now[i] = head[i];

 vh[0] = n; x = s;

 while(d[s] < n){

 if(x == t){

 for( f = inf, i = t; i ^ s; i = pre[i]) f = min(f, e[preh[i]].f) ; ans += f;

 do{e[preh[x]].f -= f; e[preh[x] ^ 1].f += f; x = pre[x];} while(x ^ s);

 }

 for(i = now[x]; i; i =e[i].p) if(e[i].f > 0 && d[y = e[i].v] + 1 == d[x]){now[x] = i; break;}

 if(i) pre[y] = x, preh[y] = i, x = y; 

 else{

 if(!--vh[d[x]]) break; k = n;

 for(i = now[x] = head[x];i;i=e[i].p) if(e[i].f > 0 && k > d[e[i].v]) now[x] = i, k = d[e[i].v];

 ++vh[d[x] = k + 1]; if(x ^ s) x = pre[x];

 }

 }

 return ans; 

}

int n,m;

int s, t; 

int col[maxn];

bool get(){

 if(EOF == scanf(""%d%d"",&n,&m)) return 0;

 init();

 s = 0;

 t = n - 1;

 while(m --){

 int a,b , c;

 scanf(""%d%d%d"",&a,&b,&c);

 add(a, b, c) ;

 }

 return 1;

}

void dfs(int x){ 

 col[x] = 1;

 int i;

 for(i = head[x]; i; i = e[i].p){

 if(e[i].f > 0 && !col[e[i].v]) dfs(e[i].v) ;

 }

}

void dfs0(int x){

 col[x] = 2;

 int i;

 for(i = head[x]; i; i = e[i].p){

 if(e[i ^ 1].f > 0 && e[i].f > 0 && !col[e[i].v])

 dfs0(e[i].v) ;

 } 

}

void work(){

 memset(col,0, sizeof col);

 sap(n, s, t);

 dfs(s) ;

 dfs0(t) ;

 int ans = 0;

 int i,j;

 for(i = 0; i < n; ++ i)

 for(j = head[i]; j; j = e[j].p){

 if(j % 2 == 1) continue ; //只考虑正向

 if(col[i] == 1 && col[e[j].v] == 2 )

 ++ ans; 

 }

 printf(""%d\n"",ans);

}

int main(){

 while(get()) work() ;

 return 0;

}"
82,"POJ 1129 Channel Allocation - c++语言程序开发技术文章_c++编程 - 红黑联盟

Channel Allocation 

 Time Limit: 1000MS
   
  Memory Limit: 10000K
 

 Total Submissions: 10300
   
  Accepted: 5245
 

 Description
 

  
 

 When a radio station is broadcasting over a very large area, repeaters are used to retransmit the signal so that every receiver has a strong signal. However, the channels used by each repeater must be carefully chosen so that nearby repeaters do not interfere with one another. This condition is satisfied if adjacent repeaters use different channels. 
 

  
 

 Since the radio frequency spectrum is a precious resource, the number of channels required by a given network of repeaters should be minimised. You have to write a program that reads in a description of a repeater network and determines the minimum number of channels required.
 

 Input
 

  
 

 The input consists of a number of maps of repeater networks. Each map begins with a line containing the number of repeaters. This is between 1 and 26, and the repeaters are referred to by consecutive upper-case letters of the alphabet starting with A. For example, ten repeaters would have the names A,B,C,...,I and J. A network with zero repeaters indicates the end of input. 
 

  
 

 Following the number of repeaters is a list of adjacency relationships. Each line has the form: 
 

  
 

 A:BCDH 
 

  
 

 which indicates that the repeaters B, C, D and H are adjacent to the repeater A. The first line describes those adjacent to repeater A, the second those adjacent to B, and so on for all of the repeaters. If a repeater is not adjacent to any other, its line has the form 
 

  
 

 A: 
 

  
 

 The repeaters are listed in alphabetical order. 
 

  
 

 Note that the adjacency is a symmetric relationship; if A is adjacent to B, then B is necessarily adjacent to A. Also, since the repeaters lie in a plane, the graph formed by connecting adjacent repeaters does not have any line segments that cross. 
 

 Output
 

  
 

 For each map (except the final one with no repeaters), print a line containing the minumum number of channels needed so that no adjacent channels interfere. The sample output shows the format of this line. Take care that channels is in the singular form when only one channel is required.
 

 Sample Input
 

  
 

 2
 

 A:
 

 B:
 

 4
 

 A:BC
 

 B:ACD
 

 C:ABD
 

 D:BC
 

 4
 

 A:BCD
 

 B:ACD
 

 C:ABD
 

 D:ABC
 

 0
 

 Sample Output
 

  
 

 1 channel needed.
 

 3 channels needed.
 

 4 channels needed. 
 

 Source
 

  
 

 Southern African 2001
 

 其实这道题目并不难 dfs暴搜一下就可以了，但是确实很容易错 ，请注意最后输出的单复数的变化，结果是1的时候是不加s的。或者复数的时候应该加s 很容易忽视掉
 

 [cpp]  
 

 #include <stdio.h>  
 

 #include <string.h>  
 

 char s1[1000];  
 

 int a[30][30];  
 

 int b[30][30],chan[30];  
 

 int n,res,key;  
 

 int main()  
 

 {  
 

     void dfs(int x);  
 

     int i,j,m,s,t;  
 

     int x,y,l;  
 

     while(scanf(""%d"",&n)!=EOF)  
 

     {  
 

         if(n==0)  
 

         {  
 

             break;  
 

         }  
 

         memset(a,0,sizeof(a));  
 

         memset(b,0,sizeof(b));  
 

         memset(chan,0,sizeof(chan));  
 

         for(i=0;i<=n-1;i++)  
 

         {  
 

             scanf(""%s"",s1);  
 

             l=strlen(s1);  
 

             x=s1[0]-'A'+1;  
 

             for(j=2;j<=l-1;j++)  
 

             {  
 

                 y=s1[j]-'A'+1;  
 

                 a[x][y]=1;  
 

                 a[y][x]=1;  
 

             }  
 

         }  
 

         res=0; key=0;  
 

         dfs(1);  
 

         if(res==1)  
 

         {  
 

             printf(""%d channel needed.\n"",res);  
 

         }else  
 

         {  
 

             printf(""%d channels needed.\n"",res);  
 

         }  
 

     }  
 

     return 0;  
 

 }  
 

 void dfs(int x)  
 

 {  
 

     int i,j,u,v;  
 

     if(key)  
 

     {  
 

         return ;  
 

     }  
 

     for(i=1;i<=n;i++)  
 

     {  
 

         for(j=1;j<=n;j++)  
 

         {  
 

             if(a[x][j]&&b[j][i])  
 

             {  
 

                 break;  
 

             }  
 

         }  
 

         if(j==n+1)  
 

         {  
 

             b[x][i]=1;  
 

             chan[i]=1;  
 

             if(x==n)  
 

             {  
 

                 for(u=1;u<=n;u++)  
 

                 {  
 

                     if(chan[u])  
 

                     {  
 

                         res++;  
 

                     }  
 

                 }  www.2cto.com
 

                 key=1;  
 

                 return ;  
 

             }else  
 

             {  
 

                 dfs(x+1);  
 

             }  
 

             b[x][i]=0;  
 

             chan[i]=0;  
 

         }  
 

     }  
 

 }  
 

  
"
83,"POJ 2976 - tmeteorj - 博客园

算是一道裸的0-1分数规划，0-1规划正确性的证明请参考OI论文《最小割模型在信息学竞赛中的应用》，里面非常详细。
总之，就是枚举比例，求a-bx的最大值，由于最多可以删去k个物品，实际就是保留n-k个，然后就在n个物品中选出最大的n-k个物品，然后再看剩下的物品里面权值为正就加进来，最后，看ans是否等于0
 

 
 
 View Code  
  
   1 #include<cstdio>
 2 #include<cstring>
 3 #include<algorithm>
 4 using namespace std;
 5 double a[1005],b[1005];
 6 const double eps=1e-8;
 7 int n,r;
 8 double solve(double x)
 9 {
10     double temp[1005],ans=0;
11     for(int i=0;i<n;i++)
12         temp[i]=100*a[i]-x*b[i];
13     sort(temp,temp+n);
14     for(int i=0;i<r;i++)
15         ans+=temp[n-i-1];
16     for(int i=r;i<n&&temp[n-i-1]>-eps;i++)
17         ans+=temp[n-i-1];
18     return ans;
19 }
20 int main()
21 {
22     while(scanf(""%d%d"",&n,&r))
23     {
24         if(!(n||r))
25             break;
26         r=n-r;
27         for(int i=0;i<n;i++)
28             scanf(""%lf"",a+i);
29         for(int i=0;i<n;i++)
30             scanf(""%lf"",b+i);
31         double ll=0,rr=100,mid;
32         while(rr-ll>eps)
33         {
34             mid=(ll+rr)/2.0;
35             if(solve(mid)>eps)
36                 ll=mid;
37             else
38                 rr=mid;
39         }
40         printf(""%.0lf\n"",ll);
41     }
42     return 0;
43 } 
  
"
97,"HDU1505/POJ1964 City Game - c++语言程序开发技术文章_c++编程 - 红黑联盟

和HDU 1506类似，用a[i][j]表示  在i高度j位置上的最大高度
 [cpp]
 #include<stdio.h> 
 #define N 1002 
 int a[N][N]; 
 int l[N],r[N]; 
 int n,m;  www.2cto.com
 char ch[10]; 
 __int64 max,ans; 
 int main() 
 { 
    int T,i,j; 
    scanf(""%d"",&T); 
    while(T--) 
    { 
      scanf(""%d%d"",&n,&m); 
      for(i=0;i<=m;i++) a[0][i]=0; 
      for(i=1;i<=n;i++) 
         for(j=1;j<=m;j++) 
         { 
             scanf(""%s"",ch); 
             if(ch[0]=='F') 
                 a[i][j]=a[i-1][j]+1;//高度处理 
             else a[i][j]=0;//若遇上‘R’，高度置零 
         } 
         max=0; 
      for(i=1;i<=n;i++)//从第一行开始扫描，其他实现几乎与HDU 1506一样 
      { 
          a[i][0]=a[i][m+1]=-1; 
          for(j=1;j<=m;j++) 
             l[j]=r[j]=j; 
          for(j=1;j<=m;j++) 
             while(a[i][j]<=a[i][l[j]-1]) 
                 l[j]=l[l[j]-1]; 
         for(j=m;j>=1;j--) 
             while(a[i][j]<=a[i][r[j]+1]) 
                 r[j]=r[r[j]+1]; 
         for(j=1;j<=m;j++) 
         { 
            ans=a[i][j]*(r[j]-l[j]+1)*3; 
            if(max<ans) max=ans; 
         }        
      } 
       printf(""%I64d\n"",max); 
    } 
    return 0; 
 } 
"
100,"pku 3349 (Snowflake Snow Snowflakes)未解决_void com(fool G,fool G){happy every day!}_百度空间

//先留着，思想都有，写得太麻烦，等做够足够的HASH题再说吧
#include <iostream>
using namespace std;
const int Prime=14997 ;
int a[100010][7] ;
const int maxn=150000;
struct node
{
 node()
 {
   idx=-1;next=NULL;
 }
 node(int id)
 {
 idx=id;
 next=NULL;
 }
 int idx;
 node *next;
}table[maxn];
void init(int n)
{
 int i;
    for(i = 0 ; i < n ; i++)
 {
         table[i].idx=-1;
        table[i].next=NULL;
    }
}
int hash(int *a)
 {
      __int64 sum=0;
   int i;
      for(i = 0 ; i < 6 ; i++) 
    sum+=a[i];
     return sum%149997;
 }
int main()
{
    int N,OK(0),i(0),count(0);
 scanf(""%d"",&N);
 init(N);
 for(;N--;)
 {
        for(i = 0 ; i < 6 ; i++)
    scanf(""%d"",&a[count][i]);
     count++;
 }
/* for(i = 0 ; i < count ; i++)
 {
   for(int j = 0 ; j < 6 ; j++)
    cout<<a[i][j]<<"" "";
         cout<<endl;
 }*/
 return 0;
}
"
102,"poj 2985_乐吾天_百度空间

昨天zbwm让我用splay写这道题，但是由于我傻不小心忘了splay怎么写了。

想了很久终于想起来怎么写splay了，用vijos1081试了试发现的确没写次，于是我就用splay写了个这道题。

gnaggnoyil神牛用sbt只用了1313ms，我就比较弱，写了个splay用了1422ms

#include <cstdio>

using namespace std;

const int maxn=250001;

int c[maxn][2],s[maxn],key[maxn],count[maxn],root,total,nt,n,m;

int fa[maxn],size[maxn];

void splay(int&x,int k)

{

 if (x==0) return;

 int pt[2],ps[2];

 pt[0]=pt[1]=ps[0]=ps[1]=c[0][0]=c[0][1]=0;

 key[0]=k;

 while (key[x]!=k)

 {

 int w=k>key[x];

 if (k>key[c[x][w]]==w&&k!=key[c[x][w]])

 {

 int y=c[x][w];c[x][w]=c[y][!w];c[y][!w]=x;

 s[x]=s[c[x][0]]+s[c[x][1]]+count[x];

 x=y;

 }

 if (!c[x][w]) break;

 c[pt[!w]][w]=x;

 pt[!w]=x;

 ps[!w]+=s[c[x][!w]]+count[x];

 x=c[x][w];

 }

 for (int w=0;w<2;++w)

 {

 c[pt[w]][!w]=c[x][w];

 pt[w]=c[x][w];

 ps[w]+=s[c[x][w]];

 c[x][w]=c[0][!w];

 int y=c[x][w];

 while (y!=pt[w])

 {

 s[y]=ps[w];

 ps[w]-=s[c[y][w]]+count[y];

 y=c[y][!w];

 }

 }

 s[x]=s[c[x][0]]+s[c[x][1]]+count[x];

}

void insert(int&x,int k)

{

 splay(x,k);

 if (x&&key[x]==k) {count[x]++;s[x]++;return;}

 int y=++total;key[y]=k;s[y]=1;count[y]=1;

 if (x==0) {x=y;return;}

 int w=k>key[x];

 c[y][!w]=x;

 c[y][w]=c[x][w];

 c[x][w]=0;

 s[x]=s[c[x][!w]]+count[x];

 x=y;

 s[x]=s[c[x][0]]+s[c[x][1]]+count[x];

}

void remove(int&x,int k)

{

 splay(x,k);

 if (count[x]>1) {count[x]--;s[x]--;return;}

 int y=c[x][0];

 if (!y) {x=c[x][1];return;}

 splay(y,k+1);

 c[y][1]=c[x][1];

 x=y;

 s[x]=s[c[x][0]]+s[c[x][1]]+count[x];

}

int get_kth(int x,int k)

{

 for (;;)

 {

 if (k<=s[c[x][0]]) {x=c[x][0];continue;}

 k-=s[c[x][0]];

 if (k<=count[x]) break;

 k-=count[x];

 x=c[x][1];

 }

 splay(root,key[x]);

 return key[x];

}

int father(int i)

{

 int p=i;

 for (;fa[p];p=fa[p]);

 for (;fa[i];)

 {

 int t=fa[i];

 fa[i]=p;

 i=t;

 }

 return p;

}

int main()

{

// freopen(""1.in"",""r"",stdin);

 scanf(""%d%d"",&n,&m);

 nt=n;

 for (int i=1;i<=n;++i)

 {

 insert(root,1);

 size[i]=1;

 }

 for (int i=1;i<=m;++i)

 {

 int w,u,v;

 scanf(""%d"",&w);

 if (w==0)

 {

 scanf(""%d%d"",&u,&v);

 u=father(u);v=father(v);

 if (u!=v)

 {

 remove(root,size[u]);

 remove(root,size[v]);

 size[v]+=size[u];

 fa[u]=v;

 nt--;

 insert(root,size[v]);

 }

 }

 else

 {

 scanf(""%d"",&u);

 printf(""%d\n"",get_kth(root,nt+1-u));

 }

 }

}

推荐文章:

1. 
POJ 1733 / URAL 1003 Parity game [并查集]

2. 
poj 1611-The Suspects

3. 
POJ 1006 Biorhythms

4. 
POJ 1005 I Think I Need a Houseboat

5. 
[POJ 2019]矩阵处理

6. 
[POJ 1019]数字处理

7. 
[POJ 2299]逆序对

8. 
[POJ 2029]矩阵处理

9. 
poj 1140 Expanding Fractions 模拟

"
114,"pku 1505 copying books(DP) - xmx - 博客园

#include<stdio.h>
 #include<string>
 #include<algorithm>
 using namespace std;
int t,k,m;
 int books[510];
 int dp[510][510];
 int part[510];
#define Max(x,y) ((x)>(y)?(x):(y))
 #define Min(x,y) ((x)<(y)?(x):(y))
int sum(int i,int j)
 {
  int t=0,p;
  for(p=i;p<=j;p++)
   t += books[p];
  return t;
 }
 void cal2()
 {
  int i,j,l,st;
  for(i=1;i<=k;i++)
   dp[i][1] = sum(i,k);
 dp[k][1] = books[k];
 for(i=2;i<=m;i++)
  {
   dp[k-i+1][i] = Max(books[k-i+1], dp[k-i+2][i-1]);
   j = k-i+1;
   for(l=k-i; l>=m-i+1; l--)
   {
    if(sum(l,j) <= dp[j+1][i-1])
     dp[l][i] = dp[j+1][i-1];
    else if(books[l] >= dp[l+1][i-1])
     dp[l][i] = books[l] , j = l;
    else
    {
     while(sum(l,j-1) >= dp[j][i-1])
      j--;
     dp[l][i] = Min( sum(l,j), dp[j][i-1]);
     if(dp[l][i] == dp[j][l-1])
      j--;
    }
   }
  }
 }
 int main()
 {
  int i ,j, st;
  scanf(""%d"",&t);
  books[0]=0;
  while(t--)
  {
   scanf(""%d %d"",&k,&m);
   for(i=1;i<=k;i++) scanf(""%d"",&books[i]);
   memset(dp,0,sizeof(dp));
   cal2();
   st = 0; j = 0;
   for(i=k;i>=1;i--)
   {
    st += books[i];
    if(st > dp[1][m])
    {
     part[j++] = i+1;
     st = books[i];
    }
      if(st == dp[1][m])
    {
     if(m-j <= i)
     {
      part[j++] = i;
      st = 0;
     }
     else
     {
      part[j++] = i+1;
      st = books[i];
     }
    }
   }
  j--;
   printf(""%d"",books[1]);
   for(i=k;i<=2;i++)
   {
    if(i == part[j])
    {
     printf("" /"");
     j--;
    }
    printf("" %d"",books[i]);
   }
   printf(""\n"");
  }
 }
"
115,"pku1007 poj 1007 hdu1379 DNA Sorting - jw72jw的专栏 - 博客频道 - CSDN.NET

//poj1007
 //puk 1007
 //DNA Sorting
 //开始时老是不能理解题意，后来仔细再看了一下题目和测试数据，恍然大悟啊
 //题目给出若干个字符串，然后要你数出有多少对是前面一个比后面一个大的
 //举个例子：A A C A T G A A G G，每一个数一数后面有多少个比它大
 //分别是：  0 0 3 0 5 2 0 0 0 0  这一个串就有是10
 //然后根据这个的大小给所有串排序
 #include<iostream>
 #include<string>
 using namespace std;
 struct DNA                         //结构体，方便排序
 {
  string a;
  int length;
 }dna[110];
 int calNumber( string ch, int n )  //找出每一个串有多少对
 {
  int count=0;
  int i,j;
  for( i=0; i<n-1; i++ )
   for( j=i+1; j<n; j++ )
   {
    if( ch[i]>ch[j] )
    {
     count++;
    }
   }
  return count;
 }
 int cmp( const void *a ,const void *b)   //qsort比较函数
 { 
              return (*(DNA *)a).length < (*(DNA *)b).length ? 1 : -1; 
 } 
 int main()
 {
  int n,cases;
  int i;
  char a[100];
  scanf(""%d%d"",&n,&cases);
  for(i=0;i<cases;i++)
  {
   cin>>dna[i].a;
   dna[i].length=calNumber( dna[i].a , n );
 //  cout<<dna[i].length<<endl;
  }
     qsort(dna,cases,sizeof(dna[0]),cmp);
 // cout<<endl;
  for(i=cases-1;i>=0;i--)
   cout<<dna[i].a/*<<dna[i].length*/<<endl;
  return 0;
 }
"
119,"POJ 1204 - c++语言程序开发技术文章_c++编程 - 红黑联盟

trie树做法
 [cpp] 
 #include<cstdio> 
 #include<cstring> 
 #include<queue> 
 #include<cstdlib> 
 const int kind=26; 
 using namespace std; 
 char s[1010][1010]; 
 int h[]={-1,-1,0,1,1,1,0,-1}; 
 int g[]={0,1,1,1,0,-1,-1,-1}; 
 int m,n,q,sum; 
 int xx[1010],yy[1010],zz[1010]; 
 struct trie{ 
     struct trie * fail,*next[kind]; 
     int count,num; 
 }; 
 struct trie * root; 
 void insert(char* str,int ii){ 
     int len=strlen(str),i,tem; 
     struct trie *p,*q; 
     p=root; 
     for(i=0;i<len;i++){ 
         tem=str[i]-'A'; 
         if(p->next[tem]==NULL){ 
             q=(struct trie*)calloc(1,sizeof(struct trie)); 
             q->count=0; 
             q->num=0; 
             q->fail=NULL; 
             memset(q->next,NULL,sizeof(q->next)); 
             p->next[tem]=q; 
         } 
         p=p->next[tem]; 
     } 
     p->count=1; 
     p->num=ii; 
 } 
 bool yes(int i,int j){ 
     if(i>=0 && j>=0 && i<n && j<m) 
         return 1; 
     return 0; 
 } 
 void query(int i,int j,int k){ 
     int tem,x,y,pp; 
     struct trie* tmp=root,*p; 
     x=i,y=j; 
     for(pp=0;yes(i+pp*h[k],j+pp*g[k]);pp++){ 
         x=i+pp*h[k]; 
         y=j+pp*g[k]; 
         tem=s[x][y]-'A'; 
         if(tmp->next[tem]==NULL) 
             return; 
         tmp=tmp->next[tem]; 
         if(tmp->count){ 
             sum++; 
             xx[tmp->num]=i; 
             yy[tmp->num]=j; 
             zz[tmp->num]=k; 
             tmp->count=0; 
         } 
     } 
 } 
 void sea(){ 
     char str[2010]; 
     int i,j,k; 
     sum=0; 
     for(i=0;i<n;i++) 
         for(j=0;j<m;j++){ 
             for(k=0;k<8;k++){ 
                 query(i,j,k); 
                 if(sum==q)return; 
             } 
         } 
 } 
 int main(){ 
     int i; 
     char str[2010]; 
     root=(struct trie*)calloc(1,sizeof(struct trie)); 
     root->fail=NULL; 
     root->count=0; 
     root->num=0; 
     memset(root->next,NULL,sizeof(root->next)); 
     scanf(""%d %d %d"",&n,&m,&q); 
     for(i=0;i<n;i++) 
         scanf(""%s"",s[i]); 
     for(i=1;i<=q;i++){ 
         scanf(""%s"",str); 
         insert(str,i); 
     } 
     sea(); 
     for(i=1;i<=q;i++){ 
         printf(""%d %d %c\n"",xx[i],yy[i],'A'+zz[i]); 
     } 
 } 
 AC自动机做法
 作者：waitfor_"
125,"Poj.Grids 2764 数根_朗弦_新浪博客

//@author langx
 //G++4.4

 
#include <cstdio> #include <cstring>  int main(){     char chr[1005];     int i, a[1005], alen, broot, n;     while ( ~scanf(""%s"",chr) && chr[0] != '0'){         alen = 0;         for ( i = 0; chr[i] != '\0'; ++i ){             a[alen++] = chr[i] - '0';         }         broot = 0;         for ( i = 0; i < alen; ++i){             broot += a[i];         }         //计算完以后broot <= 9 * 1000 = 9000         //if(broot > 9){         //    n = broot;         //    while ( true ){         //        broot = 0;         //        while ( n ){         //            broot += n % 10;         //            n /= 10;         //        }         //        if(broot < 10) break;         //        n = broot;         //    }         //}         //注意到任何移位相加前后，模9余数都不变。         broot = (broot - 1) % 9 + 1;         printf(""%d\n"",broot);     }     return 0; }

"
132,"Coin Toss【poj】3440 - 只是路过的日志 - 网易博客

主要是找准图形的对应的区域，那么代码就简单了
#include<iostream>
#define pi 3.141592653
using namespace std;
double a2(double m,double n,double v,double r)
{
 return (v-r)*r*((m-1)*(n)+(m)*(n-1))+r*r/2.0*(m+n-2)*2;
}
double a4(double m,double n,double v,double r)
{
 return pi*r*r/4.0*(m-1)*(n-1);
}
double a3(double m,double n,double v,double r)
{
 return (r*r-pi*r*r/4.0)*(m-1)*(n-1);
}
int main()
{
 int c,i;
 cin>>c;
 for(i=1;i<=c;i++)
 {
   double m,n,v,arc;
   cin>>m>>n>>v>>arc;
   //2:
   double are2=a2(m,n,v,arc);
   double are4=a4(m,n,v,arc);
   double are3=a3(m,n,v,arc);
   double are1=m*n*v*v-are2-are3-are4;
   printf(""Case %d:\n"",i);
   printf(""Probability of covering 1 tile = %.4f%%\n"",are1*100/(m*n*v*v));
   printf(""Probability of covering 2 tiles = %.4f%%\n"",are2*100/(m*n*v*v));
   printf(""Probability of covering 3 tiles = %.4f%%\n"",are3*100/(m*n*v*v));
   printf(""Probability of covering 4 tiles = %.4f%%\n\n"",are4*100/(m*n*v*v));
 }
 return 0;
}
"
135,"POJ 1657 Distance on Chessboard 解题报告 - 端木 - 博客园

POJ 1657 Distance on Chessboard 解题报告
    
 
编号：1657
   
 
考查点：简单计算题
   
 
思路：水题，有一点弯弯的就是象是如何走的，仔细观察可知：象只可以在横竖坐标之差为偶数的两点移动.看出来这点就相当easy了
   
 
提交情况: 刷水题，一次AC.。
   
 
Source Code：
   
 
 //
 POJ Grids 1657
 
 
 #include 
 <
 string
 >
 
 #include 
 <
 iostream
 >
 
 
 using
  
 namespace
  std;
 
 int
  main()
 {
     
 int
  t;cin
 >>
 t;
     
 while
  (t
 --
 )
     {
         
 string
  str1,str2;
         cin
 >>
 str1
 >>
 str2;
         
 int
  x 
 =
  abs(str1[
 0
 ]
 -
 str2[
 0
 ]);
         
 int
  y 
 =
  abs(str1[
 1
 ]
 -
 str2[
 1
 ]);
         
 if
  (x
 +
 y
 ==
 0
 )
         {
             cout
 <<
 ""
 0 0 0 0
 ""
 <<
 endl;
             
 continue
 ;
         }
         
 if
  (x
 >
 y)
             cout
 <<
 x
 <<
 ""
  
 ""
 ;
         
 else
 
             cout
 <<
 y
 <<
 ""
  
 ""
 ;
         
 if
  (x
 ==
 0
 ||
 y
 ==
 0
 ||
 x
 ==
 y)
             cout
 <<
 1
 <<
 ""
  
 ""
 ;
         
 else
 
             cout
 <<
 2
 <<
 ""
  
 ""
 ;
         
 if
  (x
 ==
 0
 ||
 y
 ==
 0
 )
             cout
 <<
 1
 <<
 ""
  
 ""
 ;
         
 else
 
             cout
 <<
 2
 <<
 ""
  
 ""
 ;
         
 if
  (x
 ==
 y)
             cout
 <<
 1
 <<
 endl;
         
 else
 
         {
             
 if
  (abs(x
 -
 y)
 %
 2
 ==
 0
 )
                 cout
 <<
 2
 <<
 endl;
             
 else
 
                 cout
 <<
 ""
 Inf
 ""
 <<
 endl;
         }
     }
     
 return
  
 0
 ;
 }
 
 
总结：这道题我寒假刚开始的时候做过，现在再做一遍，感觉自己进步了很多，思路也开阔了，想当年这道题我用了四个小时，汗.。
   
 
                                                       By   Ns517
   
 
                                                      Time 09.02.11
  
"
136,"poj3401 - lyg_wangyushi的专栏 - 博客频道 - CSDN.NET

http://acm.pku.edu.cn/JudgeOnline/problem?id=3401
                                                          String reduction
 
 
  
   
    
    Time Limit: 1000MS 
      
    Memory Limit: 65536K 
    
    
    Total Submissions: 799 
      
    Accepted: 219 
    
   
  
 
Description
There is a string of characters 'a' and 'b' with the length of no more than 255 characters. You can perform the substring reduction on the initial string in the following way: a substring ""a*a"" or ""b*b"" (where *(asterisk) denotes any character) can be reduces to a substring ""*"".
The task is to achieve a string of minimal possible length after several substring reductions.
 
  
 
Input
The input contains the initial string.
 
 
Output
The output contains a single line with the minimal possible length.
 
 
Sample Input
 
aab 
Sample Output
 
3 
Source
 

 Northeastern Europe 2001, Western Subregion
 

 
题目意思是说，有一个只有'a','b'组成的字符串，可以有一种操作reduction  ,可以将形如 a*a,b*b的字符变为a或者b，要求
 

 给定一个字符串，求能变化后的最小的长度。
 

 看了discuss后才AC,具体是这样做的：
 

 我们先用F[i][j]表示能否将i,j之间的字符串变化为一个单个字符，这个是标准的动态规划，状态转移方程为：
 

 F[i][j] =  true  if( str[i] == str[j] && F[i+1][j-1] = = true
 

 F[i][j] =  true if(i+2 != j && (F[i+2][j] == true || F[i][j-2] ==true)
 

 else F[i][j] = false;
 

 然后我们用Len[i][j] 表示i，j之间的字串能够变为的最小长度，可以看出这个也是一个标准的动态规划
 

 状态转移方程为：
 

 Len[i][j] = 1 if(F[i][j] == true)
 

 else Len[i][j] = min(Len[i+1][j-1] + 2,Len[i+1][j]+1,Len[i][j-1]+1)
 

 由此我们就可以得到求这个题目的具体做法，代码如下：
 

 #include ""iostream""
#include ""cstdio""
#include ""cstring""
using namespace std;
const int MaxN = 260;
bool F[MaxN][MaxN];
char str[MaxN];
int Len[MaxN][MaxN],len;
inline int min(int a,int b,int c){
    int ret = a;
    if(b < ret) ret = b;
    if(c < ret) ret = c;
    return ret;
}
void work(){
    len = strlen(str);
    memset(F,false,sizeof(F));
    for(int i = 0 ;i < len; ++i)
        F[i][i] = true;
    memset(Len,0,sizeof(Len));
    for(int i =  0;i < len; ++i)
        Len[i][i] = 1;
    for(int j = 2;j < len ;++j){
        for(int i = 0 ;i < len - j; ++i){
            if(str[i] == str[i+j] && F[i+1][i+j-1])
                F[i][i+j] = true;
            else if( j!= 2 && (F[i+2][i+j] || F[i][i+j-2]))
                F[i][i+j] = true;
        }
    }
    for(int j = 1;j < len; ++j){
        for(int i = 0 ;i < len - j; ++i){
            if(F[i][i+j] == true)
                Len[i][i+j] = 1;
            else
                Len[i][i+j] = min(Len[i+1][i+j-1] + 2,Len[i+1][i+j]+1,Len[i][i+j-1]+1);
        }
    }
}
int main(){
    scanf(""%s"",&str);
    work();
    printf(""%d/n"",Len[0][len-1]);
    return 0;
}
后来突然发现这个题目有一个非常桥面简单的方法，由于a*a, b*b之类的字符可以匹配任意字符，那么我们只要从前
向后扫描，如果有相隔的两个字符相同，由于这三个字符能够匹配a,b任意字符，那么我们就可以让这种匹配一直进行
下去，从而将字符串不断的reduction ，只要注意字符串长度的奇偶性就可以了，如此我们可以得到一个很简单的方法
代码如下：
#include ""iostream""
#include ""cstdio""
#include ""cstring""
using namespace  std;
char str[256];
int main(){
    scanf(""%s"",str);
    int len = strlen(str);
    int ans = len;
    for(int i = 0 ;i +2 <len;++i){
        if(str[i] == str[i+2]){
            if(len %2)
                ans = 1;
            else ans = 2;
        }
    }
    printf(""%d/n"",ans);
    return 0;
} 
"
138,"poj 2777 Count Color - 静涛 - 博客频道 - CSDN.NET

//更新区间，求区间数的种类
#include<stdio.h>
#include<string.h>
const int max=100000;
int flag[31];
struct node
{
	int left,right,color;
}nodes[3*max];
void build(int l,int r,int id)
{
	nodes[id].left=l;//这里是参数l，大写是L，而不是1，错了几次
	nodes[id].right=r;
	nodes[id].color=1;//这里是数字1
	if(l==r) return ;
	int mid=(l+r)>>1;
	build(l,mid,id<<1);//id*2
	build(mid+1,r,id<<1|1);//id*2+1
}
void insert(int id,int l,int r,int cc)
{
	if(nodes[id].left>=l&&nodes[id].right<=r)
	{
		nodes[id].color=cc;
		return ;
	}
	if(nodes[id].left==nodes[id].right)return ;
	if(nodes[id].color>0)//懒惰标记，标记父节点，而暂时不更新子节点，当要询问时再来更新
        {
		nodes[id*2].color=nodes[id].color;
		nodes[id*2+1].color=nodes[id].color;
		nodes[id].color=-1;
	}
	int mid=(nodes[id].left+nodes[id].right)>>1;
	if(mid>=r) insert(id*2,l,r,cc);
	else if(mid<l) insert(id*2+1,l,r,cc);
	else
	{
		insert(id*2,l,mid,cc);
		insert(id*2+1,mid+1,r,cc);
	}
}
void count(int l,int r,int id)
{
	if(nodes[id].color>0)
	{
		flag[nodes[id].color]=1;
		return ;
	}
	int mid=(nodes[id].left+nodes[id].right)>>1;
	if(mid>=r) count(l,r,id*2);
	else if(mid<l) count(l,r,id*2+1);
	else 
	{
		count(l,mid,id*2);
		count(mid+1,r,id*2+1);
	}
}
int main()
{
	int n,m,k,a,b,c,ee,ff;
	char char1;
	scanf(""%d%d%d"",&n,&m,&k);
	build(1,n,1);
	while(k--)
	{
		getchar();
		scanf(""%c"",&char1);
		if(char1=='C')
		{
			scanf(""%d%d%d"",&a,&b,&c);
			if(a>b)
				insert(1,b,a,c);
			else 
				insert(1,a,b,c);
		}
		else
		{ 
		     scanf(""%d%d"",&ee,&ff);
			 memset(flag,0,sizeof(flag));
			 if(ee>ff) 
				 count(ff,ee,1);
			 else 
				 count(ee,ff,1);
			 int sum=0;
	         for(int j=1;j<=m;j++)
	         {
                if(flag[j])sum++;
	         }
	         printf(""%d\n"",sum);
		}
	}
	return 0;
}
"
139,"poj pku 2245 Lotto_天空之城_百度空间

简单的搜索dfs.
//poj_2245 Lotto
//LiQi 2010-8-01 13:20
#include<iostream>
int a[15];
int num[15];
int k;
void dfs(int n,int m)
{
 if(n==6)
 {
   for(int j=0;j<6;j++)
    printf(""%d "",a[j]);
   printf(""\n"");
   return ;
 }
 for(int i=m;i<k;i++)
 {
   a[n]=num[i];
   dfs(n+1,i+1);
 } 
}
int main()
{
 //freopen(""in.txt"",""r"",stdin);
 while(scanf(""%d"",&k)!=EOF&&k)
 {
   for(int i=0;i<k;i++)
    scanf(""%d"",&num[i]);
   dfs(0,0);
   printf(""\n"");
 }
 return 0;
}
"
140,"求pku 2426 Remainder的解题报告及代码_百度知道

这题做了有一段时间了，当初我也卡了很久。。
解题思路是这样的：
1。先考虑一个以个特殊情况 当 M = K的时候。
这个时候问题就简单了，因为M=K的，所以可以用BFS，因为答案最终比较的时候是（N的最终值)%K,实际上就是(N + - * % M 的一些算数运输）% K,由于M = K的，加上%的特性之，可以把%放到括号里面的每一步。。这是一个很好的想法，因为 K <= 1000的，这时候你会发现，BFS的状态空间就顶多包含1000个节点！
2.当M != K 的时候，由于(()%M)%K) 不一定等于 (()%K)%M，这时候1的算法就行不通了。。。但题目有个很好的限制，就是规定字典序的时候，%的字典序是最大的，而答案最终要输出的是字典序最小的运算系列。。认真分析一下你会发觉出现%运算只有两种情况：1.开头出现一次%；2.开头出现*%。基于这个特征可以枚举这两种情况，那么后面的运算就没有%了，进而转化成第一种情况！
算法可能稍微复杂了点，但想清楚%出现的情况后实际上就是一水BFS.
代码如下：
#include <iostream>
using namespace std;
const int N = 1010;
const int MAX = INT_MAX / 2;
int dis[N];
char op[N];
int q[N];
int parent[N];
int * head, * tail;
int Mod(int n, int m)
{
 n %= m;
 if(n < 0){
  n += m;
 }
 return n;
}
int BFS(char * ans, int ini, int goal, int k, int m)
{
// printf(""ini = %d, goal = %d, k = %d, m = %d\n"", ini, goal, k, m);
 memset(dis, -1, k * sizeof(int));
 head = tail = q;
 dis[ini] = 0;
 *(tail++) = ini;
// printf(""aaaaaaa\n"");
 while(head < tail)
 {
  int n = *(head++);
  if(n == goal){
   break;
  }
  int next = Mod(n + m, k);
  if(dis[next] == -1){
   dis[next] = dis[n] + 1;
   parent[next] = n;
   op[next] = '+';
   *(tail++) = next;
  }
  next = Mod(n - m, k);
  if(dis[next] == -1){
   dis[next] = dis[n] + 1;
   op[next] = '-';
   parent[next] = n;
   *(tail++) = next;
  }
  next = Mod(n * m, k);
  if(dis[next] == -1){
   dis[next] = dis[n] + 1;
   op[next] = '*';
   parent[next] = n;
   *(tail++) = next;
  }
 }
// printf(""bbbbbbbb\n"");
 if(head == tail){
  return MAX;
 }
 int pos = dis[goal], d = dis[goal];
 ans[pos--] = '\0';
 while(goal != ini){
  ans[pos--] = op[goal];
  goal = parent[goal];
 }
 return d;
}
int main()
{
 int n, k, m;
 char ans[100], t[100];
 while(true){
  scanf(""%d%d%d"", &n, &k, &m);
  if(!n && !k && !m){
   break;
  }
  char add[10] = ""\0"";
//  printf(""aaaaaaa\n"");
  int goal = Mod(n + 1, k);
//  printf(""bbbbbbbb\n"");
  int tot = BFS(ans, Mod(n, k), goal, k, m);
//  printf(""aaaaaaaa\n"");
//  printf(""tot = %d\n"", tot);
  int tt = BFS(t, 0, goal, k, m);
  if(tot > tt + 2){
   tot = tt + 2;
   add[0] = '*';
   add[1] = '%';
   add[2] = '\0';
   strcpy(ans, t);
  }
//  printf(""bbbbbbbbb\n"");
  tt = BFS(t, Mod(n, m), goal, k, m);
  if(tot > tt + 1){
   tot = tt + 1;
   add[0] = '%';
   add[1] = '\0';
   strcpy(ans, t);
  }
  if(tot >= MAX){
   printf(""0\n"");
  }
  else {
   printf(""%d\n"", tot);
   printf(""%s%s\n"", add, ans);
  }
 }
 return 0;
}"
146,"POJ 1324_勇敢的心_新浪博客

POJ 1324
 BFS广搜，所有边权都相等的这类广搜是不需要记录dis[][]数组的，定义一个vis[][]数组，碰到了这个点就标记这个点访问过，这样一旦第一次碰到了一个没有访问过的点并且这个点是终点的话，那么就可以返回结果了。
 这个题的重点在于如何记录蛇身的状态，注意到蛇身长度最长为8，那么只需要7个记录蛇身相邻的块的关系就可以了，比如如果一个蛇块A在另一个蛇块B的右边，认为这个值为1，这样只需要四个值就可以记录相邻的两个蛇块之间的关系了
 小技巧，如果多CASE输入的话，初始化vis操作可能会占用比较多的时间，我们可以将vis[][]==cas这个条件来判断是否是本CASE中所访问的点。
 另外需要注意的地方，对于队列来说，如果要在访问到新的节点是判断是否是终点，那么一定记得在最开始的时候判断是否起点就是终点，不然可能会返回无解，比如起点和终点重合，然后起点四周被封死，这样如果不在一开始判断的话，会导致最终返回-1，这是错误的。如果是在一个节点弹出队列的时候判断是否是终点，那么就不需要在最开始的时候判断了。
#include<iostream>
 #include<cstdlib>
 #include<cstdio>
 #include<cstring>
 #include<queue>
 using namespace std;
struct data{
  int x,y,st,dep;
  data(int X,int Y,int St,int Dep):x(X),y(Y),st(St),dep(Dep){}
 };
int a[9][2],b[25][25];
 int vis[21][21][1<<14];
 int n,m,L,cas=0;
 int dx[]={1,0,-1,0},dy[]={0,-1,0,1};
 int ass[9];
 int hash[]={2,3,0,1};
queue<data>q;
bool check(int x,int y,data t){
     int xx=t.x,yy=t.y,st=t.st;
     if(x==xx&&y==yy)return 1;
    for(int i=L-1;i>0;i--){
         ass[i]=st&3;
         st>>=2;
     }
    for(int i=1;i<L;i++){
         int k=hash[ass[i]];
         xx+=dx[k],yy+=dy[k];
         if(x==xx&&y==yy)return 1;
     }
     return 0;
 }
int bfs(data s){
     if(s.x==1&&s.y==1)return 0;
  while(!q.empty())q.pop();
  q.push(s);
  vis[s.x][s.y][s.st]=cas;
 while(!q.empty()){
   data u=q.front();
   q.pop();
   int x=u.x,y=u.y,st=u.st,dep=u.dep+1;
   for(int k=0;k<4;k++){
    int xx=x+dx[k],yy=y+dy[k];
    if(b[xx][yy]||check(xx,yy,u))continue;
    int t=(st>>2)+(k<<(2*L-4));
    if(vis[xx][yy][t]==cas)continue;
    if(xx==1&&yy==1)return dep;
    vis[xx][yy][t]=cas;
    data tp(xx,yy,t,dep);
    q.push(tp);
   }
  }
  return -1;
 }
int main(){
  while(scanf(""%d%d%d"",&n,&m,&L)!=EOF){
   if(n+m+L==0)break;
   int i,st=0;
   for(i=1;i<=L;i++)
    scanf(""%d%d"",&a[i][0],&a[i][1]);
   for(i=1;i<L;i++){
    int x=a[i][0],y=a[i][1],xx=a[i+1][0],yy=a[i+1][1],f;
    if(xx==x){
     if(yy==y-1)f=3;
     else f=1;
    }
    else {
     if(xx==x-1)f=0;
     else f=2;
    }
    st=(st<<2)+f;
   }
  int blo,x,y;
   scanf(""%d"",&blo);
   memset(b,0,sizeof(b));
   while(blo--){
    scanf(""%d%d"",&x,&y);
    b[x][y]=1;
   }
   for(i=1;i<=m;i++)b[0][i]=b[n+1][i]=1;
   for(i=1;i<=n;i++)b[i][0]=b[i][m+1]=1;
  data tp(a[1][0],a[1][1],st,0);
   ++cas;
   printf(""Case %d: %d\n"",cas,bfs(tp));
  }
  return 0;
 }
"
149,"POJ-2946-The Warehouse - z309241990的专栏 - 博客频道 - CSDN.NET

唉，终于做到书中图遍历系列的最后一个题了。
题目的大意是说，你所处的一个迷宫，你只能走在有数字的方格（坐标）上，方格按照题目的意思是箱子，其为长方体（1*1*h)，h即为其上面的数字。当然这里给你2种操作（方向都只有上下左右）：
1、走到旁边的数字方格上面去。
2、推到你现在所站的方格，其向前倒下高度变为1.，当然前提是前面有足够多的'.'（出口E不能算作'.'）即不能将箱子推到到E上面去。题目所要求箱子只能被推到一次，即在做的过程中只能推到数字大于1的，等于1的就只能行走。
注意：非数字的坐标是不能走的，要求就是求起点到终点的最小步数。
这个题明显是个BFS搜索题，关键的问题是它需要记录的状态并不像以往那样只记录坐标即可，它需要把整个图的状态也要记录下来。这就给去重复工作增添了麻烦，这里按书上的建议我采用的也是哈希表，通过一个表达式进行计算，然后得到一个状态值，判断这个状态值是否出现从而得到当前状态是否与之前的重复。这个表达式有点侥幸的感觉~
做后觉得这个题就是我们以前一个游戏的模型，还觉得比较有意思。
代码：
 
#include<cstdio>
#include<cstring>
#define MAX 10
#define mod 3000007
struct map
{
    char smap[MAX][MAX];
    int x,y,moves;
}q[1000000];
int n,movex[4]={1,-1,0,0},movey[4]={0,0,-1,1};
bool ipos[mod];
bool isborder(int x,int y)
{
    if(x<0||x>=n||y<0||y>=n)
	return true;
    return false;
}
int GetHash(int index)
{
    int ans=0;
    for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	    ans=(ans*131+q[index].smap[i][j])%mod;
    ans=(ans+q[index].x*33+q[index].y*131)%mod;
    return ans;
}
int main()
{
    while(scanf(""%d%d%d"",&n,&q[0].x,&q[0].y)&&n)
    {
	memset(ipos,0,sizeof(ipos));
	int front=0,last=1,pos=0;
	q[0].x--;
	q[0].y--;
	q[0].moves=0;
	for(int i=0;i<n;i++)
	{
	    getchar();
	    for(int j=0;j<n;j++)
		scanf(""%c"",&q[0].smap[i][j]);
	}
	ipos[GetHash(0)]=1;
	int flag=0,ans=0;
	while(front!=last)
	{
	    char smap[8][8];
	    for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
		    smap[i][j]=q[front].smap[i][j];
	    int itx=q[front].x;
	    int ity=q[front].y;
	    int moves=q[front++].moves;
	    for(int i=0;i<4;i++)
	    {
		int xx=itx+movex[i];
		int yy=ity+movey[i];
		if(!(isborder(xx,yy)||smap[xx][yy]=='.'))
		{
		    if(smap[xx][yy]=='E')
		    {
			flag=1;
			ans=moves+1;
			break;
		    }
		    int hash=0;
		    for(int j=0;j<n;j++)
			for(int k=0;k<n;k++)
			    hash=(hash*131+smap[j][k])%mod;
		    if(!ipos[(hash+xx*33+yy*131)%mod])
		    {
			for(int j=0;j<n;j++)
			    for(int k=0;k<n;k++)
				q[last].smap[j][k]=smap[j][k];
			q[last].x=xx;q[last].y=yy;
			q[last].moves=moves+1;
			last++;
			ipos[(hash+xx*33+yy*131)%mod]=1;
		    }
		}
		if(smap[itx][ity]!='.'&&smap[itx][ity]!='1')
		{
		    int flaga=0,mx=itx,my=ity;
			for(int j=0;j<smap[itx][ity]-'0';j++)
			{
			    mx+=movex[i];
			    my+=movey[i];
			    if(isborder(mx,my)||smap[mx][my]!='.')
			    {
				flaga=1;
				break;
			    }
			}
			if(!flaga)
			{
			    for(int j=0;j<n;j++)
				for(int k=0;k<n;k++)
				    q[last].smap[j][k]=smap[j][k];
			    mx=itx,my=ity;
			    for(int j=0;j<smap[itx][ity]-'0';j++)
			    {
				mx+=movex[i];
				my+=movey[i];
				q[last].smap[mx][my]='1';
			    }
			    q[last].smap[itx][ity]='.';
			    q[last].x=xx;
			    q[last].y=yy;
			    q[last].moves=moves+1;
			    ipos[GetHash(last)]=1;
			    last++;
			}
		}
	    }
	    if(flag)
		break;
	}
	if(flag)
	    printf(""%d\n"",ans);
	else
	    printf(""Impossible.\n"");
    }
    return 0;
}
"
150,"pku 3140_chenjiang_百度空间

题意：有一棵树，数的每个节点有一个权值，删去树中的一条边，得到两部分，求这两部分权值和的差最少是多少
思路：树形DP，递归建树并求出树中每个节点root所属子树的权值和，然后求每个节点删除他和孩子节点后分成的两部分的权值差，求的最小那个就行了
const double PI = acos(-1.0);
const double eps = 1e-11;
#define _max 100005
int head[_max];
int head0[_max];
struct node
{
    int to;
    int next;
}edge[_max*20],edge0[_max];
int e_num0;
int e_num;
int n,m;
__int64 sum[_max];
int a[_max];
__int64 num;
__int64 ans;
bool visited[_max];
__int64 labs(__int64 k)
{
    if(k>=0)return k;
    else return -k;
}
void add(int from,int to)
{
    e_num++;
    int i=e_num;
    edge[i].to=to;
    edge[i].next=head[from];
    head[from]=i;
}
void add0(int from,int to)
{
    e_num0++;
    int i=e_num0;
    edge0[i].to=to;
    edge0[i].next=head0[from];
    head0[from]=i;
}
void Build_Tree(int root)
{
    int i;
    for(i=head[root];i!=-1;i=edge[i].next)
    {
        int son=edge[i].to;
        if(visited[son])continue;
        visited[son]=1;
        add0(root,son);
        Build_Tree(son);
        sum[root]+=sum[son];
    }
}
void dfs(int root)
{
    int i;
    for(i=head0[root];i!=-1;i=edge0[i].next)
    {
        int son=edge0[i].to;
        ans=min(ans,labs(num-sum[son]-sum[son]));
        dfs(son);
    }
}
int main(int argc, char** argv) {
    int i,j;
    int ca=0;
    while(scanf(""%d%d"",&n,&m)!=EOF)
    {
        if(n==0&&m==0)break;
        num=0;
        for(i=1;i<=n;i++)
        {
            scanf(""%d"",&a[i]);
            num+=a[i];
            sum[i]=a[i];
        }
        e_num=0;
        memset(head,-1,sizeof(head));
        for(i=1;i<=m;i++)
        {
            int from,to;
            scanf(""%d%d"",&from,&to);
            add(from,to);
            add(to,from);
        }
        if(n==1)
        {
            printf(""Case %d: %d\n"",++ca,a[1]);
            continue;
        }
        memset(visited,0,sizeof(visited));
        visited[1]=1;
        memset(head0,-1,sizeof(head0));
        e_num0=0;
        Build_Tree(1);
        ans=(long long) INT_MAX * (long long) 10000;
        dfs(1);
        printf(""Case %d: %I64d\n"",++ca,ans);
    }
    return (EXIT_SUCCESS);
}
"
155,"POJ 3100 Root of the Problem_乐吾天_百度空间

 
#include<stdio.h>


int power(int a, int b)


{


     int m=1;


    while(b--)


         m = m*a;


    return m;


}


int main()


{


     int b, n, i;


    while(scanf(""%d %d"", &b, &n))


     {


        if(b==0 && n==0)


            break;


        for(i=1; ; i++)


         {


            if(power(i, n) > b)


                break;


         }


        if(power(i, n)-b > b-power(i-1, n))


            printf(""%d\n"", i-1);


        else


            printf(""%d\n"", i);


     }


    return 0;


} 

推荐文章:

1. 
POJ 1036 DP 强盗闯门

2. 
转一首poj的情诗，先留这里，以后定有用

3. 
poj 2311 Cutting Game(博弈论 之 sg函数)

4. 
转战POJ

5. 
POJ 3150 Cellular Automaton 矩阵法

6. 
POJ 2352 Stars [树状数组]

7. 
poj 2288——Islands and Bridges——基于Hamilton回路的状态压缩动态规划（DP)

8. 
poj 3530——A Modular Arithmetic Challenge——数论

9. 
都不想在POJ上做题了

10. 
POJ 1201

"
156,"POJ 1632 Vase collection - bobten2008的专栏 - 博客频道 - CSDN.NET

 

 Vase collection
 
 
  
   
    
    Time Limit: 1000MS 
      
    Memory Limit: 10000K 
    
    
    Total Submissions: 1536 
      
    Accepted: 552 
    
   
  
 
Description
 

 Mr Cheng is a collector of old Chinese porcelain, more specifically late 15th century Feng dynasty vases. The art of vase-making at this time followed very strict artistic rules. There was a limited number of accepted styles, each defined by its shape and decoration. More specifically, there were 36 vase shapes and 36 different patterns of decoration ? in all 1296 different styles. 
 
For a collector, the obvious goal is to own a sample of each of the 1296 styles. Mr Cheng however,like so many other collectors, could never afford a complete collection, and instead concentrates on some shapes and some decorations. As symmetry between shape and decoration was one of the main aestheathical paradigms of the Feng dynasty, Mr Cheng wants to have a full collection of all combinations of k shapes and k decorations, for as large a k as possible. However, he has discovered that determining this k for a given collection is not always trivial. This means that his collection might actually be better than he thinks. Can you help him?
 
Input
 

 On the first line of the input, there is a single positive integer n, telling the number of test scenarios to follow. Each test scenario begins with a line containing a single positive integer m <= 100, the number of vases in the collection. Then follow m lines, one per vase, each with a pair of numbers, si and di, separated by a single space, where si ( 0 < si <= 36 ) indicates the shape of Mr Cheng's i:th vase, and di ( 0 < di <= 36 ) indicates its decoration.
 
Output
 

 For each test scenario, output one line containing the maximum k, such that there are k shapes and k decorations for which Mr Cheng's collection contains all k*k combined styles.
 
Sample Input
 
2
5
11 13
23 5
17 36
11 5
23 13
2
23 15
15 23 
Sample Output
 
2
1 
Source
 

 Northwestern Europe 2003
 

/*
 搜索的好题
 数据结构与状态的表示如下：
 1)对于输入i,j置graph[j][i] = true, 称作j和i存在映射关系
 2)为了节省搜索时间将收入中出现过的数据，分别顺序存入setsf, setst,并统计数目setsfn,setstn
 3)状态利用bit位来表示，每一个shape占一位，用来表示当前的shape是否处在可选集合中，一共可能
 有36种shape，所以需要用到__int64，普通int已经无法容纳
 搜索策略如下：采用DFS搜索，搜索从第一个decoration开始，依次往下遍历，每处理一个decoration时
 需要判断当前decoration能否被选，如果可以被选那么下一步可以有两种选择，选择该decoration和不选
 该decoration
 假设当前可选集合中decoration的数量是num,则判断当前decoration可不可以被选的方法如下：对于当前
 状态state中，必须存在至少num + 1种shape是当前decoration在输入数据中映射到的,注意要特殊处理起
 始情况即num为0的情况
 
 
  
   
   6095577 
   bobten2008  
   1632  
   Accepted  
   168K 
   16MS 
   C++  
   1428B 
   2009-11-06 13:53:17 
   
  
 

 */
#include <iostream>
#define MAX_N 36
using namespace std;
bool graph[MAX_N + 1][MAX_N + 1];
int setsf[MAX_N + 1], setsfn;
int setst[MAX_N + 1], setstn;
__int64 expv[MAX_N + 1];
int maxK;
//curState表示当前状态,即当前被选的shapes
//curPos表示当前需要考虑的decoration的序号，即考虑改decoration是否被选
//num表示当前已选decoration值
void dfs(__int64 curState, int curPos, int num)
{
    //已经遍历完所有decoration
    if(curPos > setstn)
    {
        //更新最大成员数
        if(num > maxK) maxK = num;
        return;
    }
    int countv = 0, tid = setst[curPos];
    int newState = curState, i;
    //遍历所有的shapes，统计当前decoration在curState中可以找到多少自己对应的shapes
    for(i = 1; i <= setsfn; i++)
    {
        int fid = setsf[i];
        //输入中存在fid tid
        if(graph[tid][fid])
        {
            //如果当前已选shapes中已经存在，则统计值+1
            if(curState & expv[fid])
                countv++;
            //初始状态特殊处理
            if(num == 0)
            {
                countv++;
                //需要加入初始decoration所有对应的shapes到状态中
                newState |= expv[fid];
            }
        }
        //不是初始状态的话需要从当前状态中去除当前当前decoration无法映射的shapes
        else if(num != 0 && (curState & expv[fid]))
            newState -= expv[fid];
    }
    dfs(curState, curPos + 1, num);
    if(countv >= num + 1) dfs(newState, curPos + 1, num + 1);
}
int main()
{
    int caseN, n, i, j;
    expv[0] = 1;
    for(i = 1; i <= MAX_N; i++)
        expv[i] = expv[i - 1] * 2;
    scanf(""%d"", &caseN);
    while(caseN--)
    {
        maxK = INT_MIN;
        setstn = setsfn = 0;
        memset(graph, 0, sizeof(graph));
        scanf(""%d"", &n);
        int from, to;
        for(i = 1; i <= n; i++)
        {
            scanf(""%d%d"", &from, &to);
            graph[to][from] = true;
            for(j = 1; j <= setsfn; j++)
                if(setsf[j] == from) break;
            if(j == setsfn + 1) setsf[++setsfn] = from;
            for(j = 1; j <= setstn; j++)
                if(setst[j] == to) break;
            if(j == setstn + 1) setst[++setstn] = to;
        }
        dfs(0, 1, 0);
        printf(""%d/n"", maxK);
    }
    return 0;
} 
"
159,"POJ 1027_乐吾天_百度空间

 题意：
一个长15宽10的格子内，有R,G,B三种颜色的球。颜色相同的一片球（不少于2个球）可以消除，每一片球用最左边的最下面的球表示。消除以后，上面的球会落下来。如果有空列，其右边的列左移补上空列。每消除一次，得分为(消除的球数-2)^2。如果可以消除同样球数的方法不唯一，则消除代表球最左边的最下面的那一片。如果最后全部消除，则再加1000分。请问这样，最后剩下多少球，得多少分。
思路：
有个同学说这个就是Windows Mobile里面的Bubble Breaker那个游戏，有兴趣的可以去看看那个游戏。
 while( 没有结束 ){ 找出要消除的那一片 删除那一片} 
思路不难，可是我做了整整一天，充分显示代码能力太差。
不过，这里面一些优化还是值得提一下。首先是在bfs的时候，就记录下最佳消除的是哪些球，消除的时候不再进行bfs。我看discuss和网友不少用的dfs，我觉得那样肯定不快，因为递归太多了。另外，每消除一片球，可以压缩格子，也就是我的程序中的top和right_，用于记录目前整个地图的右上角。这样每次也能少搜索很多。
这题被列为较难的模拟题。我觉得找时间还可以再做，练习代码能力。
错误：
1. 行列容易写反
2. 消除函数有些地方考虑不全面，比如要判断一个格子如果消除了，不能进行bfs
3. 全局变量有点多，后来自己都搞不清什么含义了
统计：
5418B，创记录了。276k, 250ms
 #include <iostream>//#include <cstdio>#include <cmath>#include <string>//#include <memory>#define F(i,a,b) for( int i=a;i<=b;i++)#define FD(i,a,b) for (int i=a;i>=b;i--)using namespace std;struct P2{ int x, y; P2() { } P2(int a, int b) { x = a ; y = b; } friend ostream& operator << (ostream& os, const P2& b) { os << b.x << "","" << b.y ; return os; }};bool mk[10][15];int map[10][15], points, top = 9, right_ = 14, removed;P2 tempQ[151], Q[151], p, tempp;int move[ 4 ][ 2 ] = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };char Color[ 4 ] = { 'R', 'G', 'B', ' ' };void scan(){ string str; memset(map, 0, sizeof( map ) ); FD(i, 9, 0) { cin >> str; F(j, 0, 14) { switch ( str[ j ] ) { case 'R': map[ i ][ j ] = 0; break; case 'G': map[ i ][ j ] = 1; break; case 'B': map[ i ][ j ] = 2; break; } } }}// return the block size, modify mk,int bfs(P2 pp){ P2 t; int now = 0, last = 1, left = 20, down = 20; tempQ[ 0 ] = pp; mk[ pp.x ][ pp.y ] = true; while ( now < last ) { pp = tempQ[ now ]; if ( pp.y < left || ( pp.y == left && pp.x < down ) ) { left = pp.y; down = pp.x; } F(i, 0, 3) { t = P2( pp.x + move[ i ][ 0 ], pp.y + move[ i ][ 1 ]); if ( t.x >= 0 && t.x <= top && t.y <= right_ && t.y >= 0 ) { if ( !mk[ t.x ][ t.y ] && map[ t.x ][ t.y ] != 3 && map[ t.x ][ t.y ] == map[ pp.x ][ pp.y ] ) { //cout << ""added: "" << t.x << "","" << t.y << endl; tempQ[ last++ ] = t; mk[ t.x ][ t.y ] = true; } } } now++; } tempp = P2(down, left) ; return last;}bool findMax(){ memset( mk, 0, sizeof( mk ) ) ; removed = 0; F(i, 0, top) { F(j, 0, right_) { if (map[ i ][ j ] == 3) { mk[ i ][ j ] = true; continue; } if ( !mk[ i ][ j ] ) { //cout << i << "","" << j << "": ""; int t = bfs( P2(i, j) ); //cout << t << endl; if (t > removed) { F(k, 0, t-1) Q[k] = tempQ[k]; p = tempp; removed = t; } if (t == removed) { if (tempp.y < p.y || (tempp.y == p.y && tempp.x < p.x) ) { F(k, 0, t-1) Q[k] = tempQ[k]; p = tempp; removed = t; } } } } } points = (int)( pow( (removed - 2.0), 2.0 ) + 0.1 ); //cout << ""Max: "" << Max << endl; if ( removed > 1 ) return true; return false;}void disp(){ cout << endl; FD(i, top, 0) { F(j, 0, right_) cout << Color[ map[i][j] ] ; //cout << map[i][j]; cout << endl; } cout << endl;}void Cancel(P2 p){ F(i, 0, removed - 1) { P2 t = Q[ i ]; map[ t.x ][ t.y ] = 3; } //check column F(i, 0, right_) { int newp = 0, oldp = 0; while (oldp <= top) { if (map[ oldp ][ i ] != 3) map[ newp++ ][ i ] = map[ oldp ][ i ]; oldp++; } while (newp <= top) map[ newp++ ][ i ] = 3; } // check horizontal int newp = 0, oldp = 0; while (oldp <= right_ ) { bool empty = true; F(i, 0, top) if (map[ i ][ oldp ] != 3) { empty = false; break; } if ( !empty ) { F(i, 0, top) map[ i ][ newp ] = map[ i ][ oldp ]; newp++; } oldp ++; } while (newp <= right_) { F(i, 0, top) map[ i ][ newp ] = 3; newp++; } // modify int top_ = 0, right__ = 0; F(i, 0, top) F(j, 0, right_) { if (map[ i ][ j ] != 3 ) { if ( i > top_) top_ = i; if ( j > right__) right__ = j; } } top = top_, right_ = right__;}int main(){ int T, sum, leftBall, c, steps; cin >> T; F(t, 1, T) { points = 0.0, removed = 0, top = 9, right_ = 14, leftBall = 150, sum = 0, steps = 0; printf(""Game %d: \n\n"", t ); scan(); while ( findMax() ) { sum += points; leftBall -= removed; c = map[ p.x ][ p.y ]; Cancel( p ); steps++; printf( ""Move %d at (%d,%d): removed %d balls of color %c, got %d points.\n"", steps, p.x + 1, p.y + 1, removed, Color[ c ], points ) ; } if (leftBall == 0) sum += 1000; printf(""Final score: %d, with %d balls remaining.\n\n"", sum, leftBall); } return 0;} 
推荐文章:

1. 
poj 1975

2. 
POJ 3674 Super Assassin

3. 
ACM（poj上的）-题型分类的代码（转1）

4. 
ACM（poj）-题型分类的代码（转2）

5. 
*LS4* 【重做】 Pku Poj 1095 Trees Made to Order 卡特兰数

6. 
poj 2251 Dungeon Master(6方向广搜)

7. 
poj 1950 Dessert(深搜 好像有爆搜过的 ⊙﹏⊙b汗 郁闷了两天 作出来的 晕死)

8. 
poj 1703

9. 
教训－－poj 3667

10. 
POJ分类

"
162,"ZOJ 1123 Triangle Encapsulation_庒谐的空间_百度空间

求解位于三角形内部的整数坐标点,由于三角形特别小(x-y坐标的范围是-9……9),使用一个平行于坐标轴的矩形把三角形套起来.显然矩形的边界是三角形三个顶点坐标中的最大,最小值.
采用计算三角形面积的办法判断点是否在三角形内部,如果顶点p在三角形内部,该店与三角形三个顶点构成的三个三角形面积的和等于大三角形的面积,否则不相等.如果顶点p在三角形的边界上,则三个三角形中,必然有一个面积为0.但x-y坐标的范围是-9……9,直接用xy当做数组的下表,负数值是非法的,所以在坐标上加上10即可,输出时在减去10.
在矩形区域内的点(i,j),如果标记数组为1,则输出该坐标,否则为空输出域.
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
int min(int a,int b,int c)                                    //计算最小值
{
    int tmp=(a<b)?a:b;
    return (tmp<c)?tmp:c;
}
int max(int a,int b,int c)                                   //计算最大值
{
    int tmp=(a>b)?a:b;
    return (tmp>c)?tmp:c;
}
int area(int a,int b,int c,int d)                            //计算面积,叉乘的方法,是实际面积的两倍
{
    int s=a*d-b*c;
    if(s<0)
       s=-s;
    return s;
}
int main()
{
    int x1,x2,x3,y1,y2,y3;                                  //三角形三个顶点的坐标
    int right,top,left,below;                               //套住三角形的矩形边界
    int minx,miny,maxx,maxy;                                //套住三角形内部整数点的矩形边界
    int ss,s1,s2,s3;                                        //三角形面积
    char map[50][50];                                       //保存坐标点在三角形内外的状态
    int border;                                             //控制行末的空输出域
    int i,j;
    printf(""Program 4 by team X\n"");
    while(scanf(""%d%d%d%d%d%d"",&x1,&y1,&x2,&y2,&x3,&y3)!=EOF)
    {
          minx=miny=10;
          maxx=maxy=-10;
          ss=area(x2-x1,y2-y1,x3-x1,y3-y1);
          memset(map,0,sizeof(map));
          right=max(x1,x2,x3);                             //计算包含三角形的矩形
          top  =max(y1,y2,y3); 
          left =min(x1,x2,x3);
          below=min(y1,y2,y3);
          for(i=left;i<=right;i++)                        //判断该矩形内那些点是三角形内部的整数点 
           for(j=below;j<=top;j++)
           {
                s1=area(x1-i,y1-j,x2-i,y2-j);
                s2=area(x1-i,y1-j,x3-i,y3-j);
                s3=area(x2-i,y2-j,x3-i,y3-j);
                if(s1 && s2 && s3 &&(s1+s2+s3)==ss)       //若某个面积为0,表示该点在边界上 
                {
                      map[i+10][j+10]=1;
                      if(i+10<minx)                       //计算包围三角形内整点的矩形 
                         minx=i+10;
                      if(i+10>maxx)
                         maxx=i+10;
                      if(j+10>maxy)
                         maxy=j+10;
                      if(j+10<miny)
                         miny=j+10;
                }
           } 
          for(j=maxy;j>=miny;j--)
          {
                for(i=minx;i<=maxx;i++)                  //计算行末的右边界
                 if(map[i][j])
                    border=i;
                for(i=minx;i<=border;i++)
                {
                    if(i!=minx)
                       printf("" "");
                    if(map[i][j])
                       printf(""(%2d, %2d)"",i-10,j-10);   
                    else 
                       printf(""        "");              //9个空格
                }
                printf(""\n"");
          }
          printf(""\n"");
    }
    printf(""End of program 4 by team X\n"");
    system(""pause"");
    return 0;
}
"
166,"poj 3533  Nim积_年轻_百度空间

(i) The nim-product of a Fermat 2-power and any smaller number is their ordinary product.
(ii) The nim-product of a Fermat 2-power with itself is the Fermat 2-power times 3/2 in the ordinary sense.

竟然又因为位运算的优先级问题找了好久，因该是 if((i&1) == 0) 而不是 if(i&1 == 0)， 鄙视自己~~晚饭都耽误了~~
#include<iostream>
#include<cstring>

#include<cstdio>

using namespace std;

const int N = 1001;

int sg[N];

int gg[N][N];

bool flag[N];

int mex(int k)

{

   memset(flag,false,sizeof(flag));

   for(int i = 1; i < k; i++)

   {

      if(sg[i])flag[sg[i]] = true;

   }

   for(int i = 1; i < N; i++)

   {

      if(!flag[i])return i;

   }

}

int f(int,int);//声明一下，因为f与g互相嵌套调用

int g(int x, int y)//计算2^x与2^y的nim积

{

   if(gg[x][y] != -1)//查备忘录

   {

      return gg[x][y];

   }

   if(!x)//x==0也就是1与2^y的nim积，等于2^y

   {

      return gg[x][y] = 1<<y;

   }

   if(!y)//同上

   {

      return gg[x][y] = 1<<x;

   }

   int ans=1,k=1,t;

   int x1=x,y1=y;

   while(x||y)//再将x和y分为二进制，这里计算那些普通乘积的（即对应二进制位不同的）

   {

      t = 1<<k;//从此位得到的最终的数2^k

      if((x&1||y&1) && !((x&1)&&(y&1)))//该位不同

      {

         ans *= t;

      }

      x >>= 1;

      y >>= 1;

      k <<= 1;//从此位得到的指数(本身也是2的幂)

   }

   k = 1;

   x = x1;

   y = y1;

   while(x||y)//计算那些相同的fermat 2-power 数，与已得出的数的nim积

   {

      t = 1<<k;

      if((x&1)&&(y&1))//该位相同

      {

         ans = f(ans,t/2*3);

      }

      x >>= 1;

      y >>= 1;

      k <<= 1;//从此位得到的指数(本身也是2的幂)

   }

   return (gg[x1][y1] = ans);

}

int f(int x, int y)//计算二维的nim积

{

   if(!x || !y)return 0;

   if(x == 1)return y;

   if(y == 1)return x;

   int ans = 0;

   for(int i = x,a = 0; i; i>>=1,a++)//完成（将x和y分解后）按分配律计算其积

   {

      if((i&1)==0)continue;//该位（bit）是1才计算，否则跳过

      for(int j = y,b = 0; j; j>>=1,b++)

      {

         if((j&1)==0)continue;

         ans ^= g(a,b);

      }

   }

   return ans;

}

int main()

{

   int x,y,z;

   int n,ans;

   memset(gg,-1,sizeof(gg));

   for(int i = 0; i < N; i++)//先计算出一维的sg值

   {

      sg[i] = mex(i);

   }

   while(scanf(""%d"",&n) != EOF)

   {

      ans = 0;

      while(n--)

      {

         scanf(""%d%d%d"",&x,&y,&z);

         ans ^= f(sg[x],f(sg[y],sg[z]));

      }

      puts(ans ? ""No"" : ""Yes"");

   }

   return 0;

}

"
168,"POJ：2713  肿瘤面积_小_船__百度空间

肿瘤面积
Time Limit:1000MS Memory Limit:65536K
Total Submit:445 Accepted:189
Description 
在一个正方形的灰度图片上，肿瘤是一块矩形的区域，肿瘤的边缘所在的像素点在图片中用0表示。其它肿瘤内和肿瘤外的点都用255表示。现在要求你编写一个程序，计算肿瘤内部的像素点的个数（不包括肿瘤边缘上的点）。已知肿瘤的边缘平行于图像的边缘。
Input 
只有一个测试样例。第一行有一个整数n，表示正方形图像的边长。其后n行每行有n个整数，取值为0或255。整数之间用一个空格隔开。已知n不大于100。
Output 
输出一行，该行包含一个整数，为要求的肿瘤内的像素点的个数。
Sample Input 
Sample Output 
Source 
POJ：2713
C语言代码：
1

Sample Result: 
5255 255 255 255 255255 0 0 0 255255 0 255 0 255255 0 0 0 255255 255 255 255 255 #include <stdio.h>int main(){ int a[100][100],i,j,t; int m,n,x,y,sum=0,sum1=0; scanf(""%d"",&t); for(i=0;i<t;i++) { for(j=0;j<t;j++) scanf(""%d"",&a[i][j]); } for(i=0;i<t;i++) { for(j=0;j<t;j++) if(a[i][j]==0) {n=i;m=j;} } for(x=n,y=m;x>=0;x--) { if(a[x][y]==0) sum=sum+1;/计算出宽/ else break; } for(x=n,y=m;y>=0;y--) { if(a[x][y]==0) sum1=sum1+1;/计算出长/ else break; } printf(""%d\n"",sum*sum1-2*(sum+sum1-2)); return 0;}"
169,"POJ 3640 Conformity - 低智商呀>_< - 博客频道 - CSDN.NET

题意：n个学生，每人5门课程代号（100~499）的组合，定义这些课程组合的重复次数为受欢迎度。问选受欢迎度最大的课程组合的学生人数是多少。
题解：将每个学生所选的5门课进行从小到大排序，拼起来组成一个15位的数。即：
 
 for(int j=0;j<5;j++)
                  temp=temp*1000+x[j];
 
 由于变换之后的数太大，所以要哈希一下在存储。接下来再判重即可。
 
 #include<algorithm>
 #include<iostream>
 #include<cstring>
 #include<cstdio>
 using namespace std;
 const long long MOD=100007;
 long long Hash[MOD],pos[MOD],pop[MOD],x[6];
 int Getkey(long long num){
     int temp=num%MOD;
     while(Hash[temp]!=-1&&Hash[temp]!=num)
         temp=(temp+1)%MOD;
     return temp;
 }
 int main()
 {
     int n;
     while(scanf(""%d"",&n),n){
         long long ans=0;
         memset(pop,0,sizeof(pop));
         memset(Hash,-1,sizeof(Hash));
         for(int i=0;i<n;i++){
             for(int j=0;j<5;j++)
                 scanf(""%I64d"",&x[j]);
             sort(x,x+5);
             long long temp=0;
             for(int j=0;j<5;j++)
                 temp=temp*1000+x[j];
             int  ps=Getkey(temp);
             Hash[ps]=temp;
             ans=max(ans,++pop[pos[i]=ps]);
         }
         int cnt=0;
         for(int j=0;j<n;j++){
             if(pop[pos[j]]==ans)
                 cnt++;
         }
         printf(""%d\n"",cnt);
     }
     return 0;
 } 

"
171,"poj 3517 - Missa - 博客园

约瑟夫环问题
http://www.cnblogs.com/alex4814/archive/2011/09/11/2173739.html
约瑟夫问题：
用数学方法解的时候需要注意应当从0开始编号，因为取余会等到0解。
实质是一个递推，n个人中最终存活下来的序号与n-1个人中存活的人的序号有一个递推关系式。
分析：
假设除去第k个人。
0, 1, 2, 3, ..., k-2, k-1, k, ..., n-1　　//original sequence (1)
0, 1, 2, 3, ..., k-2,      , k, ..., n-1　　//get rid of kth person (2)
k, k+1, ..., n-1,    0,    1,        ..., k-2　　//rearrange the sequence (3)
0, 1,     ..., n-k-1, n-k, n-k+1, ..., n-2　　//the n-1 person (4)
我们假设f(n)的值为n个人中最后存活的人的序号，则
注意到(2)式(3)式(4)式其实是同一个序列。
注意(1)式和(4)式，是同一个问题，不同的仅仅是人数。
假设我们已知f(n-1)，即(4)式中最后剩下的人的序号，则(3)式所对应的序号，就是f(n)，即(1)式n个人中最后存活的序号。
而从(3)(4)式中我们不难发现有这样一个递推式：
f(n) = (f(n-1) + k) % n
显然，f(1) = 0。
于是递推得f(n)
 

 
 
 View Code  
  
   1 // File Name: 3517.cpp
 2 // Author: Missa
 3 // Created Time: 2013/2/15 星期五 20:22:11
 4 
 5 #include<iostream>
 6 #include<cstdio>
 7 #include<cstring>
 8 #include<algorithm>
 9 #include<cmath>
10 #include<queue>
11 #include<stack>
12 #include<string>
13 #include<vector>
14 #include<cstdlib>
15 #include<map>
16 #include<set>
17 using namespace std;
18 #define CL(x,v) memset(x,v,sizeof(x));
19 
20 int n,k,m;
21 
22 int main()
23 {
24     while(~scanf(""%d%d%d"",&n,&k,&m))
25     {
26         if(n==0) break;
27         int x=0,i=2;
28         for(;i<n;i++)
29             x=(x+k)%i;
30         x=(x+m)%i+1;
31         printf(""%d\n"",x);
32     }
33     return 0;
34 } 
  
 

"
172,"POJ-2057 The Lost House 贪心在动态规划中的应用 - 沐阳 - 博客园

这题题意在代码中有解释, 求的最优值初看不太好理解. 求的是给定一个决策下的找到房子的最优期望值. 那么这题其实要做的就是一件事那就是给所有的分叉口的选择拍一个次序出来.根据这个次序我们就能够给出这只蜗牛在碰到有所情况下的唯一的一条爬行路线. 题目就是当我们安排好这样的这个次序后, 假设房子在各个叶子节点时, 需要走的路径总长最小. 这里的每一棵子树, 在枚举的过程中总是充当着不同的角色, 当枚举到的房子在自己的子树中时, 其要考虑能够安排最快的路径让蜗牛找到. 当没有在自己的子树时又不想让其放在前面让蜗牛白忙活一场. 所以综合一看, 貌似是一个很复杂的问题. 但是这题就是在如何安排子节点访问顺序时满足一个贪心策略. 这点在代码中会有介绍. 当我们能够利用一个排序安排出足够好的序列出来的时候. 在通过动态规划, 最终由子问题最优得到了全局最优.
使用yefeng1627推荐的公式生成利器生成的动态规划方程:
 
    当 j 是 i 的子节点时,  特别的,当为 i 叶子节点时有 
 
   当 j 是 i 的子节点时, 特别的, 当 i 为叶子节点时有 
代码如下:
 
 
 #include <cstdlib>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
/*
题意:有一只蜗牛爬上树睡着之后从树上掉下来,发现后面的""房子""却丢在了树上面, 现在这
     只蜗牛要求寻找它的房子,它又得从树根开始爬起,现在要求一条路径使得其找到房子
     所要爬行的期望距离最小. 爬行距离如下计算, 题目规定每一个分支和枝末都看做是
     一个节点, 这些节点之间的距离都是1, 在分支上可能会有热心的毛毛虫, 这些毛毛虫
     会如实的告诉蜗牛他之前是否经过这条路径, 也正是因为毛毛虫, 因此询问毛毛虫的顺
     序使得这题的期望是不同的. 输入数据时给定的一个邻接关系,通过上一个节点来构图 
     同时字符 'Y'表示该点有毛毛虫, 字符'N'表示该点 
解法:dp[i][0]表示以该点为根的节点找不到房子时要爬行最少的距离, 这个值有什么用呢?
     这个值就是用去计算房子落在其他叶子节点时,其对爬行距离的负面效应有多大.
     dp[i][1]表示以该点为根的节点在选择好所有分支点的爬行方案后,枚举完房子落在该
     子树所有叶子节点上的总爬行距离的最小值,这是一个值告诉我们这棵子树对爬行距离
     的正面效应有多大.那么有动态方程:  ch[x]表示x节点一共有多少个孩子节点 
     dp[i][0] = sum{ dp[j][0] + 2 } 当i没有毛毛虫且要求j是i的孩子节点,这个是很好
     理解的, 多出来的2就是连接该孩子节点的边来回的两次 
     dp[i][0] = 0 当该点有毛毛虫的时候, 原因是因为毛毛虫会告诉我们这点下面没有房子
     当一个节点时叶子节点的时候,那么 dp[i][0] = dp[i][1] = 0; 
     要明确dp[i][1]是表示在遇到分支选择的先后顺序决定后,我们枚举房子在其各个叶子
     上的所要爬行的总距离
     dp[i][1] = sum{ (sum{dp[1..j-1][0]+2}+1}*ch[j] +  dp[j][1]}, 其中j是i的孩子 
     这个方程要怎么去理解呢? 意思翻译过来就是遍历i的孩子中的j号子树所有叶子节点所
     要爬行的最短距离.其值就是: 
     前面[1, j-1]号子树没有找到节点所爬行的最短距离加上走了的多余的边再加上遍历j
     号子树所有叶子节点所爬行的最短距离, 那么这里显然谁前谁后就会决定最后值的大小
     现在只考虑序列中任意两棵子树A,B, 如果A放前面的话, 枚举完所有房子所在位置后的总距离就是
     ans1 = (ch[A] + dp[A][1]) + ((dp[A][0]+2)*ch[B] + dp[B][1] + ch[B])
     前一个括号是假设枚举房子落在A的所有叶子上, 后面的扩后是枚举在B的所有叶子上 
     ans2 = (ch[B] + dp[B][1]) + ((dp[B][0]+2)*ch[A] + dp[A][1] + ch[A])
     ans1 - ans2 = (dp[A][0]+2)*ch[B] - (dp[B][0]+2)*ch[A]
*/
int N, head[1005], idx, at[1005];
int dp[1005][2], ch[1005];
struct Node {
    int v, yes, next;    
}e[1005];
void insert(int x, int y) {
    ++idx;
    e[idx].v = y, e[idx].next = head[x];
    head[x] = idx; // 建立邻接链表 
}
bool cmp(int a, int b) {
    return (dp[a][0]+2) * ch[b] < (dp[b][0]+2) * ch[a];
}
int dfs(int x) {
    if (head[x] == -1) { //说明x肯定是一个叶子节点 
        dp[x][1] = dp[x][0] = 0;
        return ch[x] = 1; // 返回时叶子节点的个数 
    }
    vector<int>v;
    for (int i = head[x]; i != -1; i = e[i].next) {
        ch[x] += dfs(e[i].v);
        v.push_back(e[i].v);
    }
    sort(v.begin(), v.end(), cmp);
    for (int i = 0; i != v.size(); ++i) {
        dp[x][1] += dp[x][0]*ch[v[i]] + dp[v[i]][1] + ch[v[i]];
        // dp[x][0] 就相当于dp方程中的sum{ dp[1..j-1][0] +2 }
        dp[x][0] += dp[v[i]][0] + 2;
    }
    if (at[x]) {
        dp[x][0] = 0;    
    }
    return ch[x];
}
int main() {
    int pre;
    char str[5]; 
    while (scanf(""%d"", &N), N) {
        idx = -1;
        memset(head, 0xff, sizeof (head));
        memset(dp, 0, sizeof (dp));
        memset(ch, 0, sizeof (ch));
        scanf(""%d %s"", &pre, str); // 这两个的值已经毫无意义了 
        for (int i = 2; i <= N; ++i) {
            scanf(""%d %s"", &pre, str);
            at[i] = str[0] == 'Y';
            insert(pre, i);
        }
        dfs(1); // 1号节点永远是根节点
        printf(""%.4lf\n"", 1.*dp[1][1]/ch[1]);
    }
    return 0;    
} 
 

"
175,"PKU_1112(补图，背包DP)_Otaku_geek_百度空间

PKU 1112:PKU上一道比较经典的题，以前一直做不来，今天总算把它过掉了，分析题目的条件可以建立这样一个无向图：如果A不认识B或者B不认识A，那么这两个必然是两个组的人，因为题目要求一个组的所有人都必须两两认识，这样就可以在原图的基础上建立一个补图，对于每一个点我们可以进行这样一个操作，把它自己标记为1，并且把与他相邻的点都标记为2，相同的点不能重复标记，如果在标记的过程中发现某个点即可以标记为1又可以标记为2，则不存在解，这样一个标记的过程可以用简单的DFS完成，完成这样一个操作后，我们对于每次DFS的过程都可以得到两个数，一个数是标记为1的点的数量，另一个则是标记为2的点的数量，假如图中存在n个连通分量，则我们就可以得到n组这样的数据，然后就是背包DP了，每次都在上一次的基础上选择放入第一个或者第二个数，注意这两个DP是互相独立的，即他们不会互相影响，最后再进行一下路劲压缩就可以得到最后的答案了，AC了之后发现速度很慢，感觉我的方法复杂度也就是100*100，怎么会这么慢呢，忘大牛指教～～～

 #include <cstdio>

 #include <cstring>

 #include <cmath>

 #include <vector>

 using namespace std;

 const int N = 105;

 bool _map[N][N];//原图

 vector<int> _revMap[N];//补图

 bool _visited[N];

 int _n;

 int _cnt[N][2];

 int _col[N];

 int _now;

 int _sumOne;

 int _sumTwo;

 int _peo[N][2][N];

 int _res[N][N];

 int _min;

 int _path[N][N];

 bool _dp[N][N];

 bool _flg[N];

 bool _noSol;

 int ABS(int x) {

     if (x<0) x *= -1;

     return x;

 }

 void CreateRevMap()

 {

     int i, j;

     for (i=1; i<=_n; ++i) {

         for (j=1; j<=_n; ++j) {

             if (i == j) continue;

             if (!_map[i][j]) {

                 _revMap[i].push_back(j);

                 _revMap[j].push_back(i);

             }

         }

     }

 }

 void DFS(int x)

 {

     _visited[x] = true;

     if (_col[x] == 1) {

         _sumOne++;

         _peo[_now][0][_sumOne] = x;

     }

     else {

         _sumTwo++;

         _peo[_now][1][_sumTwo] = x;

     }

     int i, size = _revMap[x].size();

     for (i=0; i<size; ++i) {

         int u = _revMap[x][i];

         if (_col[u] == _col[x]) {

             _noSol = true;

             return;

         }

         if (_visited[u]) continue;

         if (_col[x] == 1) {

             _col[u] = 2;

         }

         else _col[u] = 1;

         DFS(u);

     }

 }

 void DP()

 {    

     int i, j, id;

     _dp[0][0] = true;

     for (i=1; i<_now; ++i) {

         for (id=0; id<=1; ++id) {

             for (j=_n; j>=_cnt[i][id]; --j) {

                 if (_dp[i-1][ j - _cnt[i][id] ]) {

                     _dp[i][j] = true;

                     _path[i][j] = id;

                     if (i == _now-1) {

                         if (ABS(j - _n/2) < ABS(_min)) _min = j - _n/2;

                     }

                 }

             }

         }

     }

 }

 void Print()

 {

     int ans = _min + _n/2, tmp = ans;

     int i, j, tag;

     printf(""%d"", ans);

     for (i=_now-1; i>=1; --i) {

         tag = _path[i][tmp];

         for (j=1; j<=_cnt[i][tag]; ++j) {

             printf("" %d"", _peo[i][tag][j]);

             _flg[ _peo[i][tag][j] ] = true;

         }

         tmp -= _cnt[i][tag];

     }

     ans = _n - ans;

     printf(""\n%d"", ans);

     for (i=1; i<=_n; ++i) {

         if (!_flg[i]) printf("" %d"", i);

     }

     putchar('\n');

 }

 int main()

 {

     scanf(""%d"", &_n);

     int i;

     for (i=1; i<=_n; ++i) {

         int p;

         while (scanf(""%d"", &p), p) {

             _map[i][p] = true;

         }

     }

     CreateRevMap();

     _now = 1;

     _noSol = false;

     for (i=1; i<=_n; ++i) {

         if (_visited[i]) continue;

         _sumOne = 0;

         _sumTwo = 0;

         _col[i] = 1;

         DFS(i);

         if (_noSol) break;

         _cnt[_now][0] = _sumOne;

         _cnt[_now][1] = _sumTwo;

         _now++;

     }

     if (_noSol) {

         puts(""No solution"");

         return 0;

     }

     _min = 1000;

     DP();

     Print();

     return 0;

 }

"
177,"数据结构与算法学习之十一【树状数组】(2)HOJ 2430 + HOJ 2098/POJ 2299_漫步在橙色夕阳下的路_新浪博客

 
  HOJ 2430 Counting the algorithms  
 

传送门：http://acm.hit.edu.cn/hoj/problem/view?id=2430
题意：给出2N个数，1 - N出现两次，每次去掉1个数字，得分为这个数字两次出现的距离，比如3第一次出现在86位，第二次出现在88位，可以得2分，给出能得的最大分。
输入：2N个数。
输出：最大分。
思路：从左到右扫描或者从右到左扫描，将外层的数字先删除，再删除内层的数字即可。需要记录每个数字第一次出现和第二次出现的位置。初始化的时候，将每个点设置为1，这样查询的时候就是就是两者的距离，当数字被删除之后，将这两个点减1，变成0，这样不影响其他数字的计算。
程序：
 

 #include<cstdio>
 #include<cstring>
 const int MAX = 102400;
 class TreeArray {
 private:
     int N, c[MAX * 2];
     int lowbit(int x) { return x & (-x); }
     int sum(int x) {
         int ret = 0;
         for (int i = x; i > 0; i -= lowbit(i)) {
             ret += c[i];
         }
         return ret;
     }
 public:
     void init(int n) {
         N = n;
         memset(c, 0, sizeof(c));
     }
     void update(int x, int v) {
         for (int i = x; i <= N; i += lowbit(i)) {
             c[i] += v;
         }
     }
     int query(int s, int e) { return sum(e) - sum(s); }
 };
 TreeArray ta;
 int main() {
     int n, first[MAX], second[MAX], arr[MAX * 2];
     while (scanf(""%d"", &n) == 1) {
         n *= 2;
         ta.init(n);
         memset(first, 0, sizeof(first));
         for (int i = 1; i <= n; i++) {
             scanf(""%d"", &arr[i]);
             if (first[arr[i]]) {
                 second[arr[i]] = i;
             } else {
                 first[arr[i]] = i;
             }
             ta.update(i, 1);
         }
         int ans = 0;
         for (int i = n; i > 0; i--) {
             if (!first[arr[i]]) {
                 continue;
             }
             ans += ta.query(first[arr[i]], second[arr[i]]);
             ta.update(first[arr[i]], -1);
             ta.update(second[arr[i]], -1);
             first[arr[i]] = 0;
         }
         printf(""%d\n"",ans);
     }
     return 0;
 }
 
 
  HOJ 2098/POJ 2299 Ultra-QuickSort（树状数组+离散化+HOJ坑爹）  
 

传送门：http://acm.hit.edu.cn/hoj/problem/view?id=2098
http://poj.org/problem?id=2299
题意：就是相邻的两个如果是逆序的话需要交换，直到最后都有序，问需要交换多少次？
输入：初始序列。
输出：需要交换的次数。
思路：不知道HOJ上的编译器有问题还是怎么样，用long long存结果就是过不了，改用double过了！！！但是这道题还是很有代表性的。首先数个数上限为500000，但是数据范围非常大，远远超出了这个范围，需要用到离散化，说白了就是把这n个数映射到1 – n上，来表示他们的相对大小，比如1000，1，100，10这样在存储的时候就可以变为4，1，3，2，大大降低了需要的空间。然后就是从左到右扫描4,1,3,2，累加每次出现的时候已经有多少个比它大的数组出现了，可以通过当前个数 – 树状数组统计的比它小或者等于它的个数来算出。
程序：
 

 #include <cstdio>
 #include <cstring>
 #include <algorithm>
 using namespace std;
 const int MAX = 512000;
 class TreeArray {
 private:
     int N;
     long long c[MAX];
     int lowbit(int x) {
         return x & (-x);
     }
 public:
     void init(int n) {
         N = n;
         memset(c, 0, sizeof(c));
     }
     void update(int x, int v) {
         for (int i = x; i <= N; i += lowbit(i)) {
             c[i] += v;
         }
     }
     long long sum(int x) {
         long long ret = 0;
         for (int i = x; i > 0; i -= lowbit(i)) {
             ret += c[i];
         }
         return ret;
     }
 };
 class Array {
 public:
     long long value;
     int id;
     bool operator<(const Array& a) const { return value < a.value; }
 };
 TreeArray ta;
 Array arr[MAX];
 int a[MAX];
 int main() {
     int n;
     while (scanf(""%d"", &n) == 1 && n) {
         ta.init(n);
         for (int i = 1; i <= n; i++) {
             scanf(""%I64d"", &arr[i].value);
             arr[i].id = i;
         }
         stable_sort(arr + 1, arr + 1 + n);
         a[arr[1].id] = 1;
         for (int i = 2; i <= n; i++) {
             if (arr[i].value == arr[i - 1].value) {
                 a[arr[i].id] = a[arr[i - 1].id];
             } else {
                 a[arr[i].id] = i;
             }
         }
         double ans = 0;
         for (int i = 1; i <= n; i++) {
             ta.update(a[i], 1);
             ans += i - ta.sum(a[i]);
         }
         printf(""%.0lf\n"", ans);
     }
     return 0;
 }
"
178,"POJ 2570 Fiber Network_乐吾天_百度空间

http://hi.baidu.com/lewutian
     题意:一些公司共同拥有一个具有n个顶点的网络,给出了有关于这个网络的信息,即边<i,j>以及与这条边相连的公司,现在题目给出一条路径的起点和终点,要求求出这条路径经过哪些公司.
     很容易想到求图的传递闭包,而这里两点之间可能有多条线路,如果对每个字母(也就是每个公司)单独来进行一遍Floyd,很可能会超时,这里输入的公司标志为不同的小写字母,所以我们可以根据位运算来进行优化(使得传递闭包和每个字母都有关联,而后根据这种关联即可推出是否连通).
#include<iostream>
#include<string>
#include<cstdlib>
#include<algorithm>
using namespace std;
int mat[205][205];
char ss[30];
void Floyd(int n)                                                               //Floyd算法求解传递闭包
{
     int i,j,k;
     for(k=1;k<=n;k++)
       for(i=1;i<=n;i++)
         for(j=1;j<=n;j++)
           mat[i][j]=mat[i][j]|(mat[i][k]&mat[k][j]);
}
void slove()
{
     int i,j,u,v,n,len;
     bool flag;
     while(scanf(""%d"",&n)!=EOF)
     {
         if(n==0)
           break;
         memset(mat,0,sizeof(mat));
         while(scanf(""%d%d"",&u,&v)!=EOF)
         {
             if(u==0&&v==0)
                break;
             scanf(""%s"",ss);
             len=strlen(ss);
             for(i=0;i<len;i++)
                mat[u][v]|=(1<<(ss[i]-'a'));                                 //注意这里的建图
         }
         Floyd(n);
         while(scanf(""%d%d"",&u,&v)!=EOF)
         {
              if(u==0&&v==0)
                 break;
              flag=false;
              for(i=0;i<26;i++)
                if(mat[u][v]&(1<<i))                                        //注意这里判断连通性
                {
                    flag=true;
                    printf(""%c"",'a'+i);
                }
              if(flag)
                 printf(""\n"");
              else
                 printf(""-\n"");
         }
         printf(""\n""); 
     }
     return;
}
int main()
{
    slove();
    system(""pause"");
    return 0;
}
http://hi.baidu.com/lewutian推荐文章:

1. 
 第二次个人赛D题 Y2K Accounting Bug

2. 
 POJ 3171 Cleaning Shifts【线段树+dp】

3. 
 今天做的几个map题目

4. 
 Ultra-QuickSort【poj】2299

5. 
 Phone List【poj】3630

6. 
 并查集+优先队列==邪恶的最小生成树！

7. 
 暑假实习

8. 
 poj 2954 Triangle PICK定理 GCD欧几里得定理

9. 
 POJ 1932 XYZZY

10. 
 ACM poj 1035 Spell checker

"
180,"PKU 2887 Big String_洲洲的空间_百度空间

         很精妙的N^2模拟.....
#include<stdio.h>
struct stt
{    
    int pos;
    char ch; 
};
stt st[20008];
char s[1000008];
int main()
{
    int i,j,n,m,len;
    char ss[8];
    while(gets(s))
    {
        scanf(""%d"",&n);
        len = 0;
        for(i=0;i<n;i++)
        {
            scanf(""%s"",ss);
            if(ss[0] == 'I')
            {
                scanf(""%s%d"",ss,&m);
                getchar();
                st[len].ch = ss[0];
                st[len++].pos = m;
            }
            else
            {
                scanf(""%d"",&m);
                getchar();
                int f = 0;
                for(j=len-1;j>=0;j--)
                    if(m > st[j].pos)
                        m--;
                    else if(m == st[j].pos)
                    {    printf(""%c\n"",st[j].ch); f = 1; break;    } 
                if(!f)    
                    printf(""%c\n"",s[m-1]);
            }
        }
    }
    return 0;
}
"
181,"PKU_1200_唐武的空间_百度空间

//hash,是每个串能够对应一个关键码, 如果这样的话，内存可能会很大
#include <stdio.h>
#include <memory>
#include <cmath>
using namespace std;
const int NUM = 16000010;
bool Exit[NUM] = {false};
int hash[250];      //hash[i]表示字母char(i + 'a')对应的hash值
char input[20000000]; //存储输入，内存也许还需要大一些 
int N, NC;
void initial();
int Ans();
int main()
{
 scanf(""%d%d%s"", &N, &NC, input);
 initial();
 printf(""%d\n"", Ans());
 return 0;
}
void initial()
{
 memset(hash, -1, sizeof(hash));
 int i, counter = 0, size = strlen(input);
 for(i = 0; i < size; i++)
   if(hash[int(input[i])] == -1) //input[i]如果尚未出现
   {
    hash[int(input[i])] = counter;
    counter++;
    if(counter == NC)
     break;
   }
}
int Ans()
{
 int ans = 0;
 int size = strlen(input);
 int temp;
 int i, end = size - N, j, k;
 for(i = 0; i <= end; i++)
 {
   temp = 0;
   for(k = 0; k < N; k++)
   {
    j = i + k;
    temp = temp * NC + hash[input[j]];
   }
   if(!Exit[temp])
   {
    Exit[temp] = true;
    ans++;
   }
 }
 return ans;
}
"
185,"poj 1775 Sum of Factorials - martinblack954的日志 - 网易博客

题目链接：
http://poj.org/problem?id=1775

题意：给定一个正整数n，问能否找出几个不同的整数xi，xi>=0，使得这些xi的阶乘之和等于这个正整数。

思路：暴搜。n范围为0~1000000，而10! =3628800，所以xi的取值只是0~9。而由于各个xi不会重复，所以暴搜枚举组合最多也只是2^10=1024种方式。实际上我的做法是反过来枚举。将n拿去尝试减这些阶乘，若最后能够变成0，就说明能够找到这些xi。

PS：在这里要记住，0! = 1，所以对于n=4，有解为4=0!+1!+2!~~

#include ""stdio.h""

int a[11]={1,1,2,6,24,120,720,5040,40320,362880,3628800};

int find(int s,int t)

{

    int i;

    if(s==a[t]||s==0)

        return 1;

    for(i=t;a[i]<=s;i++)

    {

        if(find(s-a[i],i+1))

            return 1;

    }

    return 0;

}

void main()

{

    int n,t;

    while(scanf(""%d"",&n)>0&&n>=0)

    {

        t=0;

        if(n>0&&find(n,0))

            printf(""YES\n"");

        else

            printf(""NO\n"");

    }

}"
191,"POJ 2992 Divisors - bingshen的专栏 - 博客频道 - CSDN.NET

  

 Divisors
 
 
  
   
    
    Time Limit: 1000MS 
      
    Memory Limit: 65536K 
    
    
    Total Submissions: 7635 
      
    Accepted: 2098 
    
   
  
 
Description
 

 Your task in this problem is to determine the number of divisors of 
 Cnk. Just for fun -- or do you need any special reason for such a useful computation? 
 
Input
 

 The input consists of several instances. Each instance consists of a single line containing two integers n and k (0 ≤ k ≤ n ≤ 431), separated by a single space. 
 
Output
 

 For each instance, output a line containing exactly one integer -- the number of distinct divisors of 
 Cnk. For the input instances, this number does not exceed 2
 63 - 1. 
 
Sample Input
 
5 1
6 3
10 4 
Sample Output
 
2
6
16 
Source
 

 CTU Open 2005
 

  
 

 看似简单的一道题目，纠结了我好久好久。。Orz
 

  
 

 我先开始太天真了，因为数据量只有431所以我以为随便搞
 

 于是就直接把那个C(n,r)的每一个乘法分开来质因数分解。（其实对于单组数据还是很快的，不过数据量太大）
 

 然后直接超时了。紧接着又各种优化，仍然超时。后来就直接预处理打表
 

 我试了试，果然很慢，要把所有的表打出来，差不多要花5到6秒的时间
 

 而且优化了和没优化差不多。。
 

 然后后来又用到了那个C(n,r)=C(n,n-r)的公式继续优化，瞬间，时间降到了1秒多
 

 但是速度仍然很慢，还是要TLE。
 

  
 

 然后看了下discuss
 

 发现有如下公式：
 
 C(n,k+1)=C(n,k)/(k+1)*(n-k)
 

 于是就想到了递推。可惜我模拟能力严重匮乏
 

 写了很久终于搞出来了。
 

 用这个方法，我没有任何优化，688MS过掉了
 

  
 

 我的代码：
 

 #include<stdio.h>
#include<string.h>
typedef __int64 ll;
ll ans[500][500];
ll num[500];
void solve(ll n,ll flag)
{
    ll i;
    for(i=2;i*i<=n;i++)
    {
        if(n%i==0)
        {
            n=n/i;
            num[i]=num[i]+flag;
            while(n%i==0)
            {
                num[i]=num[i]+flag;
                n=n/i;
            }
        }
        if(n==1)
            break;
    }
    if(n>1)
        num[n]=num[n]+flag;
}
ll C(ll n,ll r)
{
    ll i,res=1;
    for(i=1;i<=r;i++)
        solve(n-i+1,1);
    for(i=1;i<=r;i++)
        solve(i,-1);
    for(i=0;i<500;i++)
        res=res*(num[i]+1);
	return res;
}
ll ADD(ll x,ll y)
{
	ll res=1,i;
	solve(x,-1);
	solve(y,1);
	for(i=0;i<500;i++)
		res=res*(num[i]+1);
	return res;
}
void init()
{
	ll i,j;
	ans[0][0]=1;
	ans[1][0]=1;
	ans[1][1]=1;
	for(i=2;i<432;i++)
	{
		memset(num,0,sizeof(num));
		ans[i][0]=C(i,0);
		ans[i][i]=ans[i][0];
		for(j=1;j<i;j++)
			ans[i][j]=ADD(j,i-j+1);
	}
}
int main()
{
	int n,k;
	init();
	while(scanf(""%d%d"",&n,&k)!=EOF)
		printf(""%I64d\n"",ans[n][k]);
	return 0;
}
 
 
"
193,"数据结构与算法学习之九【图论其他问题】HOJ 1303/POJ 1776 + HOJ 1115/POJ 1129 + HOJ 1266/POJ 1620_漫步在橙色夕阳下的路_新浪博客

 
  HOJ 1303/POJ 1776 Task Sequences（比赛图构造哈密顿图）  
 

传送门：http://acm.hit.edu.cn/hoj/problem/view?id=1303
http://poj.org/problem?id=1776
题意：Tom有一个machine，要做很多task，machine不能在多个task之间自由移动，只能从特定的task移动到它的后继，如果不存在后继，则要重启机器，请问怎样安排machine的工作流程，才能使得启动次数最少。
输入：task的个数，还有可达矩阵，如果可达则为1，否则为0。
输出：需要启动的次数(肯定为1)，每次启动的task个数(肯定为n)，然后task顺序。
思路：此题为求比赛图的哈密顿路，由于此有向图中任意两点都有边，则该图必有哈密顿路。
构造方法：
初始：将点1加入没有边的路中。
考虑点2。如果有（1，2），则将2加入1之后，形成1，2路，否则，将2加入1之前，形成2，1。
依次考虑点3，4，5，……，i；设形成路a1，a2，a3，……，ai；现在将i+1加入此路，如果有（i+1，a1)，则将i+1加入a1之前；否则，有（a1，i+1)，如果有（i+1，a2),则将i+1加入a1和a2之间；否则，考虑（a2,i+1)………。直到最后，如果有(ai,i+1),则将i+1加入ai之后。
程序：
 

 #include <iostream>
 #include <deque>
 using namespace std;
 const int MAX = 1024;
 int main() {
     deque<int> q;
     bool map[MAX][MAX];
     int n;
     while (cin >> n) {
         for (int i = 0; i < n; i++) {
             for (int j = 0; j < n; j++) {
                 cin >> map[i][j];
             }
         }
         q.clear();
         q.push_front(0);
         for (int i = 1; i < n; i++) {
             if (map[i][q.front()]) {
                 q.push_front(i);
             } else if (map[q.back()][i]) {
                 q.push_back(i);
             } else {
                 deque<int>::iterator iter;
                 bool first = true;
                 for (iter = q.begin(); iter != q.end(); iter++) {
                     if (!map[*iter][i] && !first) {
                         break;
                     } else {
                         first = !map[*iter][i];
                     }
                 }
                 q.insert(iter, i);
             }
         }
         cout << 1 << endl << n << endl;
         bool first = true;
         for (deque<int>::iterator iter = q.begin(); iter != q.end(); iter++) {
             if (first) {
                 first = false;
                 cout << *iter + 1;
             } else {
                 cout << "" "" << *iter + 1;
             }
         }
         cout << endl;
     }
     return 0;
 }

 
 
  HOJ 1115/POJ 1129 Channel Allocation（染色问题+四色定理）  
 

传送门：http://acm.hit.edu.cn/hoj/problem/view?id=1115
http://poj.org/problem?id=1129
题意：染色问题，相邻的repeater之间不能用相同的颜色。
输入：邻接表。
输出：最少需要的颜色（注意单数和复数形式）。
思路：最多用四种颜色即可，用DFS进行枚举即可。
程序：
 

 #include <iostream>
 #include <cstring>
 using namespace std;
 const int MAX = 26;
 int n, color[MAX];
 bool map[MAX][MAX];
 void init() {
     memset(map, false, sizeof(map));
 }
 bool check(int v) {
     for (int i = 0; i < n; i++) {
         if (map[v][i] && color[v] == color[i]) {
             return false;
         }
     }
     return true;
 }
 bool DFS(int v, int c) {
     if (c == 4 || v >= n) {
         return true;
     }
     for (int i = 1; i <= c; i++) {
         color[v] = i;
         if (check(v)) {
             if (DFS(v + 1, c)) {
                 return true;
             }
         }
         color[v] = 0;
     }
     return false;
 }
 int main() {
     while (cin >> n && n) {
         init();
         for (int i = 0; i < n; i++) {
             string s;
             cin >> s;
             for (int j = 2; j < (int)s.length(); j++) {
                 map[s[0] - 'A'][s[j] - 'A'] = map[s[j] - 'A'][s[0] - 'A'] = true;
             }
         }
         for (int i = 1; i <= 4; i++) {
             memset(color, 0, sizeof(color));
             if (DFS(0, i)) {
                 if (i == 1) {
                     cout << ""1 channel needed."" << endl;
                 } else {
                     cout << i << "" channels needed."" << endl;
                 }
                 break;
             }
         }
     }
     return 0;
 }

 
 
  HOJ 1266/POJ 1620 Phone Home（染色问题+四色定理）  
 

传送门：http://acm.hit.edu.cn/hoj/problem/view?id=1266
http://poj.org/problem?id=1620
题意：还是染色问题，就是改成频率，距离在20以内的就是算邻居。
输入：每个Tower的坐标。
输出：最少需要的颜色。
思路：还是DFS，枚举四种颜色即可。
 
程序： 

 #include <iostream>
 #include <cstring>
 using namespace std;
 const int MAX = 12;
 class Tower {
 public:
     double x, y;
     void set() {
         cin >> x >> y;
     }
     bool near(const Tower& t) const {
         return ((x - t.x) * (x - t.x) + (y - t.y) * (y - t.y)) <= 20 * 20;
     }
 };
 int n, no = 0, color[MAX];
 bool map[MAX][MAX];
 Tower tower[MAX];
 void init() {
     memset(map, false, sizeof(map));
 }
 bool check(int v) {
     for (int i = 0; i < n; i++) {
         if (map[v][i] && color[v] == color[i]) {
             return false;
         }
     }
     return true;
 }
 bool DFS(int v, int c) {
     if (c == 4 || v >= n) {
         return true;
     }
     for (int i = 1; i <= c; i++) {
         color[v] = i;
         if (check(v)) {
             if (DFS(v + 1, c)) {
                 return true;
             }
         }
         color[v] = 0;
     }
     return false;
 }
 int main() {
     while (cin >> n && n) {
         init();
         for (int i = 0; i < n; i++) {
             tower[i].set();
         }
         for (int i = 0; i < n - 1; i++) {
             for (int j = i + 1; j < n; j++) {
                 if (tower[i].near(tower[j])) {
                     map[i][j] = map[j][i] = true;
                 }
             }
         }
         for (int i = 1; i <= 4; i++) {
             memset(color, 0, sizeof(color));
             if (DFS(0, i)) {
                 cout << ""The towers in case "" << ++no << "" can be covered in "" << i << "" frequencies."" << endl;
                 break;
             }
         }
     }
     return 0;
 }

"
197,"POJ 3176 Cow Bowling - c++语言程序开发技术文章_c++编程 - 红黑联盟

Cow Bowling 

 Time Limit: 1000MS
   
  Memory Limit: 65536K
 

 Total Submissions: 11302
   
  Accepted: 7399
 

 Description  www.2cto.com
 

  
 

 The cows don't use actual bowling balls when they go bowling. They each take a number (in the range 0..99), though, and line up in a standard bowling-pin-like triangle like this: 
 

  
 

           7
 

  
 

  
 

  
 

         3   8
 

  
 

  
 

  
 

       8   1   0
 

  
 

  
 

  
 

     2   7   4   4
 

  
 

  
 

  
 

   4   5   2   6   5
 

 Then the other cows traverse the triangle starting from its tip and moving ""down"" to one of the two diagonally adjacent cows until the ""bottom"" row is reached. The cow's score is the sum of the numbers of the cows visited along the way. The cow with the highest score wins that frame. 
 

  
 

 Given a triangle with N (1 <= N <= 350) rows, determine the highest possible sum achievable.
 

 Input
 

  
 

 Line 1: A single integer, N 
 

  
 

 Lines 2..N+1: Line i+1 contains i space-separated integers that represent row i of the triangle.
 

 Output
 

  
 

 Line 1: The largest sum achievable using the traversal rules
 

 Sample Input
 

  
 

 5
 

 7
 

 3 8
 

 8 1 0
 

 2 7 4 4
 

 4 5 2 6 5
 

 Sample Output
 

  
 

 30
 

 Hint
 

  
 

 Explanation of the sample: 
 

  
 

           7
 

  
 

          *
 

  
 

         3   8
 

  
 

        *
 

  
 

       8   1   0
 

  
 

        *
 

  
 

     2   7   4   4
 

  
 

        *
 

  
 

   4   5   2   6   5
 

 The highest score is achievable by traversing the cows as shown above.
 

 Source
 

  
 

 USACO 2005 December Bronze
 

 考察点：DP 问题
 

 [cpp] 
 

 #include <stdio.h>  
 

 #include <string.h>  
 

 #include <math.h>  
 

 int a[400][400];  
 

 int dp[400][400];  
 

 int main()  
 

 {  
 

     int i,j,n,m,s,t;  
 

     scanf(""%d"",&n);  
 

     for(i=0;i<=n-1;i++)  
 

     {  
 

         for(j=0;j<=i;j++)  
 

         {  
 

             scanf(""%d"",&a[i][j]);  
 

         }  
 

     }  
 

     memset(dp,0,sizeof(dp));  
 

     for(i=0;i<=n-1;i++)  
 

     {    www.2cto.com
 

         dp[n-1][i]=a[n-1][i];  
 

     }  
 

     for(i=n-2;i>=0;i--)  
 

     {  
 

         for(j=0;j<=i;j++)  
 

         {  
 

             if(dp[i+1][j]>dp[i+1][j+1])  
 

             {  
 

                 dp[i][j]=dp[i+1][j]+a[i][j];  
 

             }else  
 

             {  
 

                 dp[i][j]=dp[i+1][j+1]+a[i][j];  
 

             }  
 

         }  
 

     }  
 

     printf(""%d\n"",dp[0][0]);  
 

     return 0;  
 

 }  
 

  
"
