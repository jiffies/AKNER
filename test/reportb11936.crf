poj1821	eng	B-OJ
-	x	O
-	x	O
fence	eng	O
 	x	O
动态	n	B-KNOWLEDGE
规划	n	I-KNOWLEDGE
（	x	O
九	m	O
）	x	O
_	x	O
highkobe	eng	O
_	x	O
百度	n	O
空间	n	O

	x	O

	x	O
题目	n	O
大意	d	O
：	x	O
有	v	O
一段	m	O
长度	ns	O
为	p	O
n	eng	O
的	uj	O
木板	n	O
也	d	O
就是	d	O
被	p	O
分成	v	O
n	eng	O
分	v	O
，	x	O
有	v	O
k	eng	O
个	m	O
工人	n	O
他们	r	O
负责	v	O
以	p	O
Si	eng	O
为	p	O
中心	n	O
的	uj	O
一块	m	O
长	a	O
为	p	O
L	eng	O
的	uj	O
区域	n	O
，	x	O
并且	c	O
每	zg	O
一个	m	O
小格	n	O
每个	r	O
工人	n	O
负责	v	O
的	uj	O
价钱	n	O
不	d	O
等	u	O
。	x	O


	x	O
求	v	O
：	x	O
怎么	r	O
进行	v	O
分配	vn	O
使得	v	O
搜与	v	O
哦	e	O
工人	n	O
正的	z	O
总	b	O
钱	n	O
数	n	O
最大	a	O
？	x	O

	x	O
思路	n	O
：	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
iend	eng	O
]	x	O
=	x	O
max	eng	O
{	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
ibegin	eng	O
-	x	O
1	x	O
]	x	O
+	x	O
(	x	O
iend	eng	O
-	x	O
ibegin	eng	O
+	x	O
1	m	O
)	x	O
*	x	O
p	x	O
}	x	O
。	x	O
。	x	O

接着	c	O
枚举	nz	O
ibegin	eng	O
和	c	O
iend	eng	O
即可	d	O

	x	O
时间	n	O
复杂度	n	O
O	x	O
（	x	O
n	x	O
*	x	O
n	x	O
*	x	O
k	x	O
)	x	O
;	x	O

	x	O
根据	p	O
上	f	O
式	k	O
可以	c	O
看出	v	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
x	eng	O
+	x	O
l	eng	O
-	x	O
1	x	O
]	x	O
=	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
1	x	O
]	x	O
+	x	O
l	eng	O
*	x	O
p	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
1	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
x	eng	O
+	x	O
l	eng	O
-	x	O
2	x	O
]	x	O
=	x	O
max	eng	O
{	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
2	x	O
]	x	O
+	x	O
l	eng	O
*	x	O
p	x	O
,	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
1	x	O
]	x	O
+	x	O
(	x	O
l	x	O
-	x	O
1	x	O
)	x	O
*	x	O
p	x	O
}	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
2	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
x	eng	O
+	x	O
l	eng	O
-	x	O
3	x	O
]	x	O
=	x	O
max	eng	O
{	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
3	x	O
]	x	O
+	x	O
l	eng	O
*	x	O
p	x	O
,	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
2	x	O
]	x	O
+	x	O
(	x	O
l	x	O
-	x	O
1	x	O
)	x	O
*	x	O
p	x	O
,	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
1	x	O
]	x	O
+	x	O
(	x	O
l	x	O
-	x	O
2	x	O
)	x	O
*	x	O
p	x	O
}	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
3	x	O

	x	O
可以	c	O
看出	v	O
if	eng	O
（	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
2	x	O
]	x	O
+	x	O
l	eng	O
*	x	O
p	x	O
>	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
1	x	O
]	x	O
+	x	O
(	x	O
l	x	O
-	x	O
1	x	O
)	x	O
*	x	O
p	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
则	d	O
f	eng	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
2	x	O
]	x	O
+	x	O
(	x	O
l	x	O
-	x	O
1	x	O
)	x	O
*	x	O
p	x	O
>	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
1	x	O
]	x	O
+	x	O
(	x	O
l	x	O
-	x	O
2	x	O
)	x	O
*	x	O
p	x	O

	x	O
反之亦然	i	O
。	x	O
。	x	O
。	x	O


	x	O
也就是说	l	O
我们	r	O
只	d	O
需要	v	O
算	v	O
一次	m	O
即可	d	O
，	x	O
不必	d	O
做	v	O
太	d	O
多	m	O
没	v	O
用功	n	O
。	x	O
。	x	O
。	x	O


	x	O
所以	c	O
变成	v	O
：	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
x	eng	O
+	x	O
l	eng	O
-	x	O
3	x	O
]	x	O
=	x	O
max	eng	O
{	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	x	O
-	x	O
3	x	O
]	x	O
+	x	O
l	eng	O
*	x	O
p	x	O
,	x	O
f	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
[	x	O
x	eng	O
+	x	O
l	eng	O
-	x	O
2	x	O
]	x	O
+	x	O
(	x	O
l	x	O
-	x	O
1	x	O
)	x	O
*	x	O
p	x	O
}	x	O
,	x	O
即可	d	O
。	x	O


	x	O
于是	c	O
我们	r	O
知道	v	O
之用	r	O
一位	m	O
方程	n	O
即可	d	O
：	x	O

	x	O
代码	n	O
如下	t	O
：	x	O

	x	O
#	x	O
include	eng	O
<	x	O
stdio	eng	O
.	m	O
h	eng	O
>	x	O
#	x	O
include	eng	O
<	x	O
string	eng	O
.	m	O
h	eng	O
>	x	O
#	x	O
include	eng	O
<	x	O
stdlib	eng	O
.	m	O
h	eng	O
>	x	O
typedef	eng	O
 	x	O
struct	eng	O
{	x	O
 	x	O
int	eng	O
 	x	O
num	eng	O
;	x	O
 	x	O
int	eng	O
 	x	O
p	x	O
;	x	O
 	x	O
int	eng	O
 	x	O
l	x	O
;	x	O
}	x	O
offset	eng	O
 	x	O
;	x	O
offset	eng	O
 	x	O
item	eng	O
[	x	O
105	m	O
]	x	O
;	x	O
int	eng	O
 	x	O
f	x	O
[	x	O
2	x	O
*	x	O
16005	m	O
]	x	O
;	x	O
int	eng	O
 	x	O
cmp	eng	O
(	x	O
const	eng	O
 	x	O
void	eng	O
*	x	O
a	x	O
,	x	O
const	eng	O
 	x	O
void	eng	O
*	x	O
b	x	O
)	x	O
{	x	O
 	x	O
offset	eng	O
*	x	O
c	x	O
=	x	O
(	x	O
offset	eng	O
*	x	O
)	x	O
a	x	O
;	x	O
 	x	O
offset	eng	O
*	x	O
d	x	O
=	x	O
(	x	O
offset	eng	O
*	x	O
)	x	O
b	x	O
;	x	O
 	x	O
return	eng	O
 	x	O
c	x	O
-	x	O
>	x	O
num	eng	O
-	x	O
d	x	O
-	x	O
>	x	O
num	eng	O
;	x	O
}	x	O
int	eng	O
 	x	O
max	eng	O
(	x	O
int	eng	O
 	x	O
x	x	O
,	x	O
int	eng	O
 	x	O
y	x	O
)	x	O
{	x	O
 	x	O
return	eng	O
 	x	O
(	x	O
x	x	O
>	x	O
y	x	O
)	x	O
?	x	O
x	x	O
:	x	O
y	x	O
;	x	O
}	x	O
int	eng	O
 	x	O
main	eng	O
(	x	O
)	x	O
{	x	O
 	x	O
int	eng	O
 	x	O
n	x	O
,	x	O
m	x	O
,	x	O
i	x	O
,	x	O
j	x	O
,	x	O
k	x	O
,	x	O
num	eng	O
,	x	O
l	x	O
,	x	O
p	x	O
,	x	O
best	eng	O
,	x	O
temp	eng	O
,	x	O
q	x	O
;	x	O
 	x	O
while	eng	O
(	x	O
scanf	eng	O
(	x	O
"	x	O
%	x	O
d	x	O
%	x	O
d	x	O
"	x	O
,	x	O
&	x	O
n	eng	O
,	x	O
&	x	O
m	eng	O
)	x	O
!	x	O
=	x	O
EOF	eng	O
)	x	O
 	x	O
{	x	O
 	x	O
memset	eng	O
(	x	O
f	x	O
,	x	O
0	x	O
,	x	O
sizeof	eng	O
(	x	O
f	x	O
)	x	O
)	x	O
;	x	O
 	x	O
for	eng	O
(	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	x	O
<	x	O
m	x	O
;	x	O
i	eng	O
++	x	O
)	x	O
 	x	O
scanf	eng	O
(	x	O
"	x	O
%	x	O
d	x	O
%	x	O
d	x	O
%	x	O
d	x	O
"	x	O
,	x	O
&	x	O
item	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
l	eng	O
,	x	O
&	x	O
item	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
p	eng	O
,	x	O
&	x	O
item	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
num	eng	O
)	x	O
;	x	O
 	x	O
qsort	eng	O
(	x	O
item	eng	O
,	x	O
m	x	O
,	x	O
sizeof	eng	O
(	x	O
item	eng	O
[	x	O
0	x	O
]	x	O
)	x	O
,	x	O
cmp	eng	O
)	x	O
;	x	O
 	x	O
best	eng	O
=	x	O
0	x	O
;	x	O
 	x	O
for	eng	O
(	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	x	O
<	x	O
m	x	O
;	x	O
i	eng	O
++	x	O
)	x	O
 	x	O
{	x	O
 	x	O
l	x	O
=	x	O
item	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
l	eng	O
;	x	O
 	x	O
num	eng	O
=	x	O
item	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
num	eng	O
;	x	O
 	x	O
p	x	O
=	x	O
item	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
p	eng	O
;	x	O
 	x	O
q	x	O
=	x	O
l	x	O
*	x	O
p	x	O
;	x	O
 	x	O
for	eng	O
(	x	O
j	x	O
=	x	O
num	eng	O
+	x	O
l	eng	O
-	x	O
1	x	O
,	x	O
k	x	O
=	x	O
num	eng	O
-	x	O
1	x	O
;	x	O
j	x	O
>	x	O
=	x	O
num	eng	O
;	x	O
j	x	O
-	x	O
-	x	O
,	x	O
k	x	O
-	x	O
-	x	O
)	x	O
 	x	O
{	x	O
 	x	O
if	eng	O
(	x	O
j	x	O
=	x	O
=	x	O
num	eng	O
+	x	O
l	eng	O
-	x	O
1	x	O
)	x	O
 	x	O
temp	eng	O
=	x	O
f	x	O
[	x	O
k	x	O
]	x	O
+	x	O
q	eng	O
;	x	O
 	x	O
else	eng	O
 	x	O
if	eng	O
(	x	O
k	x	O
>	x	O
=	x	O
0	x	O
)	x	O
 	x	O
temp	eng	O
=	x	O
max	eng	O
(	x	O
f	x	O
[	x	O
k	x	O
]	x	O
+	x	O
q	eng	O
,	x	O
temp	eng	O
-	x	O
p	x	O
)	x	O
;	x	O
 	x	O
else	eng	O
 	x	O
temp	eng	O
=	x	O
temp	eng	O
-	x	O
p	x	O
;	x	O
 	x	O
f	x	O
[	x	O
j	x	O
]	x	O
=	x	O
max	eng	O
(	x	O
temp	eng	O
,	x	O
f	x	O
[	x	O
j	x	O
]	x	O
)	x	O
;	x	O
 	x	O
if	eng	O
(	x	O
f	x	O
[	x	O
j	x	O
]	x	O
>	x	O
f	x	O
[	x	O
best	eng	O
]	x	O
)	x	O
 	x	O
best	eng	O
=	x	O
j	x	O
;	x	O
 	x	O
}	x	O
 	x	O
for	eng	O
(	x	O
j	x	O
=	x	O
best	eng	O
+	x	O
1	m	O
;	x	O
j	x	O
<	x	O
=	x	O
n	x	O
;	x	O
j	eng	O
++	x	O
)	x	O
 	x	O
f	x	O
[	x	O
j	x	O
]	x	O
=	x	O
f	x	O
[	x	O
best	eng	O
]	x	O
;	x	O
 	x	O
}	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
%	x	O
d	x	O
\	x	O
n	x	O
"	x	O
,	x	O
f	x	O
[	x	O
n	x	O
]	x	O
)	x	O
;	x	O
 	x	O
}	x	O
 	x	O
return	eng	O
 	x	O
0	x	O
;	x	O
}	x	O