Brackets	eng	O
 	x	O
Sequence	eng	O
-	x	O
-	x	O
poj	eng	B-OJ
-	x	I-OJ
-	x	I-OJ
1141	m	I-OJ
 	x	O
-	x	O
 	x	O
android	eng	O
开发	v	O
实例	n	O
 	x	O
-	x	O
 	x	O
博客园	nr	O

	x	O

	x	O
Brackets	eng	O
 	x	O
Sequence	eng	O

	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Time	eng	O
 	x	O
Limit	eng	O
:	x	O
 	x	O
1000	m	O
MS	eng	O

	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Memory	eng	O
 	x	O
Limit	eng	O
:	x	O
 	x	O
65536	m	O
K	eng	O

	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Total	eng	O
 	x	O
Submissions	eng	O
:	x	O
 	x	O
11854	m	O

	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Accepted	eng	O
:	x	O
 	x	O
3164	m	O

	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Special	eng	O
 	x	O
Judge	eng	O

	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O

	x	O
 	x	O

	x	O
Description	eng	O

	x	O
 	x	O

	x	O
Let	eng	O
 	x	O
us	eng	O
 	x	O
define	eng	O
 	x	O
a	x	O
 	x	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
 	x	O
in	eng	O
 	x	O
the	eng	O
 	x	O
following	eng	O
 	x	O
way	eng	O
:	x	O
 	x	O

	x	O
1.	m	O
 	x	O
Empty	eng	O
 	x	O
sequence	eng	O
 	x	O
is	eng	O
 	x	O
a	x	O
 	x	O
regular	eng	O
 	x	O
sequence	eng	O
.	m	O
 	x	O

	x	O
2.	m	O
 	x	O
If	eng	O
 	x	O
S	x	O
 	x	O
is	eng	O
 	x	O
a	x	O
 	x	O
regular	eng	O
 	x	O
sequence	eng	O
,	x	O
 	x	O
then	eng	O
 	x	O
(	x	O
S	x	O
)	x	O
 	x	O
and	eng	O
 	x	O
[	x	O
S	x	O
]	x	O
 	x	O
are	eng	O
 	x	O
both	eng	O
 	x	O
regular	eng	O
 	x	O
sequences	eng	O
.	m	O
 	x	O

	x	O
3.	m	O
 	x	O
If	eng	O
 	x	O
A	x	O
 	x	O
and	eng	O
 	x	O
B	x	O
 	x	O
are	eng	O
 	x	O
regular	eng	O
 	x	O
sequences	eng	O
,	x	O
 	x	O
then	eng	O
 	x	O
AB	eng	O
 	x	O
is	eng	O
 	x	O
a	x	O
 	x	O
regular	eng	O
 	x	O
sequence	eng	O
.	m	O
 	x	O

	x	O
For	eng	O
 	x	O
example	eng	O
,	x	O
 	x	O
all	eng	O
 	x	O
of	eng	O
 	x	O
the	eng	O
 	x	O
following	eng	O
 	x	O
sequences	eng	O
 	x	O
of	eng	O
 	x	O
characters	eng	O
 	x	O
are	eng	O
 	x	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequences	eng	O
:	x	O
 	x	O

	x	O
(	x	O
)	x	O
,	x	O
 	x	O
[	x	O
]	x	O
,	x	O
 	x	O
(	x	O
(	x	O
)	x	O
)	x	O
,	x	O
 	x	O
(	x	O
[	x	O
]	x	O
)	x	O
,	x	O
 	x	O
(	x	O
)	x	O
[	x	O
]	x	O
,	x	O
 	x	O
(	x	O
)	x	O
[	x	O
(	x	O
)	x	O
]	x	O
 	x	O

	x	O
And	eng	O
 	x	O
all	eng	O
 	x	O
of	eng	O
 	x	O
the	eng	O
 	x	O
following	eng	O
 	x	O
character	eng	O
 	x	O
sequences	eng	O
 	x	O
are	eng	O
 	x	O
not	eng	O
:	x	O
 	x	O

	x	O
(	x	O
,	x	O
 	x	O
[	x	O
,	x	O
 	x	O
)	x	O
,	x	O
 	x	O
)	x	O
(	x	O
,	x	O
 	x	O
(	x	O
[	x	O
)	x	O
]	x	O
,	x	O
 	x	O
(	x	O
[	x	O
(	x	O
]	x	O
 	x	O

	x	O
Some	eng	O
 	x	O
sequence	eng	O
 	x	O
of	eng	O
 	x	O
characters	eng	O
 	x	O
'	x	O
(	x	O
'	x	O
,	x	O
 	x	O
'	x	O
)	x	O
'	x	O
,	x	O
 	x	O
'	x	O
[	x	O
'	x	O
,	x	O
 	x	O
and	eng	O
 	x	O
'	x	O
]	x	O
'	x	O
 	x	O
is	eng	O
 	x	O
given	eng	O
.	m	O
 	x	O
You	eng	O
 	x	O
are	eng	O
 	x	O
to	eng	O
 	x	O
find	eng	O
 	x	O
the	eng	O
 	x	O
shortest	eng	O
 	x	O
possible	eng	O
 	x	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
,	x	O
 	x	O
that	eng	O
 	x	O
contains	eng	O
 	x	O
the	eng	O
 	x	O
given	eng	O
 	x	O
character	eng	O
 	x	O
sequence	eng	O
 	x	O
as	eng	O
 	x	O
a	x	O
 	x	O
subsequence	eng	O
.	m	O
 	x	O
Here	eng	O
,	x	O
 	x	O
a	x	O
 	x	O
string	eng	O
 	x	O
a1	eng	O
 	x	O
a2	eng	O
 	x	O
...	m	O
 	x	O
an	eng	O
 	x	O
is	eng	O
 	x	O
called	eng	O
 	x	O
a	x	O
 	x	O
subsequence	eng	O
 	x	O
of	eng	O
 	x	O
the	eng	O
 	x	O
string	eng	O
 	x	O
b1	eng	O
 	x	O
b2	eng	O
 	x	O
...	m	O
 	x	O
bm	eng	O
,	x	O
 	x	O
if	eng	O
 	x	O
there	eng	O
 	x	O
exist	eng	O
 	x	O
such	eng	O
 	x	O
indices	eng	O
 	x	O
1	x	O
 	x	O
=	x	O
 	x	O
i1	eng	O
 	x	O
<	x	O
 	x	O
i2	eng	O
 	x	O
<	x	O
 	x	O
...	m	O
 	x	O
<	x	O
 	x	O
in	eng	O
 	x	O
=	x	O
 	x	O
m	x	O
,	x	O
 	x	O
that	eng	O
 	x	O
aj	eng	O
 	x	O
=	x	O
 	x	O
bij	eng	O
 	x	O
for	eng	O
 	x	O
all	eng	O
 	x	O
1	x	O
 	x	O
=	x	O
 	x	O
j	x	O
 	x	O
=	x	O
 	x	O
n	eng	O
.	m	O

	x	O
 	x	O

	x	O
Input	eng	O

	x	O
 	x	O

	x	O
The	eng	O
 	x	O
input	eng	O
 	x	O
file	eng	O
 	x	O
contains	eng	O
 	x	O
at	eng	O
 	x	O
most	eng	O
 	x	O
100	m	O
 	x	O
brackets	eng	O
 	x	O
(	x	O
characters	eng	O
 	x	O
'	x	O
(	x	O
'	x	O
,	x	O
 	x	O
'	x	O
)	x	O
'	x	O
,	x	O
 	x	O
'	x	O
[	x	O
'	x	O
 	x	O
and	eng	O
 	x	O
'	x	O
]	x	O
'	x	O
)	x	O
 	x	O
that	eng	O
 	x	O
are	eng	O
 	x	O
situated	eng	O
 	x	O
on	eng	O
 	x	O
a	x	O
 	x	O
single	eng	O
 	x	O
line	eng	O
 	x	O
without	eng	O
 	x	O
any	eng	O
 	x	O
other	eng	O
 	x	O
characters	eng	O
 	x	O
among	eng	O
 	x	O
them	eng	O
.	m	O

	x	O
 	x	O

	x	O
Output	eng	O

	x	O
 	x	O

	x	O
Write	eng	O
 	x	O
to	eng	O
 	x	O
the	eng	O
 	x	O
output	eng	O
 	x	O
file	eng	O
 	x	O
a	x	O
 	x	O
single	eng	O
 	x	O
line	eng	O
 	x	O
that	eng	O
 	x	O
contains	eng	O
 	x	O
some	eng	O
 	x	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
 	x	O
that	eng	O
 	x	O
has	eng	O
 	x	O
the	eng	O
 	x	O
minimal	eng	O
 	x	O
possible	eng	O
 	x	O
length	eng	O
 	x	O
and	eng	O
 	x	O
contains	eng	O
 	x	O
the	eng	O
 	x	O
given	eng	O
 	x	O
sequence	eng	O
 	x	O
as	eng	O
 	x	O
a	x	O
 	x	O
subsequence	eng	O
.	m	O

	x	O
 	x	O

	x	O
Sample	eng	O
 	x	O
Input	eng	O

	x	O
 	x	O

	x	O
(	x	O
[	x	O
(	x	O
]	x	O

	x	O
 	x	O

	x	O
Sample	eng	O
 	x	O
Output	eng	O

	x	O
 	x	O

	x	O
(	x	O
)	x	O
[	x	O
(	x	O
)	x	O
]	x	O

	x	O
 	x	O

	x	O
Source	eng	O

	x	O
 	x	O

	x	O
Northeastern	eng	O
 	x	O
Europe	eng	O
 	x	O
2001	m	O

	x	O
 	x	O

	x	O
先	d	O
读懂	v	O
题意	n	O
：	x	O

	x	O
 	x	O

	x	O
很	zg	O
简单	a	O
，	x	O
就是	d	O
给出	v	O
一个	m	O
序列	n	O
，	x	O
要求	v	O
添加	v	O
最少	d	O
的	uj	O
符号	n	O
使	v	O
其	r	O
变成	v	O
题目	n	O
要求	v	O
的	uj	O
规则	n	O
序列	n	O
。	x	O

	x	O
 	x	O

	x	O
解题	n	O
思路	n	O
：	x	O

	x	O
先	d	O
用	p	O
递归	v	O
的	uj	O
方法	n	O
来	v	O
分析	vn	O
问题	n	O
，	x	O
设	v	O
输入	v	O
序列	n	O
SiSi	eng	O
+	x	O
1...	m	O
Sj	eng	O
最少	d	O
需要	v	B-KNOWLEDGE
添加	v	O
d	x	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
个	q	O
括号	n	O
，	x	O
根据	p	O
不同	a	O
情况	n	O
，	x	O
可以	c	O
将	d	O
问题	n	O
分解	v	O
为	p	O
以下	f	O
子	ng	O
问题	n	O
：	x	O

	x	O
 	x	O

	x	O
1	x	O
）	x	O
S	eng	O
形如	v	O
(	x	O
S	x	O
’	x	O
)	x	O
或者	c	O
[	x	O
S	x	O
’	x	O
]	x	O

	x	O
 	x	O

	x	O
只	d	O
需要	v	O
把	p	O
S	eng	O
’	x	O
变成	v	O
规则	n	O
的	uj	O
序列	n	O
，	x	O
则	d	O
S	eng	O
就是	d	O
规则	n	O
的	uj	O
了	ul	O
；	x	O

	x	O
 	x	O

	x	O
2	x	O
）	x	O
S	eng	O
形如	v	O
(	x	O
S	x	O
’	x	O

	x	O
 	x	O

	x	O
先	d	O
把	p	O
S	eng	O
’	x	O
变成	v	O
规则	n	O
序列	n	O
，	x	O
接着	c	O
在	p	O
最后	f	O
添加	v	O
”	x	O
)	x	O
”	x	O
，	x	O
则	d	O
S	eng	O
就	d	O
变成	v	O
规则	n	O
序列	n	O
了	ul	O
；	x	O

	x	O
 	x	O

	x	O
3	x	O
）	x	O
S	eng	O
形如	v	O
S	eng	O
’	x	O
)	x	O
或者	c	O
[	x	O
S	x	O
’	x	O
或者	c	O
S	x	O
’	x	O
]	x	O

	x	O
 	x	O

	x	O
和	c	O
上面	f	O
的	uj	O
情况	n	O
类似	v	O
解法	v	O

	x	O
 	x	O

	x	O
4	x	O
）	x	O
只要	c	O
序列	n	O
S	eng	O
的	uj	O
长度	ns	O
大于	d	O
1	x	O
，	x	O
都	d	O
可以	c	O
把	p	O
S	eng	O
分成	v	O
两	m	O
部分	n	O
：	x	O
Si	eng	O
...	m	O
Sk	eng	O
和	c	O
Sk	eng	O
+	x	O
1...	m	O
Sj	eng	O
，	x	O
然后	c	O
分别	d	O
将子	n	O
序列	n	O
变成	v	O
规则	n	O
序列	n	O
，	x	O
则	d	O
拼接	v	O
在	p	O
一起	m	O
的	uj	O
S	eng	O
就是	d	O
规则	n	O
序列	n	O
了	ul	O
。	x	O

	x	O
 	x	O

	x	O
下面	f	O
给出	v	O
递归	v	O
的	uj	O
伪	n	O
代码	n	O
：	x	O

	x	O
 	x	O

	x	O
function	eng	O
 	x	O
Bracket	eng	O
(	x	O
i	x	O
,	x	O
 	x	O
j	x	O
 	x	O
:	x	O
 	x	O
Integer	eng	O
)	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
i	eng	O
和	c	O
j	eng	O
是	v	O
本	r	O
序列	n	O
在	p	O
原始	v	O
输入	v	O
序列	n	O
中	f	O
的	uj	O
开始	v	O
和	c	O
结束	v	O
下标	v	O

	x	O
 	x	O

	x	O
begin	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
i	x	O
>	x	O
j	x	O
 	x	O
then	eng	O
 	x	O
return	eng	O
 	x	O
0	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O
 	x	O
if	eng	O
 	x	O
i	x	O
=	x	O
j	x	O
 	x	O
then	eng	O
 	x	O
return	eng	O
 	x	O
1	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O
 	x	O
begin	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Answer	eng	O
 	x	O
:	x	O
=	x	O
 	x	O
MAX	eng	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
(	x	O
)	x	O
'	x	O
 	x	O
or	eng	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
[	x	O
]	x	O
'	x	O
 	x	O
then	eng	O
 	x	O
/	x	O
/	x	O
对应	vn	O
上面	f	O
情形	n	O
1	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Answer	eng	O
 	x	O
:	x	O
=	x	O
 	x	O
min	eng	O
(	x	O
Answer	eng	O
,	x	O
 	x	O
Bracket	eng	O
(	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
j	x	O
-	x	O
1	x	O
)	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
=	x	O
'	x	O
(	x	O
'	x	O
 	x	O
or	eng	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
=	x	O
'	x	O
[	x	O
'	x	O
 	x	O
then	eng	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
对应	vn	O
上面	f	O
情形	n	O
2	x	O
/	x	O
3	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Answer	eng	O
 	x	O
:	x	O
=	x	O
 	x	O
min	eng	O
(	x	O
Answer	eng	O
,	x	O
 	x	O
Bracket	eng	O
(	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
j	x	O
)	x	O
 	x	O
+	x	O
 	x	O
1	x	O
)	x	O
;	x	O
 	x	O
/	x	O
/	x	O
加	v	O
1	m	O
表示	v	O
在	p	O
右边	f	O
加	v	O
了	ul	O
'	x	O
)	x	O
'	x	O
或	c	O
'	x	O
]	x	O
'	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
)	x	O
'	x	O
 	x	O
or	eng	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
]	x	O
'	x	O
 	x	O
then	eng	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
同上	f	O
2	m	O
/	x	O
3	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Answer	eng	O
 	x	O
:	x	O
=	x	O
 	x	O
min	eng	O
(	x	O
Answer	eng	O
,	x	O
 	x	O
Bracker	eng	O
(	x	O
i	x	O
,	x	O
 	x	O
j	x	O
-	x	O
1	x	O
)	x	O
+	x	O
1	m	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
For	eng	O
 	x	O
k	x	O
:	x	O
=	x	O
i	x	O
 	x	O
to	eng	O
 	x	O
j	x	O
-	x	O
1	x	O
 	x	O
do	eng	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
对应	vn	O
上面	f	O
情形	n	O
4	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Answer	eng	O
 	x	O
:	x	O
=	x	O
 	x	O
min	eng	O
(	x	O
Answer	eng	O
,	x	O
 	x	O
Bracket	eng	O
(	x	O
i	x	O
,	x	O
 	x	O
k	x	O
)	x	O
 	x	O
+	x	O
 	x	O
Bracket	eng	O
(	x	O
k	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
j	x	O
)	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
end	eng	O
;	x	O

	x	O
 	x	O

	x	O
end	eng	O
;	x	O

	x	O
 	x	O

	x	O
上面	f	O
递归	v	O
的	uj	O
算法	n	O
效率	n	O
很	d	O
低	a	O
（	x	O
递归	v	O
进行	v	O
了	ul	O
很多	m	O
重复	d	O
计算	v	O
）	x	O
，	x	O
时间	n	O
复杂度	n	O
是	v	O
指数	n	O
级	q	O
的	uj	O
，	x	O
因此	c	O
我们	r	O
必须	d	O
在	p	O
递归	v	O
的	uj	O
基础	n	O
上	f	O
进行	v	O
改进	v	O
，	x	O
即	v	O
采用	v	O
动态	n	O
规划	n	O
。	x	O

	x	O
 	x	O

	x	O
一	m	O
、	x	B-KNOWLEDGE
记忆	n	I-KNOWLEDGE
化	n	O
搜索	v	O

	x	O
 	x	O

	x	O
在	p	O
每次	r	O
调用	vn	O
Bracket	eng	O
函数	n	O
之前	f	O
，	x	O
先	d	O
检查	vn	O
之前	f	O
是否	v	B-KNOWLEDGE
已经	d	O
计算	v	O
过	ug	O
这个	r	O
值	n	O
了	ul	O
，	x	O
如果	c	O
是	v	B-KNOWLEDGE
则	d	I-KNOWLEDGE
直接	ad	I-KNOWLEDGE
从	p	O
之前	f	O
保存	v	O
的	uj	O
表中	v	O
找出	v	O
：	x	O

	x	O
 	x	O

	x	O
function	eng	O
 	x	O
Bracket	eng	O
(	x	O
i	x	O
 	x	O
,	x	O
 	x	O
j	x	O
 	x	O
:	x	O
 	x	O
Integer	eng	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
begin	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
Calculated	eng	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
 	x	O
then	eng	O
 	x	O
return	eng	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
此处	r	O
插入	v	O
上面	f	O
的	uj	O
递归	v	O
代码	n	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
 	x	O
:	x	O
=	x	O
 	x	O
Answer	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Calculated	eng	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	B-KNOWLEDGE
 	x	I-KNOWLEDGE
:	x	O
=	x	O
 	x	O
true	eng	O
;	x	O

	x	O
 	x	O

	x	O
end	eng	O
;	x	O

	x	O
 	x	O

	x	O
二	m	O
、	x	O
自	p	O
底向上	l	O
的	uj	O
递推	v	O
法	j	O

	x	O
 	x	O

	x	O
由于	c	O
计算	v	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
之前	f	O
需要	v	O
知道	v	O
d	x	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
j	x	O
]	x	O
，	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
-	x	O
1	x	O
]	x	O
和	c	O
d	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
j	x	O
-	x	O
1	x	O
]	x	O
的	uj	O
值	n	O
，	x	O
所以	c	O
按照	p	O
j	x	O
-	x	O
i	x	O
递增	v	O
的	uj	O
顺序	n	O
计算	v	O
出	v	O
d	eng	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
：	x	O

	x	O
 	x	O

	x	O
for	eng	O
 	x	O
i	x	O
:	x	O
=	x	O
1	x	O
 	x	O
to	eng	O
 	x	O
n	x	O
 	x	O
do	eng	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
i	x	O
-	x	O
1	x	O
]	x	O
:	x	O
=	x	O
0	x	O
;	x	O
 	x	O
/	x	O
/	x	O
置	v	O
初始值	l	O

	x	O
 	x	O

	x	O
for	eng	O
 	x	O
i	x	O
:	x	O
=	x	O
1	x	O
 	x	O
to	eng	O
 	x	O
n	x	O
 	x	O
do	eng	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
i	x	O
]	x	O
:	x	O
=	x	O
1	x	O
;	x	O

	x	O
 	x	O

	x	O
for	eng	O
 	x	O
p	x	O
:	x	O
=	x	O
1	x	O
 	x	O
to	eng	O
 	x	O
n	x	O
-	x	O
1	x	O
 	x	O
do	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
 	x	O
i	x	O
:	x	O
=	x	O
1	x	O
 	x	O
to	eng	O
 	x	O
n	x	O
-	x	O
p	x	O
 	x	O
do	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
begin	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
j	x	O
:	x	O
=	x	O
i	eng	O
+	x	O
p	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
:	x	O
=	x	O
MAX	eng	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
(	x	O
)	x	O
'	x	O
 	x	O
or	eng	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
[	x	O
]	x	O
'	x	O
 	x	O
then	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
 	x	O
:	x	O
=	x	O
 	x	O
min	eng	O
(	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
,	x	O
 	x	O
d	x	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
j	x	O
-	x	O
1	x	O
]	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
=	x	O
'	x	O
(	x	O
'	x	O
 	x	O
or	eng	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
=	x	O
'	x	O
[	x	O
'	x	O
 	x	O
then	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
 	x	O
:	x	O
=	x	O
min	eng	O
(	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
,	x	O
 	x	O
d	x	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
j	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
)	x	O
'	x	O
 	x	O
or	eng	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
]	x	O
'	x	O
 	x	O
then	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
 	x	O
:	x	O
=	x	O
 	x	O
min	eng	O
(	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
,	x	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
-	x	O
1	x	O
]	x	O
+	x	O
1	m	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
For	eng	O
 	x	O
k	x	O
:	x	O
=	x	O
i	x	O
 	x	O
to	eng	O
 	x	O
j	x	O
-	x	O
1	x	O
 	x	O
do	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
 	x	O
:	x	O
=	x	O
 	x	O
min	eng	O
(	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
j	x	O
]	x	O
,	x	O
 	x	O
d	x	O
[	x	O
i	x	O
,	x	O
 	x	O
k	x	O
]	x	O
 	x	O
+	x	O
 	x	O
d	x	O
[	x	O
k	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
j	x	O
]	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
end	eng	O
;	x	O

	x	O
 	x	O

	x	O
AC	eng	O
代码	n	O
如下	t	O
：	x	O

	x	O
 	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
iostream	eng	O
>	x	O

	x	O
 	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
string	eng	O
>	x	O

	x	O
 	x	O

	x	O
const	eng	O
 	x	O
int	eng	O
 	x	O
MAX	eng	O
 	x	O
=	x	O
 	x	O
1000	m	O
;	x	O

	x	O
 	x	O

	x	O
int	eng	O
 	x	O
flag	eng	O
[	x	O
MAX	eng	O
]	x	O
[	x	O
MAX	eng	O
]	x	O
;	x	O
 	x	O
/	x	O
/	x	O
in	eng	O
[	x	O
i	x	O
]	x	O
到	v	O
in	eng	O
[	x	O
j	x	O
]	x	O
间	f	O
字符	n	O
数	n	O

	x	O
 	x	O

	x	O
int	eng	O
 	x	O
mem	eng	O
[	x	O
MAX	eng	O
]	x	O
[	x	O
MAX	eng	O
]	x	O
;	x	O
 	x	O
/	x	O
/	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
记录	n	O
in	eng	O
[	x	O
i	x	O
]	x	O
和	c	O
in	eng	O
[	x	O
j	x	O
]	x	O
之间	f	O
的	uj	O
序列	n	O
是否	v	O
需要	v	O
分成	v	O
两	m	O
部分	n	O

	x	O
 	x	O

	x	O
std	eng	O
:	x	O
:	x	O
string	eng	O
 	x	O
in	eng	O
;	x	O
/	x	O
/	x	O
存储	j	O
输入	v	O
的	uj	O
字符串	n	O

	x	O
 	x	O

	x	O
int	eng	O
 	x	O
min	eng	O
(	x	O
int	eng	O
 	x	O
x	x	O
,	x	O
 	x	O
int	eng	O
 	x	O
y	x	O
)	x	O

	x	O
 	x	O

	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
return	eng	O
 	x	O
(	x	O
x	x	O
>	x	O
y	x	O
 	x	O
?	x	O
 	x	O
y	x	O
 	x	O
:	x	O
 	x	O
x	x	O
)	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O

	x	O
}	x	O

	x	O
 	x	O

	x	O
/	x	O
/	x	O
打印	v	O
出	v	O
结果	n	O
字符	n	O

	x	O
 	x	O

	x	O
void	eng	O
 	x	O
find	eng	O
(	x	O
int	eng	O
 	x	O
xx	eng	O
,	x	O
 	x	O
int	eng	O
 	x	O
yy	eng	O
)	x	O

	x	O
 	x	O

	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
xx	eng	O
 	x	O
>	x	O
 	x	O
yy	eng	O
)	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
return	eng	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
mem	eng	O
[	x	O
xx	eng	O
]	x	O
[	x	O
yy	eng	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
-	x	O
1	x	O
)	x	O
 	x	O
/	x	O
/	x	O
当前	t	O
序列	n	O
不	d	O
需要	v	O
分成	v	O
两	m	O
部分	n	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
xx	eng	O
 	x	O
=	x	O
=	x	O
 	x	O
yy	eng	O
)	x	O
/	x	O
/	x	O
当前	t	O
序列	n	O
只	d	O
剩	v	O
一个	m	O
字符	n	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
in	eng	O
[	x	O
xx	eng	O
]	x	O
 	x	O
=	x	O
=	x	O
'	x	O
(	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
in	eng	O
[	x	O
xx	eng	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
)	x	O
'	x	O
)	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
std	eng	O
:	x	O
:	x	O
cout	eng	O
<	x	O
<	x	O
"	x	O
(	x	O
)	x	O
"	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O
 	x	O
if	eng	O
(	x	O
in	eng	O
[	x	O
xx	eng	O
]	x	O
=	x	O
=	x	O
'	x	O
[	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
in	eng	O
[	x	O
xx	eng	O
]	x	O
=	x	O
=	x	O
 	x	O
'	x	O
]	x	O
'	x	O
)	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
std	eng	O
:	x	O
:	x	O
cout	eng	O
<	x	O
<	x	O
"	x	O
[	x	O
]	x	O
"	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O
 	x	O
 	x	O
/	x	O
/	x	O
当前	t	O
序列	n	O
不止	v	O
一个	m	O
字符	n	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
std	eng	O
:	x	O
:	x	O
cout	eng	O
<	x	O
<	x	O
in	eng	O
[	x	O
xx	eng	O
]	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
输出	v	O
当前	t	O
序列	n	O
第一个	m	O
字符	n	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
find	eng	O
(	x	O
xx	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
yy	eng	O
-	x	O
1	x	O
)	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
对	p	O
中间	f	O
的	uj	O
部分	n	O
递归	v	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
std	eng	O
:	x	O
:	x	O
cout	eng	O
<	x	O
<	x	O
in	eng	O
[	x	O
yy	eng	O
]	x	O
;	x	O
 	x	O
/	x	O
/	x	O
输出	v	O
当前	t	O
序列	n	O
最后	f	O
一个	m	O
字符	n	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O
 	x	O
 	x	O
/	x	O
/	x	O
当前	t	O
序列	n	O
需要	v	O
分成	v	O
两	m	O
部分	n	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
int	eng	O
 	x	O
tmp	eng	O
 	x	O
=	x	O
 	x	O
mem	eng	O
[	x	O
xx	eng	O
]	x	O
[	x	O
yy	eng	O
]	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
分割	v	O
的	uj	O
下标	v	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
find	eng	O
(	x	O
xx	eng	O
,	x	O
 	x	O
tmp	eng	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
find	eng	O
(	x	O
tmp	eng	O
+	x	O
1	m	O
,	x	O
 	x	O
yy	eng	O
)	x	O
;	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
return	eng	O
;	x	O

	x	O
 	x	O

	x	O
}	x	O

	x	O
 	x	O

	x	O
int	eng	O
 	x	O
main	eng	O
(	x	O
)	x	O

	x	O
 	x	O

	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
std	eng	O
:	x	O
:	x	O
cin	eng	O
>	x	O
>	x	O
in	eng	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
int	eng	O
 	x	O
len	eng	O
 	x	O
=	x	O
 	x	O
in	eng	O
.	m	O
length	eng	O
(	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
memset	eng	O
(	x	O
flag	eng	O
,	x	O
 	x	O
0	x	O
,	x	O
 	x	O
sizeof	eng	O
(	x	O
flag	eng	O
)	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
memset	eng	O
(	x	O
mem	eng	O
,	x	O
 	x	O
-	x	O
1	x	O
,	x	O
 	x	O
sizeof	eng	O
(	x	O
mem	eng	O
)	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
k	x	O
=	x	O
0	x	O
;	x	O
 	x	O
k	x	O
<	x	O
len	eng	O
;	x	O
 	x	O
k	eng	O
++	x	O
)	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
=	x	O
0	x	O
,	x	O
 	x	O
j	x	O
=	x	O
k	x	O
;	x	O
 	x	O
j	x	O
<	x	O
len	eng	O
;	x	O
 	x	O
i	eng	O
++	x	O
,	x	O
 	x	O
j	eng	O
++	x	O
)	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
i	x	O
 	x	O
=	x	O
=	x	O
 	x	O
j	x	O
)	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
flag	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O
 	x	O
 	x	O
/	x	O
/	x	O
记录	n	O
in	eng	O
[	x	O
i	x	O
]	x	O
到	v	O
in	eng	O
[	x	O
j	x	O
]	x	O
中间	f	O
字符	n	O
的	uj	O
个数	n	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
int	eng	O
 	x	O
tmp	eng	O
 	x	O
=	x	O
 	x	O
10000000	m	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
(	x	O
in	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
(	x	O
'	x	O
 	x	O
&&	x	O
 	x	O
in	eng	O
[	x	O
j	x	O
]	x	O
=	x	O
=	x	O
'	x	O
)	x	O
'	x	O
)	x	O
 	x	O
|	x	O
|	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
(	x	O
in	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
[	x	O
'	x	O
 	x	O
&&	x	O
 	x	O
in	eng	O
[	x	O
j	x	O
]	x	O
=	x	O
=	x	O
'	x	O
]	x	O
'	x	O
)	x	O
)	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
tmp	eng	O
 	x	O
=	x	O
 	x	O
min	eng	O
(	x	O
tmp	eng	O
,	x	O
 	x	O
flag	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
)	x	O
;	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
只要	c	O
当前	t	O
序列	n	O
S	eng	O
的	uj	O
长度	ns	O
大于	d	O
1	x	O
，	x	O
都	d	O
可以	c	O
把	p	O
S	eng	O
分成	v	O
两	m	O
部分	n	O
：	x	O
Si	eng	O
...	m	O
Sk	eng	O
和	c	O
Sk	eng	O
+	x	O
1	m	O
(	x	O
下标	v	O
)	x	O
...	m	O
Sj	eng	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
然后	c	O
分别	d	O
将子	n	O
序列	n	O
变成	v	O
规则	n	O
序列	n	O
，	x	O
则	d	O
拼接	v	O
在	p	O
一起	m	O
的	uj	O
就是	d	O
规则	n	O
序列	n	O
了	ul	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
t	x	O
=	x	O
i	x	O
;	x	O
 	x	O
t	x	O
<	x	O
j	x	O
;	x	O
 	x	O
t	eng	O
++	x	O
)	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
tmp	eng	O
>	x	O
flag	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
t	x	O
]	x	O
 	x	O
+	x	O
 	x	O
flag	eng	O
[	x	O
t	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
/	x	O
/	x	O
找出	v	O
字符	n	O
数	n	O
最小值	l	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
tmp	eng	O
 	x	O
=	x	O
 	x	O
flag	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
t	x	O
]	x	O
 	x	O
+	x	O
 	x	O
flag	eng	O
[	x	O
t	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
]	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
t	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
记录	n	O
分割	v	O
的	uj	O
下标	v	O
t	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
flag	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
tmp	eng	O
;	x	O
/	x	O
/	x	O
in	eng	O
[	x	O
i	x	O
]	x	O
到	v	O
in	eng	O
[	x	O
j	x	O
]	x	O
间	f	O
字符	n	O
数	m	O
为	p	O
tmp	eng	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
find	eng	O
(	x	O
0	x	O
,	x	O
 	x	O
len	eng	O
-	x	O
1	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
std	eng	O
:	x	O
:	x	O
cout	eng	O
<	x	O
<	x	O
std	eng	O
:	x	O
:	x	O
endl	eng	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
system	eng	O
(	x	O
"	x	O
pause	eng	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
return	eng	O
 	x	O
0	x	O
;	x	O
 	x	O

	x	O
 	x	O

	x	O
}	x	O
 	x	O

	x	O