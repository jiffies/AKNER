POJ2904 题解_forsona&Sona的POJ题解_百度空间

POJ2904 题解 ——人定顺天
首先 我觉得这道题目的意思不是那么容易理解，至少相当容易产生歧义。
大意是给定一个盒子和它可以容纳爆竹数量最大值的上限m（不是最大值，也就是这个最大容纳量在1..m区间内）。测试的时候提供给了你k个盒子，要求利用这些有限的实验盒测试出这类盒子容纳爆竹数的最大值……
盒子只有爆炸和完好无损两种状态（只要你没把它炸飞你就当它还是新的）
挺复杂吧。是有一点实际问题的含义在里面。
简单的举个例子 如果答案限定在l..r范围内而k==1，只给了你一个盒子，你需要从l开始一个一个小心翼翼的测试，如果不幸的是容量上限是r的话，你一共需要(l+r)(r-l+1)/2个爆竹
下面开始DP，dp[k][l][r]表示还剩下k个盒子 ，放l-1个爆竹会爆炸（后面转移的时候你会看到 如果放n个盒子会爆炸的话，那么后面就不需要再考虑n的情况了 这是显然的 我一开始还怎么都理解不了），通俗点说就是答案范围在(l-1,r)之间的情况下 最坏需要的爆竹至少是多少
这个地方看上去像一个最小最大 事实上是人和自然的博弈
人定不胜天，但是人要有和自然博弈的勇气，去追求了解认识自然，在顺应自然的同时改变自然……
老天的意思不可违背，所以我们只能从 l 到 r 枚举下一次测试放入的爆竹数目，然后分炸飞了和完好无损两种情况讨论，天意不可知，要取两种情况最大值保留
人有顺应天时的策略，我们可以对于这l到r的枚举得到的两种情况最大值取最小值 也就是得到一个最坏情况下的最优策略。人定顺天，我们可以在最糟糕的情况下获得最好的结果
转化成一个不算很典型的最小最大问题（本来想想不是二分答案，后来发现从头到位都是在二分答案甚至题目给的就是范围，只不过这个二分没有那么暴力）
状态转移方程其实并不难
Dp(k,l,r)=min ( n+ max ( Dp(k,n+1,r) , Dp(k-1,l,n-1) )     l<=n<=r
下面是我的代码
Source Code
 Problem: 2904 User: Sona Memory: 1220K Time: 94MS Language: G++ Result: Accepted 

 
 Source Code #include"iostream"#include"cstdio"#include"algorithm"#include"cstring" using namespace std;int mint[11][111][111];int dp(int k,int l,int r){ int n,i; if (mint[k][l][r]>=0) return mint[k][l][r]; if (k==1) return mint[1][l][r]=(r-l+1)*(r+l)/2; if (l>r) return mint[k][l][r]=0; mint[k][l][r]=99999999;//l+dp(k,l+1,r); for(n=l;n<=r;n++) mint[k][l][r]=min(n+max(dp(k,n+1,r),dp(k-1,l,n-1)),mint[k][l][r]); return mint[k][l][r]; }int main(){ int t,k,n; scanf("%d",&t); while(t--) { scanf("%d%d",&k,&n); memset(mint,-1,sizeof(mint)); printf("%d\n",dp(k,1,n)); } return 0; } 
