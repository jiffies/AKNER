poj1141	eng	B-OJ
 	x	O
-	x	O
 	x	O
zhang20072844	eng	O
的	uj	O
专栏	n	O
 	x	O
-	x	O
 	x	O
博客	nr	O
频道	n	O
 	x	O
-	x	O
 	x	O
CSDN	eng	O
.	m	O
NET	eng	O

	x	O

	x	O
这	r	O
道	q	O
题目	n	O
是	v	O
黑	a	O
书上	s	O
的	uj	O
原题	n	O
，	x	O
设	n	O
dp	eng	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
为从	p	O
位置	v	O
i	eng	O
到	v	O
位置	v	O
j	x	O
需要	v	O
加入	v	O
字符	n	O
的	uj	O
最小	a	O
次数	n	O
，	x	O
有	v	O
dp	eng	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
=	x	O
min	eng	O
(	x	O
dp	eng	O
[	x	O
i	x	O
,	x	O
k	x	O
]	x	O
+	x	O
dp	eng	O
[	x	O
k	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
]	x	O
)	x	O
，	x	O
其中	r	O
i	x	O
<	x	O
=	x	O
k	x	O
<	x	O
j	x	O
。	x	O

特别	d	O
的	uj	O
当	t	O
s	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
'	x	O
[	x	O
'	x	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
]	x	O
'	x	O
或者	c	O
s	x	O
[	x	O
i	x	O
]	x	O
=	x	O
'	x	O
(	x	O
'	x	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
=	x	O
'	x	O
)	x	O
'	x	O
时	n	O
，	x	O
dp	eng	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
=	x	O
dp	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
-	x	O
1	x	O
]	x	O
。	x	O

初始条件	l	O
为	p	O
dp	eng	O
[	x	O
i	x	O
,	x	O
i	x	O
]	x	O
=	x	O
1	x	O
，	x	O
其中	r	O
0	x	O
<	x	O
=	x	O
i	x	O
<	x	O
len	eng	O
。	x	O

	x	O
/	x	O
/	x	O
本题	n	O
是	v	O
自	r	O
底向上	l	O
的	uj	O
dp	eng	O
，	x	O
还	d	O
可以	c	O
用	p	O
记忆	n	O
化	n	O
搜索	v	O
的	uj	O
方法	n	O

	x	O
#	x	O
include	eng	O
<	x	O
iostream	eng	O
>	x	O

	x	O
#	x	O
include	eng	O
<	x	O
cstdio	eng	O
>	x	O

	x	O
#	x	O
include	eng	O
<	x	O
cstring	eng	O
>	x	O

	x	O
using	eng	O
 	x	O
namespace	eng	O
 	x	O
std	eng	O
;	x	O

	x	O
const	eng	O
 	x	O
int	eng	O
 	x	O
V	x	O
=	x	O
110	m	O
;	x	O

	x	O
char	eng	O
 	x	O
str	eng	O
[	x	O
V	x	O
]	x	O
;	x	O

	x	O
int	eng	O
 	x	O
dp	eng	O
[	x	O
V	x	O
]	x	O
[	x	O
V	x	O
]	x	O
,	x	O
path	eng	O
[	x	O
V	x	O
]	x	O
[	x	O
V	x	O
]	x	O
;	x	O

	x	O
void	eng	O
 	x	O
oprint	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
,	x	O
int	eng	O
 	x	O
j	x	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
if	eng	O
(	x	O
i	x	O
>	x	O
j	x	O
)	x	O
return	eng	O
;	x	O
/	x	O
/	x	O
返回	v	O

	x	O
 	x	O
if	eng	O
(	x	O
i	x	O
=	x	O
=	x	O
j	x	O
)	x	O

	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
str	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
[	x	O
'	x	O
|	x	O
|	x	O
str	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
]	x	O
'	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
[	x	O
]	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
else	eng	O

	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
(	x	O
)	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
}	x	O

	x	O
 	x	O
else	eng	O
 	x	O
if	eng	O
(	x	O
path	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
=	x	O
-	x	O
1	x	O
)	x	O
/	x	O
/	x	O
如果	c	O
是	v	O
-	x	O
1	x	O
表示	v	O
i	x	O
，	x	O
j	x	O
匹配	v	O
递归	v	O
输出	v	O

	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
%	x	O
c	x	B-KNOWLEDGE
"	x	I-KNOWLEDGE
,	x	O
str	eng	O
[	x	O
i	x	O
]	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
oprint	eng	O
(	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
-	x	O
1	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
%	x	O
c	x	O
"	x	O
,	x	O
str	eng	O
[	x	O
j	x	O
]	x	O
)	x	O
;	x	O

	x	O
 	x	O
}	x	O

	x	O
 	x	O
else	eng	O
/	x	O
/	x	O
否则	c	O
i	eng	O
到	v	O
k	eng	O
，	x	O
k	eng	O
+	x	O
1	m	O
到	v	O
j	eng	O
，	x	O
而	c	O
k	eng	O
=	x	O
path	eng	O
【	x	O
i	x	O
】	x	O
【	x	O
j	x	O
】	x	O

	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
oprint	eng	O
(	x	O
i	x	O
,	x	O
path	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
oprint	eng	O
(	x	O
path	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
+	x	O
1	m	O
,	x	O
j	x	O
)	x	O
;	x	O

	x	O
 	x	O
}	x	O

	x	O
}	x	O

	x	O
int	eng	O
 	x	O
main	eng	O
(	x	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
int	eng	O
 	x	O
i	x	O
,	x	O
j	x	O
,	x	O
k	x	O
,	x	O
r	x	O
,	x	O
n	x	O
;	x	O

	x	O
 	x	O
while	eng	O
(	x	O
gets	eng	O
(	x	O
str	eng	O
)	x	O
)	x	O

	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
n	x	O
=	x	O
strlen	eng	O
(	x	O
str	eng	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
n	x	O
=	x	O
=	x	O
0	x	O
)	x	O
/	x	O
/	x	O
注意	v	O
有	v	O
空行	n	O
，	x	O
WA	eng	O
了	ul	O
很多遍	m	O
啊	zg	O
。	x	O

	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
/	x	O
n	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
continue	eng	O
;	x	O

	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
memset	eng	O
(	x	O
dp	eng	O
,	x	O
0	x	O
,	x	O
sizeof	eng	O
(	x	O
dp	eng	O
)	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	x	O
<	x	O
n	x	O
;	x	O
i	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
dp	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
]	x	O
=	x	O
1	x	O
;	x	O

	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
r	x	O
=	x	O
1	x	O
;	x	O
r	x	O
<	x	O
n	x	O
;	x	O
r	eng	O
++	x	O
)	x	O
/	x	O
/	x	O
相当于	v	O
从小	d	O
的	uj	O
区间	n	O
去	v	O
递推	v	O
大	a	O
的	uj	O
区间	n	O
知道	v	O
整个	b	O
字符串	n	O
，	x	O
自	p	O
底向上	l	O
的	uj	O
方法	n	O
r	x	O
表示	v	O
区间	n	O
的	uj	O
长度	ns	O
，	x	O
从	p	O
1	m	O
到	v	O
n	eng	O
-	x	O
1	x	O

	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	x	O
<	x	O
n	x	O
-	x	O
r	x	O
;	x	O
i	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
j	x	O
=	x	O
i	eng	O
+	x	O
r	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
dp	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
99999999	m	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
(	x	O
str	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
(	x	O
'	x	O
&&	x	O
str	eng	O
[	x	O
j	x	O
]	x	O
=	x	O
=	x	O
'	x	O
)	x	O
'	x	O
)	x	O
|	x	O
|	x	O
(	x	O
str	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
[	x	O
'	x	O
&&	x	O
str	eng	O
[	x	O
j	x	O
]	x	O
=	x	O
=	x	O
'	x	O
]	x	O
'	x	O
)	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
dp	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
>	x	O
dp	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
dp	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
dp	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
path	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
-	x	O
1	x	O
;	x	O
/	x	O
/	x	O
path	eng	O
=	x	O
-	x	O
1	x	O
表示	v	O
i	x	O
，	x	O
j	x	O
匹配	v	O
了	ul	O
。	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
k	x	O
=	x	O
i	x	O
;	x	O
k	x	O
<	x	O
j	x	O
;	x	O
k	eng	O
++	x	O
)	x	O
/	x	O
/	x	O
dp	eng	O
求	v	O
最值	n	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
dp	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
>	x	O
dp	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
k	x	O
]	x	O
+	x	O
dp	eng	O
[	x	O
k	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
dp	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	B-KNOWLEDGE
=	x	I-KNOWLEDGE
dp	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
k	x	O
]	x	O
+	x	O
dp	eng	O
[	x	O
k	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
]	x	O
,	x	O
path	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
k	x	O
;	x	O
/	x	O
/	x	O
path	eng	O
表示	v	O
i	x	O
，	x	O
j	x	O
之间	f	O
从	p	O
k	eng	O
分开	v	O

	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
oprint	eng	O
(	x	O
0	x	O
,	x	O
n	x	O
-	x	O
1	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
/	x	O
n	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
}	x	O

	x	O
 	x	O
return	eng	O
 	x	O
0	x	O
;	x	O

	x	O
}	x	O

	x	O