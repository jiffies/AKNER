pku 1141 Brackets Sequence(DP) - low coder - 博客频道 - CSDN.NET

 
首先，大家都来鄙视我吧，这道题目我花了一天时间才勉强 AC 。 
 
题目大意 : 输入一个由‘ ( ’、‘  ) ’、‘  [ ’、‘  ] ’  4 种符号构成的杂乱序列，通过给这个序列在恰当的位置增加一些‘ ( ’、‘  ) ’、‘  [ ’、‘  ] ’，可以使原来的序列变成 regular sequence （即是通常意义上的括号配对）。输出在原序列基础上增添后的 regular sequence ，要求增加的符号尽量少。（结果可能有很多种，只要输出其中的一种就可以了） 
 
分析： 
 
DP ， int state[i][j] 表示将原序列中第 i 至第 j 个符号变为 regular sequence 后，总共的符号数量， string ans[i][j]  表示将原序列中以第 i 至第 j 个符号变换成的 regular sequence 。 
 
If A and B are regular sequences, then AB is a regular sequence.  
 
于是有 state[i][j]=min(state[i][k]+state[k+1][j]) ，其中 i<=k<j 。 
 
If S is a regular sequence, then (S) and [S] are both regular sequences. 
 
于是如果 sym[i] 和 sym[j] 本身就是配对的 ， 那么 state[i][j]=min(state[i][j],state[i+1][j-1]+2) 。（我一开始想如果 sym[i] 和 sym[j] 本身就是配对的 , 那么肯定 state[i][j]= state[i+1][j-1]+2) ，其实不然，比如说“ ()() ”， i=1,j=4 这种情况）。 
 
还有，以前不知道在 C++ 中有个这样好用的 string 类型（囧），是这次看别人代码才会用的。 
 
#include <iostream>
using namespace std;
#include <string>
#define LeftMatch(x) (x=='('?')':']')
#define IfMatch(x,y) (y==LeftMatch(x)?1:0)
void Init();
void DP();
char sym[105];
int count[105][105];
string ans[105][105];
int n;
int main()
{
	cin.getline(sym+1,105);
	Init();
	DP();
	cout<<ans[1][n]<<endl;
	return 0;
}
void Init()
{
	n=strlen(sym+1);
	memset(count,0,sizeof(count));
	for(int i=1;i<=n;i++)
	{
		count[i][i]=2;
		if(sym[i]=='('||sym[i]==')') ans[i][i]="()";
		else ans[i][i]="[]";
	}
}
void DP()
{
	for(int l=1;l<n;l++)
	{
		for(int i=1;i+l<=n;i++)
		{
			count[i][i+l]=INT_MAX;
			if((sym[i]=='('||sym[i]=='[')&&IfMatch(sym[i],sym[i+l]))
			{
				count[i][i+l]=count[i+1][i+l-1]+2;
				if(sym[i]=='(') ans[i][i+l]='('+ans[i+1][i+l-1]+')';
				else ans[i][i+l]='['+ans[i+1][i+l-1]+']';
			}
			for(int k=i;k<i+l;k++)
			{
				if(count[i][i+l]>count[i][k]+count[k+1][i+l])
				{
					count[i][i+l]=count[i][k]+count[k+1][i+l];
					ans[i][i+l]=ans[i][k]+ans[k+1][i+l];
				}
			}
		}
	}
}
