pku 1141 Bracket sequence_lunzi_新浪博客


 Brackets Sequence
 
 
  
   
    
    Time Limit: 1000MS 
     
    Memory Limit: 65536K 
    
    
    Total Submissions: 12652 
     
    Accepted: 3398 
     
    Special Judge 
    
   
  
 

Description
 

 Let us define a regular brackets sequence in the following way:
 
 1. Empty sequence is a regular sequence.
 
 2. If S is a regular sequence, then (S) and [S] are both regular sequences.
 
 3. If A and B are regular sequences, then AB is a regular sequence.
 
 For example, all of the following sequences of characters are regular brackets sequences:
 
 (), [], (()), ([]), ()[], ()[()]
 
 And all of the following character sequences are not:
 
 (, [, ), )(, ([)], ([(]
 
 Some sequence of characters '(', ')', '[', and ']' is given. You are to find the shortest possible regular brackets sequence, that contains the given character sequence as a subsequence. Here, a string a1 a2 ... an is called a subsequence of the string b1 b2 ... bm, if there exist such indices 1 = i1 < i2 < ... < in = m, that aj = bij for all 1 = j = n.
 

Input
 

 The input file contains at most 100 brackets (characters '(', ')', '[' and ']') that are situated on a single line without any other characters among them.
 

Output
 

 Write to the output file a single line that contains some regular brackets sequence that has the minimal possible length and contains the given sequence as a subsequence.
 

Sample Input
([(]
Sample Output
()[()]
/这个实在是想不出怎么做
//只能参考参考再参考。。。。。
//lrj的黑书中有详细讲解，不过没有输出结果那块，
//用mem[][]数组来记录下标i,j之间应插入的括号数目
//当i==j时，只有一个单括号，显然应加一个，故值为1
//当brt[i]==brt[j]时刚好i,j配对,故值为min{mem[i][j],mem[i+1][j-1]}
//其他情况，就需要在brt[i]和brt[j]间设置分割点t,值为min{mem[i][j],mem[i][t]+mem[t+1][j]}
#include<cstdlib>
#include<string>
#include<string.h>
using namespace std;
const int N=105;
char brt[N];//记录输入的括号序列
int mem[N][N]={0};//记忆数组，记录下标i到下标j之间所需添加的最少括号数
int back[N][N]={0};//用于记录分割位置，并回溯输出结果
void backtrack(int i,int j);//递归函数输出结果
int main()
{
 scanf("%s",&brt);
 int n=strlen(brt);
 for(int i=1;i<n;i++)//当左下标大于右下标时置为0
  mem[i][i-1]=0;
 for(int i=0;i<n;i++)//左右下标一致时，相当于只有一个单括号，故都需要添加一个
  mem[i][i]=1;
 for(int k=1;k<n;k++)//相当于设置的是i和j之间的间隔大小，从1到n-1
 {
  int bd=n-k;//k确定后，i的可能取值小于bd,因j要小于n
  for(int i=0;i<bd;i++)
  {
   int j=i+k;//左下标i加上间隔k得到右下标
   mem[i][j]=0x7fffffff;
   string ss="";
      ss+=brt[i];ss+=brt[j];
      if(ss=="()" || ss=="[]")//若i、j两括号恰能配对   
   {
    if(mem[i][j]>mem[i+1][j-1])//看mem[i][j]和[i+1,j-1]之间需要
的添加数谁大
    {
     mem[i][j]=mem[i+1][j-1];
     back[i][j]=-1;
    }
   }
   for(int r=i;r<j;r++)//在左下标和右下标之间枚举所有分割点r，取
[i,r]+[r+1,j]最小者
   {
    int gg=mem[i][r]+mem[r+1][j];
    if(mem[i][j]>gg)
    {
     mem[i][j]=gg;
        back[i][j]=r;//记录满足要求的分割位置
    }
   }
  }
 }
 backtrack(0,n-1);
 printf("\n");
 return 0;
}
void backtrack(int i,int j)
{
 if(i>j)
  return;
 if(i==j)//即只有一个括号时
  if(brt[i]=='(' || brt[i]==')')
   printf("()");
  else
   printf("[]");
 else if(back[i][j]==-1)//i、j刚好配对时
 {
  printf("%c",brt[i]);//输出i
  backtrack(i+1,j-1);//[i+1,j-1]间递归求解
  printf("%c",brt[j]);//输出j
 }
 else
 {
  backtrack(i,back[i][j]);//在分割位置前递归求解
  backtrack(back[i][j]+1,j);//在分割位置后递归求解
 }
}
