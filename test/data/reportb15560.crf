pku	eng	B-OJ
 	x	I-OJ
1141	m	I-OJ
 	x	O
Bracket	eng	O
 	x	O
sequence	eng	O
_	x	O
lunzi	eng	O
_	x	O
新浪	nz	O
博客	nr	O

	x	O

	x	O

	x	O
 	x	O
Brackets	eng	O
 	x	O
Sequence	eng	O

	x	O
 	x	O

	x	O
 	x	O

	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Time	eng	O
 	x	O
Limit	eng	O
:	x	O
 	x	O
1000	m	O
MS	eng	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Memory	eng	O
 	x	O
Limit	eng	O
:	x	O
 	x	O
65536	m	O
K	eng	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Total	eng	O
 	x	O
Submissions	eng	O
:	x	O
 	x	O
12652	m	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Accepted	eng	O
:	x	O
 	x	O
3398	m	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Special	eng	O
 	x	O
Judge	eng	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O

	x	O
 	x	O

	x	O

	x	O
Description	eng	O

	x	O
 	x	O

	x	O

	x	O
 	x	O
Let	eng	O
 	x	O
us	eng	O
 	x	O
define	eng	O
 	x	O
a	x	O
 	x	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
 	x	O
in	eng	O
 	x	O
the	eng	O
 	x	O
following	eng	O
 	x	O
way	eng	O
:	x	O

	x	O
 	x	O

	x	O
 	x	O
1.	m	O
 	x	O
Empty	eng	O
 	x	O
sequence	eng	O
 	x	O
is	eng	O
 	x	O
a	x	O
 	x	O
regular	eng	O
 	x	O
sequence	eng	O
.	m	O

	x	O
 	x	O

	x	O
 	x	O
2.	m	O
 	x	O
If	eng	O
 	x	O
S	x	O
 	x	O
is	eng	O
 	x	O
a	x	O
 	x	O
regular	eng	O
 	x	O
sequence	eng	O
,	x	O
 	x	O
then	eng	O
 	x	O
(	x	O
S	x	O
)	x	O
 	x	O
and	eng	O
 	x	O
[	x	O
S	x	O
]	x	O
 	x	O
are	eng	O
 	x	O
both	eng	O
 	x	O
regular	eng	O
 	x	O
sequences	eng	O
.	m	O

	x	O
 	x	O

	x	O
 	x	O
3.	m	O
 	x	O
If	eng	O
 	x	O
A	x	O
 	x	O
and	eng	O
 	x	O
B	x	O
 	x	O
are	eng	O
 	x	O
regular	eng	O
 	x	O
sequences	eng	O
,	x	O
 	x	O
then	eng	O
 	x	O
AB	eng	O
 	x	O
is	eng	O
 	x	O
a	x	O
 	x	O
regular	eng	O
 	x	O
sequence	eng	O
.	m	O

	x	O
 	x	O

	x	O
 	x	O
For	eng	O
 	x	O
example	eng	O
,	x	O
 	x	O
all	eng	O
 	x	O
of	eng	O
 	x	O
the	eng	O
 	x	O
following	eng	O
 	x	O
sequences	eng	O
 	x	O
of	eng	O
 	x	O
characters	eng	O
 	x	O
are	eng	O
 	x	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequences	eng	O
:	x	O

	x	O
 	x	O

	x	O
 	x	O
(	x	O
)	x	O
,	x	O
 	x	O
[	x	O
]	x	O
,	x	O
 	x	O
(	x	O
(	x	O
)	x	O
)	x	O
,	x	O
 	x	O
(	x	O
[	x	O
]	x	O
)	x	O
,	x	O
 	x	O
(	x	O
)	x	O
[	x	O
]	x	O
,	x	O
 	x	O
(	x	O
)	x	O
[	x	O
(	x	O
)	x	O
]	x	O

	x	O
 	x	O

	x	O
 	x	O
And	eng	O
 	x	O
all	eng	O
 	x	O
of	eng	O
 	x	O
the	eng	O
 	x	O
following	eng	O
 	x	O
character	eng	O
 	x	O
sequences	eng	O
 	x	O
are	eng	O
 	x	O
not	eng	O
:	x	O

	x	O
 	x	O

	x	O
 	x	O
(	x	O
,	x	O
 	x	O
[	x	O
,	x	O
 	x	O
)	x	O
,	x	O
 	x	O
)	x	O
(	x	O
,	x	O
 	x	O
(	x	O
[	x	O
)	x	O
]	x	O
,	x	O
 	x	O
(	x	O
[	x	O
(	x	O
]	x	O

	x	O
 	x	O

	x	O
 	x	O
Some	eng	O
 	x	O
sequence	eng	O
 	x	O
of	eng	O
 	x	O
characters	eng	O
 	x	O
'	x	O
(	x	O
'	x	O
,	x	O
 	x	O
'	x	O
)	x	O
'	x	O
,	x	O
 	x	O
'	x	O
[	x	O
'	x	O
,	x	O
 	x	O
and	eng	O
 	x	O
'	x	O
]	x	O
'	x	O
 	x	O
is	eng	O
 	x	O
given	eng	O
.	m	O
 	x	O
You	eng	O
 	x	O
are	eng	O
 	x	O
to	eng	O
 	x	O
find	eng	O
 	x	O
the	eng	O
 	x	O
shortest	eng	O
 	x	O
possible	eng	O
 	x	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
,	x	O
 	x	O
that	eng	O
 	x	O
contains	eng	O
 	x	O
the	eng	O
 	x	O
given	eng	O
 	x	O
character	eng	O
 	x	O
sequence	eng	O
 	x	O
as	eng	O
 	x	O
a	x	O
 	x	O
subsequence	eng	O
.	m	O
 	x	O
Here	eng	O
,	x	O
 	x	O
a	x	O
 	x	O
string	eng	O
 	x	O
a1	eng	O
 	x	O
a2	eng	O
 	x	O
...	m	O
 	x	O
an	eng	O
 	x	O
is	eng	O
 	x	O
called	eng	O
 	x	O
a	x	O
 	x	O
subsequence	eng	O
 	x	O
of	eng	O
 	x	O
the	eng	O
 	x	O
string	eng	O
 	x	O
b1	eng	O
 	x	O
b2	eng	O
 	x	O
...	m	O
 	x	O
bm	eng	O
,	x	O
 	x	O
if	eng	O
 	x	O
there	eng	O
 	x	O
exist	eng	O
 	x	O
such	eng	O
 	x	O
indices	eng	O
 	x	O
1	x	O
 	x	O
=	x	O
 	x	O
i1	eng	O
 	x	O
<	x	O
 	x	O
i2	eng	O
 	x	O
<	x	O
 	x	O
...	m	O
 	x	O
<	x	O
 	x	O
in	eng	O
 	x	O
=	x	O
 	x	O
m	x	O
,	x	O
 	x	O
that	eng	O
 	x	O
aj	eng	O
 	x	O
=	x	O
 	x	O
bij	eng	O
 	x	O
for	eng	O
 	x	O
all	eng	O
 	x	O
1	x	O
 	x	O
=	x	O
 	x	O
j	x	O
 	x	O
=	x	O
 	x	O
n	eng	O
.	m	O

	x	O
 	x	O

	x	O

	x	O
Input	eng	O

	x	O
 	x	O

	x	O

	x	O
 	x	O
The	eng	O
 	x	O
input	eng	O
 	x	O
file	eng	O
 	x	O
contains	eng	O
 	x	O
at	eng	O
 	x	O
most	eng	O
 	x	O
100	m	O
 	x	O
brackets	eng	O
 	x	O
(	x	O
characters	eng	O
 	x	O
'	x	O
(	x	O
'	x	O
,	x	O
 	x	O
'	x	O
)	x	O
'	x	O
,	x	O
 	x	O
'	x	O
[	x	O
'	x	O
 	x	O
and	eng	O
 	x	O
'	x	O
]	x	O
'	x	O
)	x	O
 	x	O
that	eng	O
 	x	O
are	eng	O
 	x	O
situated	eng	O
 	x	O
on	eng	O
 	x	O
a	x	O
 	x	O
single	eng	O
 	x	O
line	eng	O
 	x	O
without	eng	O
 	x	O
any	eng	O
 	x	O
other	eng	O
 	x	O
characters	eng	O
 	x	O
among	eng	O
 	x	O
them	eng	O
.	m	O

	x	O
 	x	O

	x	O

	x	O
Output	eng	O

	x	O
 	x	O

	x	O

	x	O
 	x	O
Write	eng	O
 	x	O
to	eng	O
 	x	O
the	eng	O
 	x	O
output	eng	O
 	x	O
file	eng	O
 	x	O
a	x	O
 	x	O
single	eng	O
 	x	O
line	eng	O
 	x	O
that	eng	O
 	x	O
contains	eng	O
 	x	O
some	eng	O
 	x	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
 	x	O
that	eng	O
 	x	O
has	eng	O
 	x	O
the	eng	O
 	x	O
minimal	eng	O
 	x	O
possible	eng	O
 	x	O
length	eng	O
 	x	O
and	eng	O
 	x	O
contains	eng	O
 	x	O
the	eng	O
 	x	O
given	eng	O
 	x	O
sequence	eng	O
 	x	O
as	eng	O
 	x	O
a	x	O
 	x	O
subsequence	eng	O
.	m	O

	x	O
 	x	O

	x	O

	x	O
Sample	eng	O
 	x	O
Input	eng	O

	x	O
(	x	O
[	x	O
(	x	O
]	x	O

	x	O
Sample	eng	O
 	x	O
Output	eng	O

	x	O
(	x	O
)	x	O
[	x	O
(	x	O
)	x	O
]	x	O

	x	O
/	x	O
这个	r	O
实在	v	O
是	v	O
想不出	v	O
怎么	r	O
做	v	O

	x	O
/	x	O
/	x	O
只能	v	O
参考	v	O
参考	v	O
再	d	O
参考	v	O
。	x	O
。	x	O
。	x	O
。	x	O
。	x	O

	x	O
/	x	O
/	x	O
lrj	eng	O
的	uj	O
黑书	n	O
中	f	O
有	v	O
详细	ad	O
讲解	v	O
，	x	O
不过	c	O
没有	v	O
输出	v	O
结果	n	O
那	r	O
块	zg	O
，	x	O

	x	O
/	x	O
/	x	O
用	p	O
mem	eng	O
[	x	O
]	x	O
[	x	O
]	x	O
数组	n	O
来	v	O
记录	n	O
下标	v	O
i	x	O
,	x	O
j	x	O
之间	f	O
应	v	O
插入	v	O
的	uj	O
括号	n	O
数目	n	O

	x	O
/	x	O
/	x	O
当	t	O
i	eng	O
=	x	O
=	x	O
j	eng	O
时	n	O
，	x	O
只有	c	O
一个	m	O
单	n	O
括号	n	O
，	x	O
显然	ad	O
应	v	O
加	v	O
一个	m	O
，	x	O
故值	n	O
为	p	O
1	m	O

	x	O
/	x	O
/	x	O
当	t	O
brt	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
brt	eng	O
[	x	O
j	x	O
]	x	O
时	n	O
刚好	d	O
i	x	O
,	x	O
j	x	O
配对	v	O
,	x	O
故值	n	O
为	p	O
min	eng	O
{	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
,	x	O
mem	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
}	x	O

	x	O
/	x	O
/	x	O
其他	r	O
情况	n	O
，	x	O
就	d	O
需要	v	O
在	p	O
brt	eng	O
[	x	O
i	x	O
]	x	O
和	c	O
brt	eng	O
[	x	O
j	x	O
]	x	O
间	f	O
设置	vn	O
分割	v	O
点	m	O
t	eng	O
,	x	O
值为	v	O
min	eng	O
{	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
,	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
t	x	O
]	x	O
+	x	O
mem	eng	O
[	x	O
t	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
]	x	O
}	x	O

	x	O
#	x	O
include	eng	O
<	x	O
cstdlib	eng	O
>	x	O

	x	O
#	x	O
include	eng	O
<	x	O
string	eng	O
>	x	O

	x	O
#	x	O
include	eng	O
<	x	O
string	eng	O
.	m	O
h	eng	O
>	x	O

	x	O
using	eng	O
 	x	O
namespace	eng	O
 	x	O
std	eng	O
;	x	O

	x	O
const	eng	O
 	x	O
int	eng	O
 	x	O
N	x	O
=	x	O
105	m	O
;	x	O

	x	O
char	eng	O
 	x	O
brt	eng	O
[	x	O
N	x	O
]	x	O
;	x	O
/	x	O
/	x	O
记录	n	O
输入	v	O
的	uj	O
括号	n	O
序列	n	O

	x	O
int	eng	O
 	x	O
mem	eng	O
[	x	O
N	x	O
]	x	O
[	x	O
N	x	O
]	x	O
=	x	O
{	x	O
0	x	O
}	x	O
;	x	O
/	x	O
/	x	O
记忆	n	O
数组	n	O
，	x	O
记录	n	O
下标	v	O
i	eng	O
到	v	O
下标	v	O
j	x	O
之间	f	O
所	c	O
需	v	O
添加	v	O
的	uj	O
最少	d	O
括号	n	O
数	n	O

	x	O
int	eng	O
 	x	O
back	eng	O
[	x	O
N	x	O
]	x	O
[	x	O
N	x	O
]	x	O
=	x	O
{	x	O
0	x	O
}	x	O
;	x	O
/	x	O
/	x	O
用于	v	O
记录	n	O
分割	v	O
位置	v	O
，	x	O
并	c	O
回溯	v	O
输出	v	O
结果	n	O

	x	O
void	eng	O
 	x	O
backtrack	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
,	x	O
int	eng	O
 	x	O
j	x	O
)	x	O
;	x	O
/	x	O
/	x	O
递归函数	l	O
输出	v	O
结果	n	O

	x	O
int	eng	O
 	x	O
main	eng	O
(	x	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
scanf	eng	O
(	x	O
"	x	O
%	x	O
s	x	O
"	x	O
,	x	O
&	x	B-KNOWLEDGE
brt	eng	I-KNOWLEDGE
)	x	O
;	x	O

	x	O
 	x	O
int	eng	O
 	x	O
n	x	O
=	x	O
strlen	eng	O
(	x	O
brt	eng	O
)	x	O
;	x	O

	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
=	x	O
1	x	O
;	x	O
i	x	O
<	x	O
n	x	O
;	x	O
i	eng	O
++	x	O
)	x	O
/	x	O
/	x	O
当	p	O
左	m	O
下标	v	O
大于	d	O
右	f	O
下标	v	O
时置	n	O
为	p	O
0	m	O

	x	O
 	x	O
 	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
-	x	O
1	x	O
]	x	O
=	x	O
0	x	O
;	x	O

	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	x	O
<	x	O
n	x	O
;	x	O
i	eng	O
++	x	O
)	x	O
/	x	O
/	x	O
左右	m	O
下标	v	O
一致	d	O
时	n	O
，	x	O
相当于	v	O
只有	c	O
一个	m	O
单	n	O
括号	n	O
，	x	O
故都	d	O
需要	v	O
添加	v	O
一个	m	O

	x	O
 	x	O
 	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
]	x	O
=	x	O
1	x	O
;	x	O

	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
k	x	O
=	x	O
1	x	O
;	x	O
k	x	O
<	x	O
n	x	O
;	x	O
k	eng	O
++	x	O
)	x	O
/	x	O
/	x	O
相当于	v	O
设置	vn	O
的	uj	O
是	v	O
i	eng	O
和	c	O
j	eng	O
之间	f	O
的	uj	O
间隔	n	O
大小	b	O
，	x	O
从	p	O
1	m	O
到	v	O
n	eng	O
-	x	O
1	x	O

	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
int	eng	O
 	x	O
bd	eng	O
=	x	O
n	x	O
-	x	O
k	x	O
;	x	O
/	x	O
/	x	O
k	x	O
确定	v	O
后	f	O
，	x	O
i	eng	O
的	uj	O
可能	v	O
取值	v	O
小于	v	O
bd	eng	O
,	x	O
因	c	O
j	eng	O
要	v	O
小于	v	O
n	x	O

	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	x	O
<	x	O
bd	eng	O
;	x	O
i	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
int	eng	O
 	x	O
j	x	O
=	x	O
i	eng	O
+	x	O
k	eng	O
;	x	O
/	x	O
/	x	O
左	m	O
下标	v	O
i	x	O
加上	v	O
间隔	n	O
k	x	O
得到	v	O
右	f	O
下标	v	O

	x	O
 	x	O
 	x	O
 	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
0	m	O
x7fffffff	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
string	eng	O
 	x	O
ss	eng	O
=	x	O
"	x	O
"	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
ss	eng	O
+	x	O
=	x	O
brt	eng	O
[	x	O
i	x	O
]	x	O
;	x	O
ss	eng	O
+	x	O
=	x	O
brt	eng	O
[	x	O
j	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
ss	eng	O
=	x	O
=	x	O
"	x	O
(	x	O
)	x	O
"	x	O
 	x	O
|	x	O
|	x	O
 	x	O
ss	eng	O
=	x	O
=	x	O
"	x	O
[	x	O
]	x	O
"	x	O
)	x	O
/	x	O
/	x	O
若	c	O
i	eng	O
、	x	O
j	eng	O
两	m	O
括号	n	O
恰能	v	O
配对	v	O
 	x	O
 	x	O
 	x	O

	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
>	x	O
mem	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
)	x	O
/	x	O
/	x	O
看	v	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
和	c	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
-	x	O
1	x	O
]	x	O
之间	f	O
需要	v	O

	x	O
的	uj	O
添加	v	O
数	m	O
谁	r	O
大	d	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
mem	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
back	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
-	x	O
1	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
r	x	O
=	x	O
i	x	O
;	x	O
r	x	O
<	x	O
j	x	O
;	x	O
r	eng	O
++	x	O
)	x	O
/	x	O
/	x	O
在	p	O
左	m	O
下标	v	O
和	c	O
右	n	O
下标	v	O
之间	f	O
枚举	nz	O
所有	b	O
分割	v	O
点	m	O
r	eng	O
，	x	O
取	v	O

	x	O
[	x	O
i	x	O
,	x	O
r	x	O
]	x	O
+	x	O
[	x	O
r	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
]	x	O
最小	a	O
者	k	O

	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
int	eng	O
 	x	O
gg	eng	O
=	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
r	x	O
]	x	O
+	x	O
mem	eng	O
[	x	O
r	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
>	x	O
gg	eng	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
mem	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
gg	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
back	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
r	x	O
;	x	O
/	x	O
/	x	O
记录	n	O
满足要求	l	O
的	uj	O
分割	v	O
位置	v	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
}	x	O

	x	O
 	x	O
backtrack	eng	O
(	x	O
0	x	O
,	x	O
n	x	O
-	x	O
1	x	O
)	x	O
;	x	O

	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
\	x	O
n	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
return	eng	O
 	x	O
0	x	O
;	x	O

	x	O
}	x	O

	x	O
void	eng	O
 	x	O
backtrack	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
,	x	O
int	eng	O
 	x	O
j	x	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
if	eng	O
(	x	O
i	x	O
>	x	O
j	x	O
)	x	O

	x	O
 	x	O
 	x	O
return	eng	O
;	x	O

	x	O
 	x	O
if	eng	O
(	x	O
i	x	O
=	x	O
=	x	O
j	x	O
)	x	O
/	x	O
/	x	O
即	v	O
只有	c	O
一个	m	O
括号	n	O
时	n	O

	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
brt	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
(	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
brt	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
)	x	O
'	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
(	x	O
)	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
else	eng	O

	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
[	x	O
]	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
else	eng	O
 	x	O
if	eng	O
(	x	O
back	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
=	x	O
-	x	O
1	x	O
)	x	O
/	x	O
/	x	O
i	x	O
、	x	O
j	x	O
刚好	d	O
配对	v	O
时	n	O

	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
%	x	O
c	x	O
"	x	O
,	x	O
brt	eng	O
[	x	O
i	x	O
]	x	O
)	x	O
;	x	O
/	x	O
/	x	O
输出	v	O
i	x	O

	x	O
 	x	O
 	x	O
backtrack	eng	O
(	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
-	x	O
1	x	O
)	x	O
;	x	O
/	x	O
/	x	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
-	x	O
1	x	O
]	x	O
间	f	O
递归	v	O
求解	v	O

	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
%	x	O
c	x	O
"	x	O
,	x	O
brt	eng	O
[	x	O
j	x	O
]	x	O
)	x	O
;	x	O
/	x	O
/	x	O
输出	v	O
j	x	O

	x	O
 	x	O
}	x	O

	x	O
 	x	O
else	eng	O

	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
backtrack	eng	O
(	x	O
i	x	O
,	x	O
back	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
;	x	O
/	x	O
/	x	O
在	p	O
分割	v	O
位置	v	O
前	f	O
递归	v	O
求解	v	O

	x	O
 	x	O
 	x	O
backtrack	eng	O
(	x	O
back	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
+	x	O
1	m	O
,	x	O
j	x	O
)	x	O
;	x	O
/	x	O
/	x	O
在	p	O
分割	v	O
位置	v	O
后	f	O
递归	v	O
求解	v	O

	x	O
 	x	O
}	x	O

	x	O
}	x	O

	x	O