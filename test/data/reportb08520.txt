pku 3286(正反dijkstara )_jingtianzi的百度空间_百度空间

考虑到牛还要往回走的情况，可以建立反图让它们返回 ，其实对于这个题来说反图很简单 ， 就是把所有的x ,y 全调换就可以了……调用两次dijkstara 拿下…… Problem: 3268 User: jingtianzi Memory: 4272K Time: 63MS Language: C++ Result: Accepted 

 
 Source Code #include <iostream>using namespace std;#define NNN 1001#define MMM 999999int mp[NNN][NNN];int n, m;int save[10001] ;int dis[10001];void dijkstara ( int start ){ int i, k, index, minnum, parent[NNN]; bool f[NNN]; memset ( f, 0, sizeof(f) ); memset ( parent, 0xff, sizeof(parent) ); for ( i = 0; i < n; i++ ) dis[i] = mp[start][i]; for ( k = 0; k < n-1; k++ ) { for ( minnum = MMM, i = 0; i < n; i++ ) { if ( !f[i] && dis[i] < minnum ) { index = i; minnum = dis[i]; } } if ( minnum == MMM ) break; f[index] = 1; for ( i = 0; i < n; i++ ) { if ( !f[i] && dis[i] > dis[index] + mp[index][i] ){ dis[i] = dis[index] + mp[index][i]; parent[i] = index; } } } for ( i = 0; i < n; i++ ) { save[i] += dis[i];// printf("%d -> %d %d\n", start + 1, i + 1, dis[i]); }}int save_x[10001] , save_y[10000] ,save_map[10000] ;int main(){ int x, y,xx ; while ( scanf("%d%d%d", &n, &m ,&xx) != EOF ) { int i , j ; for ( i = 0; i < n; i++ ) { for ( j = 0; j < n; j++ ) { mp[i][j] = MMM; } } for ( i = 0; i < m; i++ ) { scanf ( "%d%d", &x, &y ); save_x[i] = y ; save_y[i] = x ; scanf ( "%d", &mp[x-1][y-1] ); save_map[i] = mp[x-1][y-1]; } dijkstara(xx - 1); for ( i = 0; i < n; i++ ) { for ( j = 0; j < n; j++ ) { mp[i][j] = MMM; } } for ( i = 0; i < m; i++ ) { mp[save_x[i]-1][save_y[i]-1] = save_map[i] ; } memset(dis , 0 , sizeof(dis)) ; dijkstara(xx - 1); int max = 0 ; for( i = 0 ; i < n ; i++) { if( i != xx - 1) { if(save[i] > max) max = save[i] ; } } cout<<max<<endl; } return 0;} 
