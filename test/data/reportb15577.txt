pku2904（The Mailboxes Manufacturers Problem)_xiao_yu_feng的空间_百度空间

求需要使用多少的爆竹，可以知道箱子的承受能力(用多少个爆竹可以把一个箱子炸坏) 
k个箱子，m个爆竹，每次试验之多使用m个爆竹 
假如k=1， 1+2+...+m=(1+m)*m/2,即最坏的情况的是使用了m个爆竹才把箱子炸坏
k=2,m=4;
1. 用2个爆竹炸 一个box
   1) box被炸坏 ，用 1个爆竹炸另1个box
    结论： 1或2个 爆竹可 炸坏box ,只要使用 3个 爆竹
   2）box没有被炸坏，用3个，4个再实验，共需 2+3+4=9个 爆竹
    结论：取两种结果中较大的那个max(3,9)=9,即共需9个
2. 用3个爆竹炸 一个box
   1) box被炸坏 ，用 1个，2个爆竹炸另1个box
    结论： 1，2，3个 爆竹可 炸坏box ,只要使用 6个 爆竹
   2）box没有被炸坏，用4个再实验，共需 3+4=7个 爆竹
    结论：max(6,7)=7;
answer=min(6,7)=7
由2 ，k=2,m=4, answer=7   记为c[2][1][4]=7
a[k][n][m]的含义： 给你 k 个box,每次实验最多使用m个爆竹，最少使用
n个爆竹(取的爆竹数从n到m)，最多使用a[k][n][m]个爆竹 进行实验，可知多少个爆竹可 炸坏box
#include<stdio.h>
int a[12][105][105]; 
int max(int x,int y)
{ 
 if(x>y)
   return x;
 else
      return y; 
}
int main()
{
 int i,j,k,s,t,n,m;
 for(i=1;i<=100;i++)
   for(j=i;j<=100;j++)
    a[1][i][j]=(i+j)*(j-i+1)/2;
 for (k=2; k<=10; k++) //箱子个数
 {
        for (m=0; m<=100; m++) //在当前基础上(爆竹最少的情况下)增加的爆竹的数目
   {
    for (n=1; n<=100-m; n++)//至少爆竹的数目
    { 
     if (m==0)//当不增加时，即至少使用n个，且至多只能使用n
     {
      a[k][n][n] = n;
      continue;
     }
     a[k][n][m+n]=1000000000;
     for (s=n; s<=m+n; s++)//当前实验所使用的爆竹数 为s 
     {     
                    //分两种情况，箱子被炸坏。剩下k-1个箱子，then从n到s-1开始摔 
                    //箱子没被炸坏 //还有k个箱子，then从s+1到m+n开始摔 
                    //在两种情况中选更大的那个值 
                    //然后在所有的情况中选最小的那个值即为结果 
      if (a[k][n][m+n]>max(s+a[k-1][n][s-1],s+a[k][s+1][m+n]))
      a[k][n][m+n]=max(s+a[k-1][n][s-1],s+a[k][s+1][m+n]);
     }
    }
   }
 } 
 //printf("%d\n",a[2][1][4]);
 scanf("%d",&t);
 while(t--)
 {
   scanf("%d%d",&k,&m);
   if(k==1){printf("%d\n",m*(m+1)/2);}
   printf("%d\n",a[k][1][m]);
 }
 return 0;
}
