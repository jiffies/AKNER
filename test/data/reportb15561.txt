poj1141 - zhang20072844的专栏 - 博客频道 - CSDN.NET

这道题目是黑书上的原题，设dp[i,j]为从位置i到位置j需要加入字符的最小次数，有dp[i,j]=min(dp[i,k]+dp[k+1,j])，其中i<=k<j。特别的当s[i]='[' s[j]=']'或者s[i]='(' s[j]=')'时，dp[i,j]=dp[i+1,j-1]。初始条件为dp[i,i]=1，其中0<=i<len。
//本题是自底向上的dp，还可以用记忆化搜索的方法
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int V=110;
char str[V];
int dp[V][V],path[V][V];
void oprint(int i,int j)
{
 if(i>j)return;//返回
 if(i==j)
 {
  if(str[i]=='['||str[i]==']')
   printf("[]");
  else
   printf("()");
 }
 else if(path[i][j]==-1)//如果是-1表示i，j匹配递归输出
 {
  printf("%c",str[i]);
  oprint(i+1,j-1);
  printf("%c",str[j]);
 }
 else//否则i到k，k+1到j，而k=path【i】【j】
 {
  oprint(i,path[i][j]);
  oprint(path[i][j]+1,j);
 }
}
int main()
{
 int i,j,k,r,n;
 while(gets(str))
 {
  n=strlen(str);
  if(n==0)//注意有空行，WA了很多遍啊。
  {
   printf("/n");
   continue;
  }
  memset(dp,0,sizeof(dp));
  for(i=0;i<n;i++)
   dp[i][i]=1;
  for(r=1;r<n;r++)//相当于从小的区间去递推大的区间知道整个字符串，自底向上的方法r表示区间的长度，从1到n-1
  {
   for(i=0;i<n-r;i++)
   {
    j=i+r;
    dp[i][j]=99999999;
    if((str[i]=='('&&str[j]==')')||(str[i]=='['&&str[j]==']'))
     if(dp[i][j]>dp[i+1][j-1])
     {
      dp[i][j]=dp[i+1][j-1];
      path[i][j]=-1;//path=-1表示i，j匹配了。
     }
    for(k=i;k<j;k++)//dp求最值
     if(dp[i][j]>dp[i][k]+dp[k+1][j])
      dp[i][j]=dp[i][k]+dp[k+1][j],path[i][j]=k;//path表示i，j之间从k分开
   }
  }
  oprint(0,n-1);
  printf("/n");
 }
 return 0;
}
