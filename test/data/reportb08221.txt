poj 2893 M × N Puzzle (由逆序对求解8数码问题的推广)_answerme11的空间_百度空间

    这是一道8数码问题推广的题目，可通过逆序对个数判定问题是否可解。
    解决这个问题，我们可以首先把初始矩阵按从上到下，从左到右顺序排列成一个一维数组的数列，然后将问题化成求解逆序对的问题。若初始矩阵的逆序对数与目标矩阵的逆序对数奇偶性一致，则问题可解。（其中两个矩阵都要扣除数字0对逆序对数的影响）。
    至于为什么这样求解，我也无法完全解释，但是可以提供一些参考知识：
     假设这个矩阵有3列，且逆序对总数设为N
    （1）首先，对于可左右移动的数字，它左右移动是不会对逆序对总数产生影响；
    （2）若数字a0上下移动的话会移到它之前或之后的两个数字的位置，假设是向上移动，且这两个数字为a1，a2：(3个数字肯定是不同数字)
         若a0 < a1 < a2，则新的逆序对总数为N-2，
         若a1 < a0 < a2, 则新的逆序对总数为N - 1 + 1 = N，
         若a1 < a2 < a0, 则新的逆序对总数为N+2，
       由此可见，数字的移动是不影响矩阵逆序对总数的奇偶性的，推广到列数为奇数的情况也是一样。那么若判定初始矩阵与目标矩阵的逆序对总数是否相同，即可判定问题是否可解，若同则可解，否则不可解。
      若列数为偶数的话，数字左右移动同理不影响，但是上下移动一次会改变一次逆序对总数的奇偶性，所以对于这种情况，我们可以计算初始矩阵0的位置到目标矩阵0的位置的差值 S ，这样可以判定奇偶性被如何改变了。由于0最终是要到目标位置的，所以无论0在工程中如何移动，逆序对的奇偶性只和S有关。那有些人可能会想，我们怎么只考虑0的上下移动，不考虑其他数字的上下移动，我们可以这样想，无论那个数字要移动都是要和0交换位置，也就是说无论那个数字的移动都是0的移动，所以在这里我们就只分析0的上下移动即可。
       以下是本题的代码，求解逆序对数用的是归并法的模板，其实用树状数组也可以求解逆序对数。但自己写嫌麻烦，就用了USO同学的归并法的模板了。
#include<iostream>
using namespace std;
#define MAXN 1000005
int cnt;
int a[MAXN],c[MAXN];
//a[0...n-1] 初始化cnt=0; call:MergeSort(0,n);
void MergeSort(int l,int r)//归并求逆序对数
{
    int mid,i,j,tmp;
    if(r>l+1)
    {
        mid=(l+r)/2;
        MergeSort(l,mid);
        MergeSort(mid,r);
        tmp=l;
        for(i=l,j=mid;i<mid&&j<r;)
        {
            if(a[i]>a[j])
            {
                c[tmp++]=a[j++];
                cnt+=mid-i;
            }
            else c[tmp++]=a[i++];
        }
        while(j<r)   c[tmp++]=a[j++];
        while(i<mid) c[tmp++]=a[i++];
        for(i=l;i<r;++i)   a[i]=c[i];
    }
}
int main()
{
    int n,m,pl;
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        if(n == 0 || m == 0)break;
        cnt = 0;
        pl = 0;
        int x,loc0;
        for(int i = 0; i < n*m; i++)
        {
            scanf("%d",&a[pl]);
            if(a[pl] == 0)
            {
                x = pl/m;
                loc0 = pl;
            }
            pl++;
        }
        MergeSort(0,pl);
        cnt -= loc0; //扣除0的逆序数
        int step = 0;
        if(m%2 == 1)//若列数为奇数，则数字的上下左右移动都不影响最终逆序对的总数
            step = 0;
        else
            step = n - 1 - x;//若列数为偶数，左右移动不影响，但上下移动一次，会改变一次逆序对总数的奇偶性
        if(step%2 == cnt % 2)//初始，结束状态的逆序对总数奇偶性一致，则问题可解
            printf("YES\n");
        else
            printf("NO\n");
    }
    return 0;
}
