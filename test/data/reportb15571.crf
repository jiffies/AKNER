PKU	eng	B-OJ
_	x	I-OJ
1141	m	I-OJ
_	x	O
唐武	nr	O
的	uj	O
空间	n	O
_	x	O
百度	n	O
空间	n	O

	x	O

	x	O
/	x	O
/	x	O
多多指教	nz	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
iostream	eng	O
>	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
string	eng	O
>	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
cmath	eng	O
>	x	O

	x	O
using	eng	O
 	x	O
namespace	eng	O
 	x	O
std	eng	O
;	x	O

	x	O
const	eng	O
 	x	O
int	eng	O
 	x	O
NUM	eng	O
 	x	O
=	x	O
 	x	O
101	m	O
;	x	O

	x	O
int	eng	O
 	x	O
Min	eng	O
[	x	O
NUM	eng	O
]	x	O
[	x	O
NUM	eng	O
]	x	O
;	x	O
 	x	O
/	x	O
/	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
表示	v	O
第	m	O
i	eng	O
个字符	n	O
到	v	O
第	m	O
j	eng	O
个字符	n	O
规则化	n	O
需要	v	O
的	uj	O
最少	d	O
字符	n	O
数	n	O
,	x	O
这个	r	O
似乎	d	O
不用	v	O
计算	v	O
！	x	O

	x	O
string	eng	O
 	x	O
Ans	eng	O
[	x	O
NUM	eng	O
]	x	O
[	x	O
NUM	eng	O
]	x	O
;	x	O
 	x	O
/	x	O
/	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
表示	v	O
第	m	O
i	eng	O
个字符	n	O
到	v	O
第	m	O
j	eng	O
个字符	n	O
组成	v	O
的	uj	O
串	n	O
经过	p	O
最优化	v	O
后	f	O
的	uj	O
字符串	n	O

	x	O
bool	eng	O
 	x	O
cal	eng	O
[	x	O
NUM	eng	O
]	x	O
[	x	O
NUM	eng	O
]	x	O
;	x	O
 	x	O
/	x	O
/	x	O
Cal	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
为	p	O
真	d	O
表示	v	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
和	c	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
已经	d	O
算	v	O
出	v	O

	x	O
string	eng	O
 	x	O
s	x	O
;	x	O
 	x	O
/	x	O
/	x	O
s	eng	O
为	p	O
输入	v	O
的	uj	O
字符串	n	O

	x	O
int	eng	O
 	x	O
n	x	O
;	x	O
 	x	O
/	x	O
/	x	O
n	eng	O
为	p	O
字符	n	O
的	uj	O
个数	n	O

	x	O
void	eng	O
 	x	O
Init	eng	O
(	x	O
)	x	O
;	x	O

	x	O
/	x	O
/	x	O
inline	eng	O
 	x	O
string	eng	O
 	x	O
min	eng	O
(	x	O
string	eng	O
 	x	O
s1	eng	O
,	x	O
 	x	O
string	eng	O
 	x	O
s2	eng	O
)	x	O
;	x	O
 	x	O
/	x	O
/	x	O
返回	v	O
长度	ns	O
最短	z	O
的	uj	O
字符串	n	O

	x	O
int	eng	O
 	x	O
main	eng	O
(	x	O
)	x	O

	x	O
{	x	O

	x	O
cin	eng	O
 	x	O
>	x	O
>	x	O
s	x	O
;	x	O

	x	O
n	x	O
 	x	O
=	x	O
 	x	O
s	eng	O
.	m	O
length	eng	O
(	x	O
)	x	O
;	x	O

	x	O
s	eng	O
.	m	O
insert	eng	O
(	x	O
s	eng	O
.	m	O
begin	eng	O
(	x	O
)	x	O
,	x	O
 	x	O
'	x	O
O	x	O
'	x	O
)	x	O
;	x	O

	x	O
Init	eng	O
(	x	O
)	x	O
;	x	O

	x	O
int	eng	O
 	x	O
i	x	O
,	x	O
 	x	O
j	x	O
,	x	O
 	x	O
p	x	O
,	x	O
 	x	O
k	x	O
;	x	O

	x	O
/	x	O
/	x	O
这里	r	O
的	uj	O
循环	vn	O
控制	v	O
应该	v	O
使得	v	O
计算	v	O
由	c	O
i	eng	O
和	c	O
j	eng	O
的	uj	O
差值	n	O
由小到大	l	O

	x	O
for	eng	O
(	x	O
p	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O
 	x	O
p	x	O
 	x	O
<	x	O
 	x	O
n	x	O
;	x	O
 	x	O
p	eng	O
++	x	O
)	x	O
 	x	O
/	x	O
/	x	O
p	x	O
表示	v	O
j	eng	O
和	c	O
i	eng	O
的	uj	O
差值	n	O

	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
i	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O
 	x	O
i	x	O
 	x	O
<	x	O
=	x	O
 	x	O
n	x	O
 	x	O
-	x	O
 	x	O
p	x	O
;	x	O
 	x	O
i	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
j	x	O
 	x	O
=	x	O
 	x	O
i	x	O
 	x	O
+	x	O
 	x	O
p	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
INT	eng	O
_	x	O
MAX	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
(	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
 	x	O
&&	x	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
)	x	O
'	x	O
)	x	O
 	x	O
|	x	O
|	x	O
 	x	O
(	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
[	x	O
'	x	O
 	x	O
&&	x	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
]	x	O
'	x	O
)	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
 	x	O
+	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
+	x	O
 	x	O
'	x	O
)	x	O
'	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
[	x	O
'	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
'	x	O
[	x	O
'	x	O
 	x	O
+	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
+	x	O
 	x	O
'	x	O
]	x	O
'	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
[	x	O
'	x	O
)	x	O
 	x	O
/	x	O
/	x	O
需要	v	O
替换	v	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
>	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
 	x	O
&&	x	O
 	x	O
cal	eng	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
 	x	O
/	x	O
/	x	O
Min	eng	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
必须	d	O
已经	d	O
计算	v	O
过	ug	O
了	ul	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
 	x	O
+	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
+	x	O
 	x	O
'	x	O
)	x	O
'	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
'	x	O
[	x	O
'	x	O
 	x	O
+	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
+	x	O
 	x	O
'	x	O
]	x	O
'	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
s	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
]	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
)	x	O
'	x	O
)	x	O
 	x	O
/	x	O
/	x	O
需要	v	O
替换	v	O
,	x	O
当	t	O
s	eng	O
[	x	O
j	x	O
]	x	O
为	p	O
'	x	O
(	x	O
'	x	O
或者	c	O
'	x	O
[	x	O
'	x	O
时	ng	O
就	d	O
不会	v	O
有	v	O
这种	r	O
情况	n	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
>	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
 	x	O
&&	x	O
 	x	O
cal	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
s	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
)	x	O
'	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
 	x	O
+	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
+	x	O
 	x	O
'	x	O
)	x	O
'	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
'	x	O
[	x	O
'	x	O
 	x	O
+	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
+	x	O
 	x	O
'	x	O
]	x	O
'	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
k	x	O
 	x	O
=	x	O
 	x	O
i	x	O
;	x	O
 	x	O
k	x	O
 	x	O
<	x	O
 	x	O
j	x	O
;	x	O
 	x	O
k	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
(	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
>	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
k	x	O
]	x	O
 	x	O
+	x	O
 	x	O
Min	eng	O
[	x	O
k	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
 	x	O
&&	x	O
 	x	O
cal	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
k	x	O
]	x	O
 	x	O
&&	x	O
 	x	O
cal	eng	O
[	x	O
k	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
 	x	O
/	x	O
/	x	O
需要	v	O
替换	v	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
k	x	O
]	x	O
 	x	O
+	x	O
 	x	O
Min	eng	O
[	x	O
k	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
k	x	O
]	x	O
 	x	O
+	x	O
 	x	O
Ans	eng	O
[	x	O
k	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
cal	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
true	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
cout	eng	O
 	x	O
<	x	O
<	x	O
i	x	O
<	x	O
<	x	O
"	x	O
 	x	O
"	x	O
<	x	O
<	x	O
j	x	O
<	x	O
<	x	O
endl	eng	O
<	x	O
<	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
<	x	O
<	x	O
endl	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
/	x	O
/	x	O
cout	eng	O
 	x	O
<	x	O
<	x	O
i	x	O
<	x	O
<	x	O
"	x	O
 	x	O
"	x	O
<	x	O
<	x	O
j	x	O
<	x	O
<	x	O
endl	eng	O
<	x	O
<	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
<	x	O
<	x	O
endl	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
/	x	O
*	x	O
for	eng	O
(	x	O
i	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O
 	x	O
i	x	O
 	x	O
<	x	O
=	x	O
 	x	O
n	x	O
;	x	O
 	x	O
i	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
j	x	O
 	x	O
=	x	O
 	x	O
i	x	O
;	x	O
 	x	O
j	x	O
 	x	O
<	x	O
=	x	O
 	x	O
n	x	O
;	x	O
 	x	O
j	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
cout	eng	O
 	x	O
<	x	O
<	x	O
i	x	O
<	x	O
<	x	O
"	x	O
 	x	O
"	x	O
<	x	O
<	x	O
j	x	O
<	x	O
<	x	O
endl	eng	O
<	x	O
<	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
<	x	O
<	x	O
endl	eng	O
;	x	O
*	x	O
/	x	O
 	x	O

	x	O
cout	eng	O
 	x	O
<	x	O
<	x	O
Ans	eng	O
[	x	O
1	x	O
]	x	O
[	x	O
n	x	O
]	x	O
<	x	O
<	x	O
endl	eng	O
;	x	O

	x	O
return	eng	O
 	x	O
0	x	O
;	x	O

	x	O
}	x	O

	x	O
/	x	O
/	x	O
测试	vn	O
[	x	O
(	x	O
[	x	O
)	x	O
[	x	O
[	x	O
(	x	O
[	x	O
)	x	O
]	x	O

	x	O
void	eng	O
 	x	O
Init	eng	O
(	x	O
)	x	O

	x	O
{	x	O

	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O
 	x	O
i	x	O
 	x	O
<	x	O
=	x	O
 	x	O
n	x	O
;	x	O
 	x	O
i	eng	O
++	x	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
j	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O
 	x	O
j	x	O
 	x	O
<	x	O
=	x	O
 	x	O
n	x	O
;	x	O
 	x	O
j	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
cal	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
false	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
 	x	O
cal	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
 	x	O
cal	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
Min	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
=	x	O
 	x	O
0	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
)	x	O
'	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
 	x	O
"	x	O
(	x	O
)	x	O
"	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
else	eng	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
 	x	O
"	x	O
[	x	O
]	x	O
"	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
Ans	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
=	x	O
 	x	O
"	x	O
"	x	O
;	x	O

	x	O
}	x	O

	x	O
}	x	O

	x	O