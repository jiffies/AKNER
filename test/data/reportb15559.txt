POJ 1141_乐吾天_百度空间

PKU 1141
#include<iostream>
#include<string>
using namespace std;
int L = 0;
char Buff[105];
int F[105][105];
string Str,Map[105][105];
int main()
{
       gets(Buff);
       while(Buff[L] != '\0') {
             L++;
       }
       memset(F,127,sizeof(F));
       for(int i = 0 ; i < L ; i++) {
             F[i][i] = 2;
             if (Buff[i] == '(' || Buff[i] == ')') Map[i][i] = "()";
             if (Buff[i] == '[' || Buff[i] == ']') Map[i][i] = "[]";
       }
       for(int i = 1 ; i < L ; i++) {
             F[i][i - 1] = 0;
             Map[i][i - 1].clear();
       }
       for(int k = 1 ; k < L ; k++) { 
             for(int i = 0 ; i + k < L ; i++) {
                   int Temp = 0;
                   if (Buff[i] == '(' && Buff[i + k] == ')') {
                         Temp = F[i + 1][i + k - 1] + 2;
                         if (Temp < F[i][i + k]) {
                               F[i][i + k] = Temp;
                               Map[i][i + k] = '(' + Map[i + 1][i + k - 1] + ')';
                         }
                   }
                   if (Buff[i] == '[' && Buff[i + k] == ']') {
                         Temp = F[i + 1][i + k - 1] + 2;
                         if (Temp < F[i][i + k]) {
                               F[i][i + k] = Temp;
                               Map[i][i + k] = '[' + Map[i + 1][i + k - 1] + ']';
                         }
                   }
                   for(int j = i ; j < i + k ; j++) {
                         Temp = F[i][j] + F[j + 1][i + k];
                         if (Temp < F[i][i + k]) {
                               F[i][i + k] = F[i][j] + F[j + 1][i + k];
                               Map[i][i + k] = Map[i][j] + Map[j + 1][i + k];
                         }
                   }
             }
       }
       if (L == 0) {
             cout << endl;
       }
       else {
             cout << Map[0][L - 1] << endl;
       }
       return 0;
}
HINTS:这个题目又有许多人写记忆化搜索,我今天认真考虑了一下记忆化搜索和递推式的动态规划,认为,在"序"和"规则"十分明确的情况下,使用递推式的效率更高,方便检查,不存在直观"序"的可以使用DAG之类的构造一下，如果用循环十分难以表明"序"的情况下，再考虑记忆化搜索,虽然搜索写的比较快,但是由于递归带了一系列的问题十分麻烦,如果存在明确的递推"序"，还是直接写递推式比较好.
推荐文章:

1. 
【POJ 2481.Cows】【树状数组4】

2. 
POJ 3020

3. 
poj 1038 Bugs Integrated, Inc.状态压缩dp

4. 
POJ 2229

5. 
POJ 2361 Tic Tac Toe ( bfs or 模拟）

6. 
2009.10.21 POJ P1009 Edge Detection

7. 
poj 3636

8. 
poj 3164

9. 
poj 1227 RoboContest ( BFS )

10. 
poj 1006 求助！错在哪里？

