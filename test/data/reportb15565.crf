PKU	eng	B-OJ
 	x	I-OJ
1141	m	I-OJ
 	x	O
Brackets	eng	O
 	x	O
Sequence	eng	O
 	x	O
-	x	O
 	x	O
Leyni	eng	O
的	uj	O
日志	ns	O
 	x	O
-	x	O
 	x	O
网易	n	O
博客	nr	O

	x	O

	x	O
类型	n	O
：	x	O
动态	n	B-KNOWLEDGE
规划	n	I-KNOWLEDGE

	x	O

	x	O
问题	n	O
：	x	O
括号	n	O
匹配	v	O
问题	n	O
。	x	O

给出	v	O
一个	m	O
由	p	O
括号	n	O
组成	v	O
字符串	n	O
，	x	O
加	v	O
最少	d	O
的	uj	O
括号	n	O
使	v	O
之	u	O
匹配	v	O
。	x	O

	x	O

	x	O
思路	n	O
：	x	O

	x	O

	x	O
设	n	O
f	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
为从	p	O
i	eng	O
到	v	O
j	eng	O
这段	r	O
字串	n	O
达到	v	O
匹配	v	O
所	c	O
需	v	O
最少	d	O
括号	n	O
数	n	O
。	x	O

	x	O

	x	O
初始状态	l	O
：	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O

	x	O

	x	O
状态	n	O
转移	v	O
：	x	O

	x	O

	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
min	eng	O
{	x	O
f	x	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
 	x	O
|	x	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
与	p	O
s	eng	O
[	x	O
j	x	O
]	x	O
匹配	v	O
]	x	O
，	x	O
f	x	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
|	x	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
为	p	O
左	m	O
括号	n	O
，	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
|	x	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
为	p	O
右	f	O
括号	n	O
，	x	O
min	eng	O
{	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
k	x	O
]	x	O
+	x	O
f	eng	O
[	x	O
k	x	O
]	x	O
[	x	O
j	x	O
]	x	O
}	x	O
}	x	O

	x	O

	x	O
代码	n	O
（	x	O
16	m	O
MS	eng	O
 	x	O
 	x	O
280	m	O
K	eng	O
 	x	O
 	x	O
C++	nz	O
）	x	O
：	x	O

	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
iostream	eng	O
>	x	O

	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
stdlib	eng	O
.	m	O
h	eng	O
>	x	O

	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
string	eng	O
.	m	O
h	eng	O
>	x	O

	x	O

	x	O
using	eng	O
 	x	O
namespace	eng	O
 	x	O
std	eng	O
;	x	O

	x	O

	x	O
const	eng	O
 	x	O
int	eng	O
 	x	O
MAX	eng	O
 	x	O
=	x	O
 	x	O
102	m	O
;	x	O

	x	O

	x	O
char	eng	O
 	x	O
s	x	O
[	x	O
MAX	eng	O
]	x	O
;	x	O

	x	O

	x	O
int	eng	O
 	x	O
f	x	O
[	x	O
MAX	eng	O
]	x	O
[	x	O
MAX	eng	O
]	x	O
,	x	O
 	x	O
path	eng	O
[	x	O
MAX	eng	O
]	x	O
[	x	O
MAX	eng	O
]	x	O
,	x	O
 	x	O
n	x	O
;	x	O

	x	O

	x	O
void	eng	O
 	x	O
print	eng	O
(	x	O
int	eng	O
 	x	O
l	x	O
,	x	O
 	x	O
int	eng	O
 	x	O
r	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
l	x	O
 	x	O
>	x	O
 	x	O
r	x	O
)	x	O
 	x	O
return	eng	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
l	x	O
 	x	O
=	x	O
=	x	O
 	x	O
r	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
s	x	O
[	x	O
l	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
s	x	O
[	x	O
l	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
)	x	O
'	x	O
)	x	O
 	x	O
cout	eng	O
<	x	O
<	x	O
"	x	O
(	x	O
)	x	O
"	x	O
;	x	O
 	x	O
else	eng	O
 	x	O
cout	eng	O
<	x	O
<	x	O
"	x	O
[	x	O
]	x	O
"	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
else	eng	O
 	x	O
if	eng	O
 	x	O
(	x	O
path	eng	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
-	x	O
1	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
cout	eng	O
<	x	O
<	x	O
s	x	O
[	x	O
l	x	O
]	x	O
;	x	O
 	x	O
print	eng	O
(	x	O
l	x	O
 	x	O
+	x	O
 	x	O
1	x	O
,	x	O
 	x	O
r	x	O
 	x	O
-	x	O
 	x	O
1	x	O
)	x	O
;	x	O
 	x	O
cout	eng	O
<	x	O
<	x	O
s	x	O
[	x	O
r	x	O
]	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
else	eng	O
 	x	O
if	eng	O
 	x	O
(	x	O
path	eng	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
-	x	O
2	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
cout	eng	O
<	x	O
<	x	O
s	x	O
[	x	O
l	x	O
]	x	O
;	x	O
 	x	O
print	eng	O
(	x	O
l	x	O
 	x	O
+	x	O
 	x	O
1	x	O
,	x	O
 	x	O
r	x	O
)	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
s	x	O
[	x	O
l	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
)	x	O
 	x	O
cout	eng	O
<	x	O
<	x	O
"	x	O
)	x	O
"	x	O
;	x	O
 	x	O
else	eng	O
 	x	O
cout	eng	O
<	x	O
<	x	O
"	x	O
]	x	O
"	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
else	eng	O
 	x	O
if	eng	O
 	x	O
(	x	O
path	eng	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
-	x	O
3	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
s	x	O
[	x	O
r	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
)	x	O
'	x	O
)	x	O
 	x	O
cout	eng	O
<	x	O
<	x	O
"	x	O
(	x	O
"	x	O
;	x	O
 	x	O
else	eng	O
 	x	O
cout	eng	O
<	x	O
<	x	O
"	x	O
[	x	O
"	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
print	eng	O
(	x	O
l	x	O
,	x	O
 	x	O
r	x	O
 	x	O
-	x	O
 	x	O
1	x	O
)	x	O
;	x	O
 	x	O
cout	eng	O
<	x	O
<	x	O
s	x	O
[	x	O
r	x	O
]	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
else	eng	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
print	eng	O
(	x	O
l	x	O
,	x	O
path	eng	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
)	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
print	eng	O
(	x	O
path	eng	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
,	x	O
 	x	O
r	x	O
)	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O

	x	O
}	x	O

	x	O

	x	O
int	eng	O
 	x	O
main	eng	O
(	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
while	eng	O
(	x	O
gets	eng	O
(	x	O
s	x	O
)	x	O
 	x	O
!	x	O
=	x	O
 	x	O
NULL	eng	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
n	x	O
 	x	O
=	x	O
 	x	O
strlen	eng	O
(	x	O
s	x	O
)	x	O
;	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
memset	eng	O
(	x	O
f	x	O
,	x	O
 	x	O
0	x	O
,	x	O
 	x	O
sizeof	eng	O
(	x	O
f	x	O
)	x	O
)	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
 	x	O
(	x	O
int	eng	O
 	x	O
i	x	O
 	x	O
=	x	O
 	x	O
0	x	O
;	x	O
 	x	O
i	x	O
 	x	O
<	x	O
=	x	O
 	x	O
n	x	O
;	x	O
 	x	O
i	eng	O
++	x	O
)	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
 	x	O
(	x	O
int	eng	O
 	x	O
k	x	O
 	x	O
=	x	O
 	x	O
1	x	O
;	x	O
 	x	O
k	x	O
 	x	O
<	x	O
 	x	O
n	x	O
;	x	O
 	x	O
k	eng	O
++	x	O
)	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
 	x	O
(	x	O
int	eng	O
 	x	O
i	x	O
 	x	O
=	x	O
 	x	O
0	x	O
;	x	O
 	x	O
i	x	O
 	x	O
<	x	O
 	x	O
n	x	O
 	x	O
-	x	O
 	x	O
k	x	O
;	x	O
 	x	O
i	eng	O
++	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
int	eng	O
 	x	O
j	x	O
 	x	O
=	x	O
 	x	O
i	x	O
 	x	O
+	x	O
 	x	O
k	x	O
;	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
INT	eng	O
_	x	O
MAX	eng	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
 	x	O
&&	x	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
)	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
[	x	O
'	x	O
 	x	O
&&	x	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
]	x	O
'	x	O
)	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
f	x	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
<	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
f	x	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
path	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
-	x	O
1	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
(	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
s	x	O
[	x	O
i	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
[	x	O
'	x	O
)	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
f	x	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
 	x	O
<	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
f	x	O
[	x	O
i	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
path	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
-	x	O
2	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
s	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
)	x	O
'	x	O
 	x	O
|	x	O
|	x	O
 	x	O
s	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
=	x	O
 	x	O
'	x	O
]	x	O
'	x	O
)	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
 	x	O
<	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
 	x	O
-	x	O
 	x	O
1	x	O
]	x	O
 	x	O
+	x	O
 	x	O
1	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
path	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
-	x	O
3	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
 	x	O
(	x	O
int	eng	O
 	x	O
l	x	O
 	x	O
=	x	O
 	x	O
i	x	O
;	x	O
 	x	O
l	x	O
 	x	O
<	x	O
 	x	O
j	x	O
;	x	O
 	x	O
l	eng	O
++	x	O
)	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
l	x	O
]	x	O
 	x	O
+	x	O
 	x	O
f	x	O
[	x	O
l	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
<	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
)	x	O
{	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
f	x	O
[	x	O
i	x	O
]	x	O
[	x	O
l	x	O
]	x	O
 	x	O
+	x	O
 	x	O
f	x	O
[	x	O
l	x	O
 	x	O
+	x	O
 	x	O
1	x	O
]	x	O
[	x	O
j	x	O
]	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
path	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
l	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
print	eng	O
(	x	O
0	x	O
,	x	O
 	x	O
n	x	O
 	x	O
-	x	O
 	x	O
1	x	O
)	x	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
cout	eng	O
<	x	O
<	x	O
endl	eng	O
;	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
return	eng	O
 	x	O
0	x	O
;	x	O

	x	O

	x	O
}	x	O

	x	O

	x	O