POJ2904	eng	B-OJ
 	x	O
题解	v	O
_	x	O
forsona	eng	O
&	x	O
Sona	eng	O
的	uj	O
POJ	eng	B-OJ
题解	v	O
_	x	O
百度	n	O
空间	n	O

	x	O

	x	O
POJ2904	eng	B-OJ
 	x	O
题解	v	O
 	x	O
—	x	O
—	x	O
人	n	O
定	v	O
顺天	t	O

	x	O
首先	d	O
 	x	O
我	r	O
觉得	v	O
这	r	O
道	q	O
题目	n	O
的	uj	O
意思	n	O
不是	c	O
那么	r	O
容易	a	O
理解	v	O
，	x	O
至少	d	O
相当	d	O
容易	a	O
产生	n	O
歧义	n	O
。	x	O

	x	O
大意	d	O
是	v	O
给定	v	O
一个	m	O
盒子	n	O
和	c	O
它	r	O
可以	c	O
容纳	nr	O
爆竹	n	O
数量	n	O
最大值	l	O
的	uj	O
上限	v	O
m	x	O
（	x	O
不是	c	O
最大值	l	O
，	x	O
也	d	O
就是	d	O
这个	r	O
最大	a	O
容纳	nr	O
量	n	O
在	p	O
1..	m	O
m	eng	O
区间	n	O
内	n	O
）	x	O
。	x	O

测试	vn	O
的	uj	O
时候	n	O
提供	v	O
给	p	O
了	ul	O
你	r	O
k	eng	O
个	m	O
盒子	n	O
，	x	O
要求	v	O
利用	n	O
这些	r	O
有限	a	O
的	uj	O
实验	vn	O
盒	q	O
测试	vn	O
出	v	O
这类	r	O
盒子	n	O
容纳	nr	O
爆竹	n	O
数	m	O
的	uj	O
最大值	l	O
…	x	O
…	x	O

	x	O
盒子	n	O
只有	c	O
爆炸	v	O
和	c	O
完好无损	i	O
两种	m	O
状态	n	O
（	x	O
只要	c	O
你	r	O
没	d	O
把	p	O
它	r	O
炸飞	v	O
你	r	O
就	d	O
当	p	O
它	r	O
还是	c	O
新	a	O
的	uj	O
）	x	O

	x	O
挺	d	O
复杂	a	O
吧	y	O
。	x	O

是	v	O
有	v	O
一点	m	O
实际	n	O
问题	n	O
的	uj	O
含义	n	O
在	p	O
里面	f	O
。	x	O

	x	O
简单	a	O
的	uj	O
举	v	O
个	q	O
例子	n	O
 	x	O
如果	c	O
答案	n	O
限定	v	O
在	p	O
l	eng	O
..	m	O
r	eng	O
范围	n	O
内	f	O
而	c	O
k	eng	O
=	x	O
=	x	O
1	x	O
，	x	O
只给	v	O
了	ul	O
你	r	O
一个	m	O
盒子	n	O
，	x	O
你	r	O
需要	v	O
从	p	O
l	eng	O
开始	v	O
一个	m	O
一个	m	O
小心翼翼	i	O
的	uj	O
测试	vn	O
，	x	O
如果	c	O
不幸	a	O
的	uj	O
是	v	O
容量	n	O
上限	v	O
是	v	O
r	eng	O
的话	u	O
，	x	O
你	r	O
一共	j	O
需要	v	O
(	x	O
l	eng	O
+	x	O
r	eng	O
)	x	O
(	x	O
r	x	O
-	x	O
l	eng	O
+	x	O
1	m	O
)	x	O
/	x	O
2	m	O
个	m	O
爆竹	n	O

	x	O
下面	f	O
开始	v	O
DP	eng	O
，	x	O
dp	eng	O
[	x	O
k	x	O
]	x	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
表示	v	O
还	d	O
剩下	v	O
k	eng	O
个	m	O
盒子	n	O
 	x	O
，	x	O
放	v	O
l	eng	O
-	x	O
1	m	O
个	m	O
爆竹	n	O
会	v	O
爆炸	v	O
（	x	O
后面	f	O
转移	v	O
的	uj	O
时候	n	O
你	r	O
会	v	O
看到	v	O
 	x	O
如果	c	O
放	v	O
n	eng	O
个	m	O
盒子	n	O
会	v	O
爆炸	v	O
的话	u	O
，	x	O
那么	r	O
后面	f	O
就	d	O
不	d	O
需要	v	O
再	d	O
考虑	v	O
n	eng	O
的	uj	O
情况	n	O
了	ul	O
 	x	O
这	r	O
是	v	O
显然	ad	O
的	uj	O
 	x	O
我	r	O
一	m	O
开始	v	O
还	d	O
怎么	r	O
都	d	O
理解	v	O
不了	v	O
）	x	O
，	x	O
通俗	n	O
点	m	O
说	v	O
就是	d	O
答案	n	O
范围	n	O
在	p	O
(	x	O
l	x	O
-	x	O
1	x	O
,	x	O
r	x	O
)	x	O
之间	f	O
的	uj	O
情况	n	O
下	f	O
 	x	O
最	d	O
坏	a	O
需要	v	O
的	uj	O
爆竹	n	O
至少	d	O
是	v	O
多少	m	O

	x	O
这个	r	O
地方	n	O
看上去	v	O
像	v	O
一个	m	O
最小	a	O
最大	a	O
 	x	O
事实上	l	O
是	v	O
人	n	O
和	c	O
自然	d	O
的	uj	O
博弈	v	O

	x	O
人	n	O
定	v	O
不胜	v	O
天	q	O
，	x	O
但是	c	O
人	n	O
要	v	O
有	v	O
和	c	O
自然	d	O
博弈	v	O
的	uj	O
勇气	n	O
，	x	O
去	v	O
追求	v	O
了解	v	O
认识	v	O
自然	d	O
，	x	O
在	p	O
顺应	v	O
自然	d	O
的	uj	O
同时	c	O
改变	v	O
自然	d	O
…	x	O
…	x	O

	x	O
老天	t	O
的	uj	O
意思	n	O
不可	v	O
违背	v	O
，	x	O
所以	c	O
我们	r	O
只能	v	O
从	p	O
 	x	O
l	x	O
 	x	O
到	v	O
 	x	O
r	x	O
 	x	O
枚举	nz	O
下	f	O
一次	m	O
测试	vn	O
放入	v	O
的	uj	O
爆竹	n	O
数目	n	O
，	x	O
然后	c	O
分	v	O
炸飞	v	O
了	ul	O
和	c	O
完好无损	i	O
两种	m	O
情况	n	O
讨论	v	O
，	x	O
天意	n	O
不	d	O
可知	v	O
，	x	O
要取	v	O
两种	m	O
情况	n	O
最大值	l	O
保留	v	O

	x	O
人	n	O
有	v	O
顺应	v	O
天时	t	O
的	uj	O
策略	n	O
，	x	O
我们	r	O
可以	c	O
对于	p	O
这	r	O
l	eng	O
到	v	O
r	eng	O
的	uj	O
枚举	nz	O
得到	v	O
的	uj	O
两种	m	O
情况	n	O
最大值	l	O
取	v	O
最小值	l	O
 	x	O
也	d	O
就是	d	O
得到	v	O
一个	m	O
最	d	O
坏	a	O
情况	n	O
下	f	O
的	uj	O
最优	d	O
策略	n	O
。	x	O

人	n	O
定	v	O
顺天	t	O
，	x	O
我们	r	O
可以	c	O
在	p	O
最	a	O
糟糕	a	O
的	uj	O
情况	n	O
下	f	O
获得	v	O
最好	a	O
的	uj	O
结果	n	O

	x	O
转化成	l	O
一个	m	O
不算	v	O
很	zg	O
典型	n	O
的	uj	O
最小	a	O
最大	a	O
问题	n	O
（	x	O
本来	t	O
想想	v	O
不是	c	O
二分	m	O
答案	n	O
，	x	O
后来	t	O
发现	v	O
从头	v	O
到位	v	O
都	d	O
是	v	O
在	p	O
二分	m	O
答案	n	O
甚至	d	O
题目	n	O
给	p	O
的	uj	O
就是	d	O
范围	n	O
，	x	O
只不过	c	O
这个	r	O
二分	m	O
没有	v	O
那么	r	O
暴力	n	O
）	x	O

	x	O
状态	n	O
转移	v	O
方程	n	O
其实	d	O
并	c	O
不难	d	O

	x	O
Dp	eng	O
(	x	O
k	x	O
,	x	O
l	x	O
,	x	O
r	x	O
)	x	O
=	x	O
min	eng	O
 	x	O
(	x	O
 	x	O
n	eng	O
+	x	O
 	x	O
max	eng	O
 	x	O
(	x	O
 	x	O
Dp	eng	O
(	x	O
k	x	O
,	x	O
n	eng	O
+	x	O
1	m	O
,	x	O
r	x	O
)	x	O
 	x	O
,	x	O
 	x	O
Dp	eng	O
(	x	O
k	x	O
-	x	O
1	x	O
,	x	O
l	x	O
,	x	O
n	x	O
-	x	O
1	x	O
)	x	O
 	x	O
)	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
l	x	O
<	x	O
=	x	O
n	x	O
<	x	O
=	x	O
r	x	O

	x	O
下面	f	O
是	v	O
我	r	O
的	uj	O
代码	n	O

	x	O
Source	eng	O
 	x	O
Code	eng	O

	x	O
 	x	O
Problem	eng	O
:	x	O
 	x	O
2904	m	O
 	x	O
User	eng	O
:	x	O
 	x	O
Sona	eng	O
 	x	O
Memory	eng	O
:	x	O
 	x	O
1220	m	O
K	eng	O
 	x	O
Time	eng	O
:	x	O
 	x	O
94	m	O
MS	eng	O
 	x	O
Language	eng	O
:	x	O
 	x	O
G	eng	O
++	x	O
 	x	O
Result	eng	O
:	x	O
 	x	O
Accepted	eng	O
 	x	O

	x	O

	x	O
 	x	O

	x	O
 	x	O
Source	eng	O
 	x	O
Code	eng	O
 	x	O
#	x	O
include	eng	O
"	x	O
iostream	eng	O
"	x	O
#	x	O
include	eng	O
"	x	O
cstdio	eng	O
"	x	O
#	x	O
include	eng	O
"	x	O
algorithm	eng	O
"	x	O
#	x	O
include	eng	O
"	x	O
cstring	eng	O
"	x	O
 	x	O
using	eng	O
 	x	O
namespace	eng	O
 	x	O
std	eng	O
;	x	O
int	eng	O
 	x	O
mint	eng	O
[	x	O
11	m	O
]	x	O
[	x	O
111	m	O
]	x	O
[	x	O
111	m	O
]	x	O
;	x	O
int	eng	O
 	x	O
dp	eng	O
(	x	O
int	eng	O
 	x	O
k	x	O
,	x	O
int	eng	O
 	x	O
l	x	O
,	x	O
int	eng	O
 	x	O
r	x	O
)	x	O
{	x	O
 	x	O
int	eng	O
 	x	O
n	x	O
,	x	O
i	x	O
;	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
mint	eng	O
[	x	O
k	x	O
]	x	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
>	x	O
=	x	O
0	x	O
)	x	O
 	x	O
return	eng	O
 	x	O
mint	eng	O
[	x	O
k	x	O
]	x	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
;	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
k	x	O
=	x	O
=	x	O
1	x	O
)	x	O
 	x	O
return	eng	O
 	x	O
mint	eng	O
[	x	O
1	x	O
]	x	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
=	x	O
(	x	O
r	x	O
-	x	O
l	eng	O
+	x	O
1	m	O
)	x	O
*	x	O
(	x	O
r	eng	O
+	x	O
l	eng	O
)	x	O
/	x	O
2	x	O
;	x	O
 	x	O
if	eng	O
 	x	O
(	x	O
l	x	O
>	x	O
r	x	O
)	x	O
 	x	O
return	eng	O
 	x	O
mint	eng	O
[	x	O
k	x	O
]	x	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
=	x	O
0	x	O
;	x	O
 	x	O
mint	eng	O
[	x	O
k	x	O
]	x	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
=	x	O
99999999	m	O
;	x	O
/	x	O
/	x	O
l	eng	O
+	x	O
dp	eng	O
(	x	O
k	x	O
,	x	O
l	eng	O
+	x	O
1	m	O
,	x	O
r	x	O
)	x	O
;	x	O
 	x	O
for	eng	O
(	x	O
n	x	O
=	x	O
l	x	O
;	x	O
n	x	O
<	x	O
=	x	O
r	x	O
;	x	O
n	eng	O
++	x	O
)	x	O
 	x	O
mint	eng	O
[	x	O
k	x	O
]	x	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
=	x	O
min	eng	O
(	x	O
n	eng	O
+	x	O
max	eng	O
(	x	O
dp	eng	O
(	x	O
k	x	O
,	x	O
n	eng	O
+	x	O
1	m	O
,	x	O
r	x	O
)	x	O
,	x	O
dp	eng	O
(	x	O
k	x	O
-	x	O
1	x	O
,	x	O
l	x	O
,	x	O
n	x	O
-	x	O
1	x	O
)	x	O
)	x	O
,	x	O
mint	eng	O
[	x	O
k	x	O
]	x	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
)	x	O
;	x	O
 	x	O
return	eng	O
 	x	O
mint	eng	O
[	x	O
k	x	O
]	x	O
[	x	O
l	x	O
]	x	O
[	x	O
r	x	O
]	x	O
;	x	O
 	x	O
}	x	O
int	eng	O
 	x	O
main	eng	O
(	x	O
)	x	O
{	x	O
 	x	O
int	eng	O
 	x	O
t	x	O
,	x	O
k	x	O
,	x	O
n	x	O
;	x	O
 	x	O
scanf	eng	O
(	x	O
"	x	O
%	x	O
d	x	O
"	x	O
,	x	O
&	x	O
t	eng	O
)	x	O
;	x	O
 	x	O
while	eng	O
(	x	O
t	x	O
-	x	O
-	x	O
)	x	O
 	x	O
{	x	O
 	x	O
scanf	eng	O
(	x	O
"	x	O
%	x	O
d	x	O
%	x	O
d	x	O
"	x	O
,	x	O
&	x	O
k	eng	O
,	x	O
&	x	O
n	eng	O
)	x	O
;	x	O
 	x	O
memset	eng	O
(	x	O
mint	eng	O
,	x	O
-	x	O
1	x	O
,	x	O
sizeof	eng	O
(	x	O
mint	eng	O
)	x	O
)	x	O
;	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
%	x	O
d	x	O
\	x	O
n	x	O
"	x	O
,	x	O
dp	eng	O
(	x	O
k	x	O
,	x	O
1	x	O
,	x	O
n	x	O
)	x	O
)	x	O
;	x	O
 	x	O
}	x	O
 	x	O
return	eng	O
 	x	O
0	x	O
;	x	O
 	x	O
}	x	O
 	x	O

	x	O