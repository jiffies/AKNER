PKU	eng	B-OJ
 	x	I-OJ
1821	m	I-OJ
 	x	O
Fence	eng	O
（	x	O
原来	d	O
DP	eng	B-KNOWLEDGE
也	d	O
是	v	O
会	v	O
超时	b	O
的	uj	O
。	x	O
。	x	O

）	x	O
 	x	O
-	x	O
 	x	O
low	eng	O
 	x	O
coder	eng	O
 	x	O
-	x	O
 	x	O
博客	nr	O
频道	n	O
 	x	O
-	x	O
 	x	O
CSDN	eng	O
.	m	O
NET	eng	O

	x	O

	x	O
O	x	O
(	x	O
N	x	O
*	x	O
N	x	O
*	x	O
K	x	O
)	x	O
的	uj	O
DP	eng	B-KNOWLEDGE
算法	n	O
还是	c	O
比较	d	O
容易	a	O
想到	v	O
的	uj	O
。	x	O

	x	O
但	c	O
可以	c	O
运用	vn	O
一个	m	O
贪心	v	O
策略	n	O
把	p	O
O	eng	O
(	x	O
N	x	O
*	x	O
N	x	O
)	x	O
变成	v	O
O	x	O
(	x	O
N	x	O
)	x	O
。	x	O

这	r	O
一点	m	O
还是	c	O
比较	d	O
难	a	O
的	uj	O
。	x	O
。	x	O
。	x	O

	x	O
给	p	O
个	m	O
抄来	v	O
的	uj	O
解题	n	O
报告	n	O

	x	O
题目	n	O
意思	n	O
就是说	c	O
给	p	O
你	r	O
一段	m	O
墙	n	O
，	x	O
有	v	O
K	eng	O
个	m	O
粉刷	v	O
工	n	O
，	x	O
每个	r	O
粉刷	v	O
工站	n	O
在	p	O
一个	m	O
位置	v	O
，	x	O
且	zg	O
每个	r	O
粉刷	v	O
工	n	O
只能	v	O
刷	v	O
L	eng	O
连续	a	O
长度	ns	O
的	uj	O
墙	n	O
，	x	O
且要	c	O
包括	v	O
他	r	O
所在	b	O
的	uj	O
位置	v	O
，	x	O
而且	c	O
每个	r	O
粉刷	v	O
工刷	vn	O
一个	m	O
单位	n	O
的	uj	O
墙	n	O
的	uj	O
价格	n	O
也	d	O
不	d	O
一样	r	O
，	x	O
问	n	O
怎么	r	O
刷能	v	O
达到	v	O
最大	a	O
价钱	n	O
 	x	O
先以	d	O
P	eng	O
为	p	O
关键字	n	O
对	p	O
工人	n	O
进行	v	O
排序	n	O
，	x	O
使	v	O
这个	r	O
顺序	n	O
作为	v	O
动态	n	O
规划	n	O
的	uj	O
阶段	n	O
。	x	O

	x	O
 	x	O
定义	n	O
F	x	O
[	x	O
I	x	O
]	x	O
代表	n	O
粉刷	v	O
前	f	O
I	eng	O
个	m	O
栅栏	n	O
最大	a	O
价值	n	O
，	x	O
有	v	O
如下	t	O
状态	n	O
转移	v	O
方程	n	O
：	x	O

	x	O
 	x	O
F	x	O
[	x	O
I	x	O
]	x	O
:	x	O
=	x	O
Max	eng	O
{	x	O
F	x	O
[	x	O
J	x	O
]	x	O
+	x	O
Len	eng	O
*	x	O
Cost	eng	O
}	x	O

	x	O
 	x	O
显然	ad	O
，	x	O
这个	r	O
方程	n	O
的	uj	O
复杂度	n	O
是	v	O
O	eng	O
（	x	O
K	x	O
*	x	O
N	x	O
*	x	O
N	x	O
）	x	O
的	uj	O
，	x	O
我们	r	O
需要	v	O
对	p	O
其	r	O
进行	v	O
优化	vn	O
。	x	O

	x	O
 	x	O
顺序	n	O
枚举	nz	O
工人	n	O
I	x	O
，	x	O
递减	v	O
的	uj	O
枚举	nz	O
右	f	O
边界	n	O
J	x	O
，	x	O
然后	c	O
定义	n	O
一个	m	O
变量	vn	O
K	x	O
，	x	O
初始	v	O
时	n	O
K	eng	O
=	x	O
P	x	O
[	x	O
I	x	O
]	x	O
，	x	O
代表	n	O
第	m	O
I	eng	O
个	m	O
工人	n	O
粉刷	v	O
的	uj	O
左	m	O
边界	n	O
。	x	O

	x	O
 	x	O
显然	ad	O
F	x	O
[	x	O
J	x	O
]	x	O
:	x	O
=	x	O
Max	eng	O
{	x	O
F	x	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
+	x	O
（	x	O
J	x	O
-	x	O
K	eng	O
+	x	O
1	m	O
）	x	O
*	x	O
Cost	eng	O
[	x	O
I	x	O
]	x	O
}	x	O

	x	O
 	x	O
现在	t	O
的	uj	O
关键	n	O
就	d	O
在于	v	O
维护	v	O
这个	r	O
K	x	O
。	x	O

	x	O
 	x	O
当	t	O
递减	v	O
循环	vn	O
到	v	O
J	eng	O
'	x	O
的	uj	O
时	n	O
，	x	O
设	n	O
T	eng	O
=	x	O
J	x	O
'	x	O
-	x	O
Len	eng	O
[	x	O
I	x	O
]	x	O
+	x	O
1	m	O
，	x	O
当	t	O
（	x	O
(	x	O
K	x	O
-	x	O
1	x	O
）	x	O
-	x	O
T	eng	O
+	x	O
1	m	O
）	x	O
*	x	O
Cost	eng	O
[	x	O
I	x	O
]	x	O
>	x	O
F	x	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
-	x	O
F	x	O
[	x	O
T	x	O
-	x	O
1	x	O
]	x	O
时	n	O
，	x	O
K	x	O
:	x	O
=	x	O
T	x	O
，	x	O
否则	c	O
K	x	O
不变	v	O
。	x	O

（	x	O
画画	n	O
图	n	O
就	d	O
明白	nr	O
了	ul	O
）	x	O
，	x	O
这里	r	O
表示	v	O
对于	p	O
下面	f	O
一个	m	O
右	f	O
边界	n	O
是否	v	O
需要	v	O
移动	vn	O
其	r	O
左	m	O
边界	n	O
。	x	O

	x	O
我	r	O
差不多	l	O
就是	d	O
按照	p	O
这个	r	O
思路	n	O
来	v	O
的	uj	O
，	x	O
不过	c	O
我	r	O
的	uj	O
最	a	O
外面	f	O
的	uj	O
循环	vn	O
是	v	O
逆	vg	O
着	uz	O
的	uj	O
，	x	O
所以	c	O
方向	n	O
也	d	O
是	v	O
逆	vg	O
着	uz	O
的	uj	O
。	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
algorithm	eng	O
>	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
iostream	eng	O
>	x	O

	x	O
#	x	O
define	eng	O
 	x	O
_	x	O
clr	eng	O
(	x	O
a	x	O
,	x	O
b	x	O
)	x	O
 	x	O
memset	eng	O
(	x	O
a	x	O
,	x	O
b	x	O
,	x	O
sizeof	eng	O
(	x	O
a	x	O
)	x	O
)	x	O

	x	O
template	eng	O
<	x	O
class	eng	O
 	x	O
T	x	O
>	x	O
 	x	O
void	eng	O
 	x	O
get	eng	O
_	x	O
max	eng	O
(	x	O
T	eng	O
&	x	O
 	x	O
a	x	O
,	x	O
T	x	O
 	x	O
b	x	O
)	x	O

	x	O
{	x	O
 	x	O
if	eng	O
(	x	O
a	x	O
<	x	O
b	x	O
)	x	O
 	x	O
a	x	O
=	x	O
b	x	O
;	x	O
}	x	O

	x	O
using	eng	O
 	x	O
namespace	eng	O
 	x	O
std	eng	O
;	x	O

	x	O
int	eng	O
 	x	O
N	x	O
,	x	O
K	x	O
;	x	O

	x	O
struct	eng	O
 	x	O
node	eng	O

	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
int	eng	O
 	x	O
pos	eng	O
,	x	O
cost	eng	O
,	x	O
len	eng	O
;	x	O

	x	O
}	x	O
nodes	eng	O
[	x	O
105	m	O
]	x	O
;	x	O

	x	O
bool	eng	O
 	x	O
operator	eng	O
<	x	O
(	x	O
node	eng	O
&	x	O
 	x	O
a	x	O
,	x	O
node	eng	O
&	x	O
 	x	O
b	x	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
return	eng	O
 	x	O
a	eng	O
.	m	O
pos	eng	O
<	x	O
b	eng	O
.	m	O
pos	eng	O
;	x	O

	x	O
}	x	O

	x	O
void	eng	O
 	x	O
intcpy	eng	O
(	x	O
int	eng	O
 	x	O
a	x	O
[	x	O
]	x	O
,	x	O
int	eng	O
 	x	O
b	x	O
[	x	O
]	x	O
,	x	O
int	eng	O
 	x	O
len	eng	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	x	O
<	x	O
len	eng	O
;	x	O
i	eng	O
++	x	O
)	x	O
 	x	O
a	x	O
[	x	O
i	x	O
]	x	O
=	x	O
b	x	O
[	x	O
i	x	O
]	x	O
;	x	O

	x	O
}	x	O

	x	O
int	eng	O
 	x	O
DP	eng	O
[	x	O
105	m	O
]	x	O
[	x	O
16005	m	O
]	x	O
;	x	O

	x	O
int	eng	O
 	x	O
end	eng	O
[	x	O
16005	m	O
]	x	O
;	x	O

	x	O
int	eng	O
 	x	O
main	eng	O
(	x	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
scanf	eng	O
(	x	O
"	x	O
%	x	O
d	x	O
%	x	O
d	x	O
"	x	O
,	x	O
&	x	O
N	eng	O
,	x	O
&	x	O
K	eng	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	x	O
<	x	O
K	x	O
;	x	O
i	eng	O
++	x	O
)	x	O
 	x	O
scanf	eng	O
(	x	O
"	x	O
%	x	O
d	x	O
%	x	O
d	x	O
%	x	O
d	x	O
"	x	O
,	x	O
&	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
len	eng	O
,	x	O
&	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
cost	eng	O
,	x	O
&	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
sort	eng	O
(	x	O
nodes	eng	O
,	x	O
nodes	eng	O
+	x	O
K	eng	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
_	x	O
clr	eng	O
(	x	O
DP	eng	O
,	x	O
0	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
=	x	O
max	eng	O
(	x	O
1	x	O
,	x	O
nodes	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
.	m	O
pos	eng	O
-	x	O
nodes	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
.	m	O
len	eng	O
+	x	O
1	m	O
)	x	O
;	x	O
i	x	O
<	x	O
=	x	O
nodes	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
.	m	O
pos	eng	O
;	x	O
i	eng	O
++	x	O
)	x	O
 	x	O
DP	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
[	x	O
i	x	O
]	x	O
=	x	O
min	eng	O
(	x	O
nodes	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
.	m	O
len	eng	O
,	x	O
N	x	O
-	x	O
i	eng	O
+	x	O
1	m	O
)	x	O
*	x	O
nodes	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
.	m	O
cost	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
=	x	O
1	x	O
;	x	O
i	x	O
<	x	O
=	x	O
nodes	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
.	m	O
pos	eng	O
-	x	O
nodes	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
.	m	O
len	eng	O
;	x	O
i	eng	O
++	x	O
)	x	O
 	x	O
DP	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
[	x	O
i	x	O
]	x	O
=	x	O
DP	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
[	x	O
nodes	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
.	m	O
pos	eng	O
-	x	O
nodes	eng	O
[	x	O
K	x	O
-	x	O
1	x	O
]	x	O
.	m	O
len	eng	O
+	x	O
1	m	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
i	x	O
=	x	O
K	x	O
-	x	O
2	x	O
;	x	O
i	x	O
>	x	O
=	x	O
0	x	O
;	x	O
i	x	O
-	x	O
-	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
int	eng	O
 	x	O
dd	eng	O
=	x	O
max	eng	O
(	x	O
0	x	O
,	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
-	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
len	eng	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
intcpy	eng	O
(	x	O
DP	eng	O
[	x	O
i	x	O
]	x	O
+	x	O
1	m	O
,	x	O
DP	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
+	x	O
1	m	O
,	x	O
N	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
end	eng	O
[	x	O
0	x	O
]	x	O
=	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
+	x	O
1	m	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
j	x	O
=	x	O
1	x	O
;	x	O
j	x	O
<	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
len	eng	O
;	x	O
j	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
DP	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
end	eng	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
]	x	O
-	x	O
DP	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
min	eng	O
(	x	O
N	eng	O
+	x	O
1	m	O
,	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
+	x	O
1	m	O
+	x	O
j	eng	O
)	x	O
]	x	O
<	x	O
min	eng	O
(	x	O
j	eng	O
+	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
-	x	O
end	eng	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
+	x	O
1	m	O
,	x	O
N	x	O
-	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
)	x	O
*	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
cost	eng	O
)	x	O
 	x	O
end	eng	O
[	x	O
j	x	O
]	x	O
=	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
+	x	O
1	m	O
+	x	O
min	eng	O
(	x	O
j	x	O
,	x	O
N	x	O
-	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
else	eng	O
 	x	O
end	eng	O
[	x	O
j	x	O
]	x	O
=	x	O
end	eng	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
start	eng	O
=	x	O
dd	eng	O
+	x	O
1	m	O
;	x	O
start	eng	O
<	x	O
=	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
;	x	O
start	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
get	eng	O
_	x	O
max	eng	O
(	x	O
DP	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
start	eng	O
]	x	O
,	x	O
DP	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
end	eng	O
[	x	O
start	eng	O
+	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
len	eng	O
-	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
-	x	O
1	x	O
]	x	O
]	x	O
+	x	O
(	x	O
end	eng	O
[	x	O
start	eng	O
+	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
len	eng	O
-	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
pos	eng	O
-	x	O
1	x	O
]	x	O
-	x	O
start	eng	O
)	x	O
*	x	O
nodes	eng	O
[	x	O
i	x	O
]	x	O
.	m	O
cost	eng	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
int	eng	O
 	x	O
j	x	O
=	x	O
1	x	O
;	x	O
j	x	O
<	x	O
=	x	O
dd	eng	O
;	x	O
j	eng	O
++	x	O
)	x	O
 	x	O
get	eng	O
_	x	O
max	eng	O
(	x	O
DP	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
,	x	O
DP	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
dd	eng	O
+	x	O
1	m	O
]	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
%	x	O
d	x	O
/	x	O
n	x	O
"	x	O
,	x	O
DP	eng	O
[	x	O
0	x	O
]	x	O
[	x	O
1	x	O
]	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
return	eng	O
 	x	O
0	x	O
;	x	O

	x	O
}	x	O

	x	O