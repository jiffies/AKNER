POJ	eng	N	Y	O	B-OJ

2418	m	N	N	O	I-OJ

Hardwood	eng	N	N	O	O

Species	eng	N	N	O	O
(	x	N	N	O	O
排序	n	Y	N	O	O
二叉树	n	Y	N	O	B-KNOWLEDGE
)	x	N	N	O	O

-	x	N	N	O	O

Alasky	eng	N	N	O	O
的	uj	N	N	O	O
日志	ns	N	N	O	O

-	x	N	N	O	O

网易	n	N	N	O	O
博客	nr	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
不用	v	N	N	O	O
平衡	a	Y	N	O	O
技术	n	N	N	O	O
的	uj	N	N	O	O
后果	n	N	N	O	O
...	m	N	N	O	O
果断	d	N	N	O	O
1313	m	N	N	O	O
MS	eng	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
一般	a	N	N	O	O
我	r	N	N	O	O
的	uj	N	N	O	O
代码	n	N	N	O	O
会	v	N	N	O	O
相对	d	N	N	O	O
比较	d	N	N	O	O
长	a	N	N	O	O
，	x	N	N	O	O
因为	c	N	N	O	O
我	r	N	N	O	O
自己	r	N	N	O	O
写	v	N	N	O	O
栈	ng	N	N	O	B-KNOWLEDGE
。	x	N	N	O	O
。	x	N	N	O	O

初学者	n	N	N	O	O
还是	c	N	N	O	O
多	m	N	N	O	O
自己	r	N	N	O	O
写写	v	N	N	O	O
吧	y	N	N	O	O
。	x	N	N	O	O
。	x	N	N	O	O
。	x	N	N	O	O

#	x	N	N	O	O
include	eng	N	N	O	O

"	x	N	N	O	O
stdio	eng	N	N	O	O
.	m	N	N	O	O
h	eng	N	N	O	O
"	x	N	N	O	O

#	x	N	N	O	O
include	eng	N	N	O	O

"	x	N	N	O	O
string	eng	N	N	O	O
.	m	N	N	O	O
h	eng	N	N	O	O
"	x	N	N	O	O

#	x	N	N	O	O
include	eng	N	N	O	O

"	x	N	N	O	O
malloc	eng	N	N	O	O
.	m	N	N	O	O
h	eng	N	N	O	O
"	x	N	N	O	O

#	x	N	N	O	O
include	eng	N	N	O	O

"	x	N	N	O	O
stdlib	eng	N	N	O	O
.	m	N	N	O	O
h	eng	N	N	O	O
"	x	N	N	O	O

#	x	N	N	O	O
define	eng	N	N	O	O

SIZE	eng	N	N	O	O

30	m	N	N	O	O

#	x	N	N	O	O
define	eng	N	N	O	O

STACKSIZE	eng	N	N	O	O

10000	m	N	N	O	O

#	x	N	N	O	O
define	eng	N	N	O	O

EQ	eng	N	N	O	O
(	x	N	N	O	O
a	x	N	N	O	O
,	x	N	N	O	O

b	x	N	N	O	O
)	x	N	N	O	O

(	x	N	N	O	O
!	x	N	N	O	O
strcmp	eng	N	N	O	O
(	x	N	N	O	O
(	x	N	N	O	O
a	x	N	N	O	O
)	x	N	N	O	O
,	x	N	N	O	O

(	x	N	N	O	O
b	x	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O

#	x	N	N	O	O
define	eng	N	N	O	O

RT	eng	N	N	O	O
(	x	N	N	O	O
a	x	N	N	O	O
,	x	N	N	O	O

b	x	N	N	O	O
)	x	N	N	O	O

(	x	N	N	O	O
strcmp	eng	N	N	O	O
(	x	N	N	O	O
(	x	N	N	O	O
a	x	N	N	O	O
)	x	N	N	O	O
,	x	N	N	O	O

(	x	N	N	O	O
b	x	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O

>	x	N	N	O	O

0	x	N	N	O	O
)	x	N	N	O	O

#	x	N	N	O	O
define	eng	N	N	O	O

LT	eng	N	N	O	O
(	x	N	N	O	O
a	x	N	N	O	O
,	x	N	N	O	O

b	x	N	N	O	O
)	x	N	N	O	O

(	x	N	N	O	O
strcmp	eng	N	N	O	O
(	x	N	N	O	O
(	x	N	N	O	O
a	x	N	N	O	O
)	x	N	N	O	O
,	x	N	N	O	O

(	x	N	N	O	O
b	x	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O

<	x	N	N	O	O

0	x	N	N	O	O
)	x	N	N	O	O

typedef	eng	N	N	O	O

struct	eng	N	N	O	O

BSTNode	eng	N	N	O	O
{	x	N	N	O	O

int	eng	N	N	O	O

n	x	N	N	O	O
;	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
amount	eng	N	N	O	O

of	eng	N	N	O	O

the	eng	N	N	O	O

tree	eng	N	N	O	O

of	eng	N	N	O	O

this	eng	N	N	O	O

type	eng	N	N	O	O

char	eng	N	N	O	O

key	eng	N	N	O	O
[	x	N	N	O	O
SIZE	eng	N	N	O	O
+	x	N	N	O	O
1	m	N	N	O	O
]	x	N	N	O	O
;	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
tree	eng	N	N	O	O

name	eng	N	N	O	O

BSTNode	eng	N	N	O	O

*	x	N	N	O	O
lchild	eng	N	N	O	O
,	x	N	N	O	O

*	x	N	N	O	O
rchild	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O
BSTNode	eng	N	N	O	O
,	x	N	N	O	O

*	x	N	N	O	O
BSTree	eng	N	N	O	O
;	x	N	N	O	O

BSTree	eng	N	N	O	O

root	eng	N	N	O	O
;	x	N	N	O	O

int	eng	N	N	O	O

total	eng	N	N	O	O
;	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
树	v	N	N	O	O
的	uj	N	N	O	O
总数	n	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
____________	x	N	N	O	O
得	ud	N	N	O	O
，	x	N	N	O	O
自己	r	N	N	O	O
再	d	N	N	O	O
写	v	N	N	O	O
一个	m	N	N	O	O
栈	n	N	N	O	B-KNOWLEDGE
，	x	N	N	O	O
The	eng	N	N	O	O

fact	eng	N	N	O	O

is	eng	N	N	O	O

that	eng	N	N	O	O

it	eng	N	N	O	O

only	eng	N	N	O	O

costs	eng	N	N	O	O

a	x	N	N	O	O

few	eng	N	N	O	O

time	eng	N	N	O	O
.	m	N	N	O	O

typedef	eng	N	N	O	O

struct	eng	N	N	O	O

SNode	eng	N	N	O	O
{	x	N	N	O	O

BSTree	eng	N	N	O	O

*	x	N	N	O	O
base	eng	N	N	O	O
;	x	N	N	O	O

BSTree	eng	N	N	O	O

*	x	N	N	O	O
top	eng	N	N	O	O
;	x	N	N	O	O

int	eng	N	N	O	O

stacksize	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O
SqStack	eng	N	N	O	O
;	x	N	N	O	O

bool	eng	N	N	O	O

InitStack	eng	N	N	O	O
(	x	N	N	O	O
SqStack	eng	N	N	O	O

&	x	N	N	O	O
S	eng	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
初始化	l	N	N	O	O
一个	m	N	N	O	O
栈	n	N	N	O	B-KNOWLEDGE

if	eng	N	N	O	O

(	x	N	N	O	O
!	x	N	N	O	O
(	x	N	N	O	O
S	eng	N	N	O	O
.	m	N	N	O	O
base	eng	N	N	O	O

=	x	N	N	O	O

(	x	N	N	O	O
BSTree	eng	N	N	O	O
*	x	N	N	O	O
)	x	N	N	O	O
malloc	eng	N	N	O	O
(	x	N	N	O	O
STACKSIZE	eng	N	N	O	O
*	x	N	N	O	O
sizeof	eng	N	N	O	O
(	x	N	N	O	O
BSTree	eng	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O

exit	eng	N	N	O	O
(	x	N	N	O	O
0	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
top	eng	N	N	O	O

=	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
base	eng	N	N	O	O
;	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
stacksize	eng	N	N	O	O

=	x	N	N	O	O

STACKSIZE	eng	N	N	O	O
;	x	N	N	O	O

return	eng	N	N	O	O

true	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
InitStack	eng	N	N	O	O

bool	eng	N	N	O	O

Push	eng	N	N	O	O
(	x	N	N	O	O
SqStack	eng	N	N	O	O

&	x	N	N	O	O
S	eng	N	N	O	O
,	x	N	N	O	O

BSTree	eng	N	N	O	O

e	x	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
S	eng	N	N	O	O
.	m	N	N	O	O
top	eng	N	N	O	O

-	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
base	eng	N	N	O	O

>	x	N	N	O	O
=	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
stacksize	eng	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
base	eng	N	N	O	O

=	x	N	N	O	O

(	x	N	N	O	O
BSTree	eng	N	N	O	O

*	x	N	N	O	O
)	x	N	N	O	O
realloc	eng	N	N	O	O
(	x	N	N	O	O
S	eng	N	N	O	O
.	m	N	N	O	O
base	eng	N	N	O	O
,	x	N	N	O	O

(	x	N	N	O	O
S	eng	N	N	O	O
.	m	N	N	O	O
stacksize	eng	N	N	O	O

+	x	N	N	O	O

STACKSIZE	eng	N	N	O	O
)	x	N	N	O	O
*	x	N	N	O	O
sizeof	eng	N	N	O	O
(	x	N	N	O	O
BSTree	eng	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
!	x	N	N	O	O
S	eng	N	N	O	O
.	m	N	N	O	O
base	eng	N	N	O	O
)	x	N	N	O	O

exit	eng	N	N	O	O
(	x	N	N	O	O
0	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
top	eng	N	N	O	O

=	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
base	eng	N	N	O	O

+	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
stacksize	eng	N	N	O	O
;	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
stacksize	eng	N	N	O	O

+	x	N	N	O	O
=	x	N	N	O	O

STACKSIZE	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

*	x	N	N	O	O
S	eng	N	N	O	O
.	m	N	N	O	O
top	eng	N	N	O	O
++	x	N	N	O	O

=	x	N	N	O	O

e	x	N	N	O	O
;	x	N	N	O	O

return	eng	N	N	O	O

true	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
Push	eng	N	N	O	O

bool	eng	N	N	O	O

Pop	eng	N	N	O	O
(	x	N	N	O	O
SqStack	eng	N	N	O	O

&	x	N	N	O	O
S	eng	N	N	O	O
,	x	N	N	O	O

BSTree	eng	N	N	O	O

&	x	N	N	O	O
e	eng	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
S	eng	N	N	O	O
.	m	N	N	O	O
top	eng	N	N	O	O

=	x	N	N	O	O
=	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
base	eng	N	N	O	O
)	x	N	N	O	O

return	eng	N	N	O	O

false	eng	N	N	O	O
;	x	N	N	O	O

e	x	N	N	O	O

=	x	N	N	O	O

*	x	N	N	O	O
(	x	N	N	O	O
-	x	N	N	O	O
-	x	N	N	O	O
S	eng	N	N	O	O
.	m	N	N	O	O
top	eng	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

return	eng	N	N	O	O

true	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
Pop	eng	N	N	O	O

bool	eng	N	N	O	O

EmptyStack	eng	N	N	O	O
(	x	N	N	O	O
SqStack	eng	N	N	O	O

&	x	N	N	O	O
S	eng	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
S	eng	N	N	O	O
.	m	N	N	O	O
top	eng	N	N	O	O

=	x	N	N	O	O
=	x	N	N	O	O

S	eng	N	N	O	O
.	m	N	N	O	O
base	eng	N	N	O	O
)	x	N	N	O	O

return	eng	N	N	O	O

true	eng	N	N	O	O
;	x	N	N	O	O

else	eng	N	N	O	O

return	eng	N	N	O	O

false	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
EmptyStack	eng	N	N	O	O

bool	eng	N	N	O	O

SearchBST	eng	N	N	O	O
(	x	N	N	O	O
BSTree	eng	N	N	O	O

T	x	N	N	O	O
,	x	N	N	O	O

char	eng	N	N	O	O

*	x	N	N	O	O
key	eng	N	N	O	O
,	x	N	N	O	O

BSTree	eng	N	N	O	O

f	x	N	N	O	O
,	x	N	N	O	O

BSTree	eng	N	N	O	O

&	x	N	N	O	O
p	eng	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
在	p	N	N	O	O
二叉树	n	Y	N	O	B-KNOWLEDGE
中	f	N	N	O	O
查找	v	Y	N	O	O
key	eng	N	N	O	O
，	x	N	N	O	O
查找	v	Y	N	O	O
成功	a	N	N	O	O
，	x	N	N	O	O
对应	vn	N	N	O	O
n	eng	N	N	O	O
值	n	N	N	O	O
+	x	N	N	O	O
1	m	N	N	O	O
；	x	N	N	O	O
否则	c	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
p	eng	N	N	O	O
值	n	N	N	O	O
返回	v	N	N	O	O
应该	v	N	N	O	O
插入	v	N	N	O	O
的	uj	N	N	O	O
结点	n	Y	N	O	O
的	uj	N	N	O	O
双亲	n	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
!	x	N	N	O	O
T	x	N	N	O	O
)	x	N	N	O	O

{	x	N	N	O	O
p	x	N	N	O	O

=	x	N	N	O	O

f	x	N	N	O	O
;	x	N	N	O	O

return	eng	N	N	O	O

false	eng	N	N	O	O
;	x	N	N	O	O
}	x	N	N	O	O

else	eng	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
EQ	eng	N	N	O	O
(	x	N	N	O	O
key	eng	N	N	O	O
,	x	N	N	O	O

T	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
key	eng	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O

{	x	N	N	O	O
T	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
n	eng	N	N	O	O
++	x	N	N	O	O
;	x	N	N	O	O

return	eng	N	N	O	O

true	eng	N	N	O	O
;	x	N	N	O	O
}	x	N	N	O	O

else	eng	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
LT	eng	N	N	O	O
(	x	N	N	O	O
key	eng	N	N	O	O
,	x	N	N	O	O

T	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
key	eng	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O

return	eng	N	N	O	O

SearchBST	eng	N	N	O	O
(	x	N	N	O	O
T	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
lchild	eng	N	N	O	O
,	x	N	N	O	O

key	eng	N	N	O	O
,	x	N	N	O	O

T	x	N	N	O	O
,	x	N	N	O	O

p	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

else	eng	N	N	O	O

return	eng	N	N	O	O

SearchBST	eng	N	N	O	O
(	x	N	N	O	O
T	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
rchild	eng	N	N	O	O
,	x	N	N	O	O

key	eng	N	N	O	O
,	x	N	N	O	O

T	x	N	N	O	O
,	x	N	N	O	O

p	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
SearchBST	eng	N	N	O	O

bool	eng	N	N	O	O

InsertBST	eng	N	N	O	O
(	x	N	N	O	O
BSTree	eng	N	N	O	O

&	x	N	N	O	O
T	eng	N	N	O	O
,	x	N	N	O	O

char	eng	N	N	O	O

*	x	N	N	O	O
e	x	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
查找	v	Y	N	O	O
e	eng	N	N	O	O
.	m	N	N	O	O
key	eng	N	N	O	O
，	x	N	N	O	O
如果	c	N	N	O	O
存在	v	N	N	O	O
n	eng	N	N	O	O
值	n	N	N	O	O
+	x	N	N	O	O
1	m	N	N	O	O
；	x	N	N	O	O
否则	c	N	N	O	O
插入	v	N	N	O	O

BSTNode	eng	N	N	O	O

*	x	N	N	O	O
p	x	N	N	O	O
;	x	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
!	x	N	N	O	O
SearchBST	eng	N	N	O	O
(	x	N	N	O	O
T	x	N	N	O	O
,	x	N	N	O	O

e	x	N	N	O	O
,	x	N	N	O	O

NULL	eng	N	N	O	O
,	x	N	N	O	O

p	x	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

BSTNode	eng	N	N	O	O

*	x	N	N	O	O
s	x	N	N	O	O

=	x	N	N	O	O

(	x	N	N	O	O
BSTree	eng	N	N	O	O
)	x	N	N	O	O
malloc	eng	N	N	O	O
(	x	N	N	O	O
sizeof	eng	N	N	O	O
(	x	N	N	O	O
BSTNode	eng	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

s	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
n	x	N	N	O	O

=	x	N	N	O	O

1	x	N	N	O	O
;	x	N	N	O	O

strcpy	eng	N	N	O	O
(	x	N	N	O	O
s	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
key	eng	N	N	O	O
,	x	N	N	O	O

e	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

s	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
lchild	eng	N	N	O	O

=	x	N	N	O	O

s	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
rchild	eng	N	N	O	O

=	x	N	N	O	O

NULL	eng	N	N	O	O
;	x	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
!	x	N	N	O	O
p	x	N	N	O	O
)	x	N	N	O	O

T	x	N	N	O	O

=	x	N	N	O	O

s	x	N	N	O	O
;	x	N	N	O	O

else	eng	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
LT	eng	N	N	O	O
(	x	N	N	O	O
e	x	N	N	O	O
,	x	N	N	O	O

p	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
key	eng	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O

p	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
lchild	eng	N	N	O	O

=	x	N	N	O	O

s	x	N	N	O	O
;	x	N	N	O	O

else	eng	N	N	O	O

p	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
rchild	eng	N	N	O	O

=	x	N	N	O	O

s	x	N	N	O	O
;	x	N	N	O	O

return	eng	N	N	O	O

true	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

return	eng	N	N	O	O

false	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
InsertBST	eng	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
从小到大	l	N	N	O	O
输出	v	Y	N	O	O
需要	v	N	N	O	O
中序	n	N	N	O	O
遍历	v	Y	N	O	O

bool	eng	N	N	O	O

InOrdTraverse	eng	N	N	O	O
(	x	N	N	O	O
BSTree	eng	N	N	O	O

T	x	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
中序	n	N	N	O	O
遍历	v	Y	N	O	O
排序	n	Y	N	O	O
二叉树	n	Y	N	O	B-KNOWLEDGE
，	x	N	N	O	O
虽然	c	N	N	O	O
这里	r	N	N	O	O
我	r	N	N	O	O
没有	v	N	N	O	O
引入	v	N	N	O	O
平衡	a	Y	N	O	B-KNOWLEDGE
二叉树	n	Y	N	O	I-KNOWLEDGE
的	uj	N	N	O	O
结构	n	Y	N	O	O
，	x	N	N	O	O
但	c	N	N	O	O
勉强	v	N	N	O	O
来	v	N	N	O	O
一次	m	N	N	O	O
吧	y	N	N	O	O
。	x	N	N	O	O
。	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
damn	eng	N	N	O	O

it	eng	N	N	O	O
!	x	N	N	O	O
!	x	N	N	O	O
我	r	N	N	O	O
突然	ad	N	N	O	O
发现	v	N	N	O	O
，	x	N	N	O	O
Stack	eng	N	N	O	O

is	eng	N	N	O	O

in	eng	Y	N	O	O

demand	eng	N	N	O	O
。	x	N	N	O	O
。	x	N	N	O	O
。	x	N	N	O	O
。	x	N	N	O	O
。	x	N	N	O	O

more	eng	N	N	O	O

time	eng	N	N	O	O

will	eng	N	N	O	O

elaps	eng	N	N	O	O
~	x	N	N	O	O
~	x	N	N	O	O
~	x	N	N	O	O
~	x	N	N	O	O

SqStack	eng	N	N	O	O

S	x	N	N	O	O
;	x	N	N	O	O

InitStack	eng	N	N	O	O
(	x	N	N	O	O
S	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

while	eng	N	N	O	O

(	x	N	N	O	O
T	x	N	N	O	O

|	x	N	N	O	O
|	x	N	N	O	O

!	x	N	N	O	O
EmptyStack	eng	N	N	O	O
(	x	N	N	O	O
S	x	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

if	eng	N	N	O	O

(	x	N	N	O	O
T	x	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

Push	eng	N	N	O	O
(	x	N	N	O	O
S	x	N	N	O	O
,	x	N	N	O	O

T	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

T	x	N	N	O	O

=	x	N	N	O	O

T	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
lchild	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

else	eng	N	N	O	O
{	x	N	N	O	O

Pop	eng	N	N	O	O
(	x	N	N	O	O
S	x	N	N	O	O
,	x	N	N	O	O

T	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

printf	eng	N	N	O	O
(	x	N	N	O	O
"	x	N	N	O	O
%	x	N	N	O	O
s	x	N	N	O	O

%	x	N	N	O	O
.4	m	N	N	O	O
lf	eng	N	N	O	O
\	x	N	N	O	O
n	x	N	N	O	O
"	x	N	N	O	O
,	x	N	N	O	O

T	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
key	eng	N	N	O	O
,	x	N	N	O	O

(	x	N	N	O	O
double	eng	N	N	O	O
)	x	N	N	O	O
T	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
n	x	N	N	O	O
/	x	N	N	O	O
total	eng	N	N	O	O
*	x	N	N	O	O
100	m	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

T	x	N	N	O	O

=	x	N	N	O	O

T	x	N	N	O	O
-	x	N	N	O	O
>	x	N	N	O	O
rchild	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

}	x	N	N	O	O

return	eng	N	N	O	O

true	eng	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

/	x	N	N	O	O
/	x	N	N	O	O
InOrdTraverse	eng	N	N	O	O

int	eng	N	N	O	O

main	eng	N	N	O	O
(	x	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

char	eng	N	N	O	O

s	x	N	N	O	O
[	x	N	N	O	O
SIZE	eng	N	N	O	O
+	x	N	N	O	O
1	m	N	N	O	O
]	x	N	N	O	O
;	x	N	N	O	O

total	eng	N	N	O	O

=	x	N	N	O	O

0	x	N	N	O	O
;	x	N	N	O	O

while	eng	N	N	O	O

(	x	N	N	O	O
gets	eng	N	N	O	O
(	x	N	N	O	O
s	x	N	N	O	O
)	x	N	N	O	O
)	x	N	N	O	O
{	x	N	N	O	O

total	eng	N	N	O	O
++	x	N	N	O	O
;	x	N	N	O	O

InsertBST	eng	N	N	O	O
(	x	N	N	O	O
root	eng	N	N	O	O
,	x	N	N	O	O

s	x	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

InOrdTraverse	eng	N	N	O	O
(	x	N	N	O	O
root	eng	N	N	O	O
)	x	N	N	O	O
;	x	N	N	O	O

return	eng	N	N	O	O

0	x	N	N	O	O
;	x	N	N	O	O

}	x	N	N	O	O

