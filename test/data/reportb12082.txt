poj2227 The Wedding Juicer_moonlight131_百度空间

这是黑书上的例题，需要用二叉堆，由于本人蒟蒻，不会自己写，只会用优先队列+dfs+bfs水过，希望读者谅解。
#include <stdlib.h>#include <iostream>#include <queue>using namespace std;const int maxn=305;int map[maxn][maxn];int use[maxn][maxn];struct NODE{ int val; int x,y;}R,P;int w,h,ans;priority_queue<NODE>Q;int move[4][2]={-1,0,0,1,1,0,0,-1};bool operator<(const NODE &a,const NODE &b){ return a.val>b.val;}void dfs(int x,int y){ int x0,y0; for(int i=0;i<4;i++) { x0=x+move[i][0]; y0=y+move[i][1]; if(x0>h||x0<1||y0>w||y0<1)continue; if(map[x0][y0]<map[R.x][R.y]) { int tmp=map[x0][y0]; map[x0][y0]=map[R.x][R.y]; if(use[x0][y0])continue; else { ans+=map[R.x][R.y]-tmp; use[x0][y0]=1; P.x=x0;P.y=y0;P.val=map[x0][y0]; Q.push(P); dfs(x0,y0); } } else { if(use[x0][y0])continue; else { use[x0][y0]=1; P.x=x0;P.y=y0;P.val=map[x0][y0]; Q.push(P); } } }}void bfs(){ for(int i=1;i<=w;i++) { R.val=map[1][i]; R.x=1;R.y=i; Q.push(R); use[R.x][R.y]=1; R.val=map[h][i]; R.x=h;R.y=i; Q.push(R); use[R.x][R.y]=1; } for(int i=2;i<h;i++) { R.val=map[i][1]; R.x=i;R.y=1; Q.push(R); use[R.x][R.y]=1; R.val=map[i][w]; R.x=i;R.y=w; Q.push(R); use[R.x][R.y]=1; } while(!Q.empty()) { R=Q.top(); Q.pop(); dfs(R.x,R.y); }}int main(int argc, char** argv) { cin>>w>>h; int s=0; ans=0; for(int i=1;i<=h;i++) for(int j=1;j<=w;j++) { scanf("%d",&map[i][j]); } bfs(); printf("%d\n",ans); return (EXIT_SUCCESS);}

