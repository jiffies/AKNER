poj	eng	B-OJ
 	x	I-OJ
1141	m	I-OJ
 	x	O
Brackets	eng	O
 	x	O
Sequence	eng	O
_	x	O
乐吾天	nr	O
_	x	O
百度	n	O
空间	n	O

	x	O

	x	O
题目	n	O
大意	d	O
:	x	O
给	p	O
你	r	O
一贯	m	O
括号	n	O
序列	n	O
(	x	O
只	d	O
包含	v	O
小括号	n	O
和	c	O
中括号	nz	O
)	x	O
，	x	O
让	v	O
你	r	O
找出	v	O
长度	ns	O
最小	a	O
的	uj	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
包含	v	O
此子	r	O
序列	n	O
.	x	O
其中	r	O
的	uj	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
定义	n	O
如下	t	O
:	x	O

	x	O
1	x	O
)	x	O
空	n	O
序列	n	O
是	v	O
一个	m	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
;	x	O

	x	O
2	x	O
)	x	O
如果	c	O
s	eng	O
是	v	O
一个	m	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
,	x	O
那么	r	O
[	x	O
s	x	O
]	x	O
 	x	O
也	d	O
是	v	O
一个	m	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
,	x	O
(	x	O
s	x	O
)	x	O
也	d	O
是	v	O
一个	m	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
.	m	O

	x	O
3	x	O
)	x	O
如果	c	O
A	x	O
,	x	O
B	eng	O
都	d	O
是	v	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
,	x	O
那么	r	O
AB	eng	O
也	d	O
是	v	O
一个	m	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
.	m	O

	x	O
例如	v	O
:	x	O
(	x	O
)	x	O
、	x	O
[	x	O
]	x	O
、	x	O
(	x	O
)	x	O
[	x	O
]	x	O
 	x	O
、	x	O
(	x	O
[	x	O
]	x	O
)	x	O
 	x	O
、	x	O
(	x	O
[	x	O
]	x	O
)	x	O
(	x	O
)	x	O
[	x	O
(	x	O
)	x	O
]	x	O
都	d	O
是	v	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
。	x	O

	x	O
而	c	O
[	x	O
[	x	O
[	x	O
、	x	O
 	x	O
(	x	O
(	x	O
(	x	O
(	x	O
(	x	O
、	x	O
 	x	O
(	x	O
[	x	O
)	x	O
]	x	O
 	x	O
则	d	O
都	d	O
不是	c	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
。	x	O

其中	r	O
以	p	O
“	x	O
(	x	O
[	x	O
)	x	O
]	x	O
”	x	O
为	p	O
例	v	O
，	x	O
包含	v	O
它	r	O
最小	a	O
的	uj	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
有	v	O
两个	m	O
:	x	O
(	x	O
)	x	O
[	x	O
(	x	O
)	x	O
]	x	O
或者	c	O
是	v	O
(	x	O
[	x	O
]	x	O
)	x	O
[	x	O
]	x	O
.	m	O
而	c	O
你	r	O
只要	c	O
输出	v	O
其中	r	O
一个	m	O
就	d	O
行	v	O
。	x	O

	x	O
好	a	O
了	ul	O
，	x	O
题目	n	O
题意	n	O
讲完	v	O
了	ul	O
，	x	O
应该	v	O
理解	v	O
了	ul	O
吧	y	O
。	x	O

下面	f	O
开始	v	O
分析	vn	O
：	x	O

	x	O
这个	r	O
问题	n	O
一眼	m	O
就	d	O
可以	c	O
看出	v	O
是	v	O
DP	eng	O
题	n	O
，	x	O
为什么	r	O
呢	y	B-KNOWLEDGE
？	x	I-KNOWLEDGE
因为	c	O
很	zg	O
明显	a	O
这个	r	O
问题	n	O
可以	c	O
根据	p	O
它	r	O
定义	n	O
中	f	O
的	uj	O
（	x	O
2	x	O
）	x	O
和	c	O
（	x	O
3	x	O
）	x	O
这	r	O
两条	m	O
性质	n	O
划分	v	O
出	v	O
更	d	O
小	a	O
的	uj	O
子	n	O
问题	n	O
。	x	O

也就是说	l	O
，	x	O
一个	m	O
序列	n	O
如果	c	O
 	x	O
是	v	O
AB	eng	O
形式	n	O
的话	u	O
，	x	O
我们	r	O
可以	c	O
划分	v	O
为	p	O
A	eng	O
，	x	O
B	x	O
两个	m	O
子	ng	O
问题	n	O
；	x	O
而	c	O
如果	c	O
序列	n	O
是	v	O
[	x	O
A	x	O
]	x	O
或者	c	O
(	x	O
A	x	O
)	x	O
的	uj	O
形式	n	O
，	x	O
我们	r	O
可以	c	O
把	p	O
它	r	O
降为	v	O
分析	vn	O
A	x	O
即可	d	O
。	x	O

分解	v	O
的	uj	O
底层	n	O
就是	d	O
剩下	v	O
一对	m	O
[	x	O
]	x	O
或者	c	O
 	x	O
(	x	O
)	x	O
或者	c	O
是	v	O
只	d	O
剩下	v	O
一个	m	O
单	n	O
字符	n	O
就	d	O
停下	v	O
不再	d	O
分解	v	O
。	x	O

当	t	O
剩下	v	O
的	uj	O
是	v	O
一对	m	O
匹配	v	O
的	uj	O
(	x	O
)	x	O
或者	c	O
[	x	O
]	x	O
时	n	O
，	x	O
我们	r	O
不必	d	O
添加	v	O
如何	r	O
括号	n	O
，	x	O
因为	c	O
这	r	O
已经	d	O
匹配	v	O
，	x	O
而	c	O
对于	p	O
只	d	O
剩下	v	O
最后	f	O
一个	m	O
单	n	O
字符	n	O
，	x	O
 	x	O
我们	r	O
需要	v	O
对	p	O
它	r	O
配	v	O
一个	m	O
字符	n	O
，	x	O
使	v	O
它	r	O
配对	v	O
，	x	O
如	v	O
（	x	O
就	d	O
配上	v	O
）	x	O
，	x	O
]	x	O
就	d	O
配上	v	O
[	x	O
，	x	O
依此类推	l	O
。	x	O

	x	O
那么	r	O
这	r	O
题	n	O
的	uj	O
状态	n	O
转移	v	O
方程	n	O
就	d	O
很	d	O
容易	a	O
列出来	v	O
了	ul	O
，	x	O
用	p	O
a	eng	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
表示	v	O
从	p	O
位置	v	O
i	eng	O
到	v	O
位置	v	O
j	eng	O
所	c	O
需要	v	O
插入	v	O
的	uj	O
最小	a	O
字符	n	O
数	n	O
，	x	O
明显	a	O
有	v	O
状态	n	O
转移	v	O
方程	n	O
如下	t	O
：	x	O

	x	O
a	x	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
=	x	O
min	eng	O
(	x	O
a	x	O
[	x	O
i	x	O
,	x	O
k	x	O
]	x	O
+	x	O
a	eng	O
[	x	O
k	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
]	x	O
)	x	O
 	x	O
其中	r	O
i	x	O
<	x	O
=	x	O
k	x	O
<	x	O
j	x	O
；	x	O
这个	r	O
是	v	O
利用	n	O
了	ul	O
定义	n	O
的	uj	O
性质	n	O
（	x	O
3	x	O
）	x	O
，	x	O
枚举	nz	O
K	x	O
，	x	O
尝试	vn	O
所有	b	O
的	uj	O
可能	v	O
分解	v	O
，	x	O
取	v	O
最优	d	O
分解	v	O
；	x	O

	x	O
特别	d	O
的	uj	O
，	x	O
当	t	O
a	eng	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
的	uj	O
首尾	m	O
为	p	O
(	x	O
)	x	O
或者	c	O
[	x	O
]	x	O
时	n	O
，	x	O

	x	O
a	x	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
 	x	O
=	x	O
 	x	O
min	eng	O
(	x	O
a	x	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
-	x	O
1	x	O
]	x	O
,	x	O
tmp	eng	O
)	x	O
 	x	O
其中	r	O
tmp	eng	O
为	p	O
上面	f	O
根据	p	O
性质	n	O
3	x	O
求得	v	O
的	uj	O
最小值	l	O
，	x	O
这	r	O
条	n	O
转移	v	O
是	v	O
利用	n	O
了	ul	O
性质	n	O
2	x	O
。	x	O

	x	O
初始条件	l	O
为	p	O
：	x	O

	x	O
a	x	O
[	x	O
i	x	O
,	x	O
i	x	O
]	x	O
=	x	O
1	x	O
,	x	O
表示	v	O
任意	v	O
一个	m	O
字符	n	O
都	d	O
要	v	O
一个	m	O
对应	vn	O
的	uj	O
字符	n	O
来	v	O
匹配	v	O
；	x	O

	x	O
a	x	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
i	x	O
]	x	O
=	x	O
0.	m	O
这个	r	O
没有	v	O
什么	r	O
实际	n	O
的	uj	O
意义	n	O
，	x	O
只是	c	O
前面	f	O
的	uj	O
分析	vn	O
说	v	O
了	ul	O
，	x	O
当	t	O
剩下	v	O
一对	m	O
(	x	O
)	x	O
或者	c	O
[	x	O
]	x	O
时	n	O
，	x	O
就	d	O
不再	d	O
继续	v	O
往	zg	O
下	f	O
分解	v	O
，	x	O
而	c	O
我们	r	O
为了	p	O
更	d	O
方便	a	O
的	uj	O
组织	v	O
程	n	O
 	x	O
序	n	O
，	x	O
把	p	O
当	t	O
剩下	v	O
一对	m	O
(	x	O
)	x	O
或者	c	O
[	x	O
]	x	O
时	ng	O
还	d	O
继续	v	O
分解	v	O
，	x	O
那么	r	O
,	x	O
举	v	O
例子	n	O
来说	u	O
，	x	O
本来	t	O
序列	n	O
为	p	O
(	x	O
)	x	O
,	x	O
a	x	O
[	x	O
0	x	O
,	x	O
1	x	O
]	x	O
通过	p	O
转移	v	O
变成	v	O
a	x	O
[	x	O
1	x	O
,	x	O
0	x	O
]	x	O
，	x	O
为了	p	O
不	d	O
出错	v	O
，	x	O
所以	c	O
我们	r	O
把	p	O
a	eng	O
[	x	O
i	eng	O
+	x	O
 	x	O
1	x	O
,	x	O
i	x	O
]	x	O
初始化	l	O
为	p	O
0	m	O
，	x	O
这样	r	O
组织	v	O
程序	n	O
起来	v	O
也	d	O
就	d	O
比较	d	O
容易	a	O
了	ul	O
。	x	O

	x	O
到	v	O
这里	r	O
，	x	O
转移	v	O
方程	n	O
就	d	O
结束	v	O
了	ul	O
，	x	O
如果	c	O
这	r	O
题	n	O
只	d	O
让	v	O
你	r	O
求	v	O
最少	d	O
需要	v	O
插入	v	O
的	uj	O
字符	n	O
数	n	O
，	x	O
那么	r	O
这	r	O
题	n	O
就	d	O
结束	v	O
了	ul	O
，	x	O
而	c	O
这	r	O
题	n	O
让	v	O
你	r	O
求	v	O
的	uj	O
是	v	O
包含	v	O
子	ng	O
序列	n	O
的	uj	O
最小	a	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
，	x	O
所以	c	O
我们	r	O
还	d	O
需要	v	O
对	p	O
前面	f	O
的	uj	O
求解	v	O
过程	n	O
进行	v	O
标记	n	O
，	x	O
把	p	O
每次	r	O
求得	v	O
最小值	l	O
所取	v	O
的	uj	O
位置	v	O
都	d	O
记录下来	l	O
，	x	O
然后	c	O
用	p	O
递归	v	O
回溯	v	O
的	uj	O
方法	n	O
去	v	O
求得	v	O
最小	a	O
的	uj	O
regular	eng	O
 	x	O
brackets	eng	O
 	x	O
sequence	eng	O
。	x	O

	x	O
如	v	O
：	x	O
我们	r	O
用	p	O
tag	eng	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
表示	v	O
i	eng	O
到	v	O
j	eng	O
位置	v	O
中	f	O
记录下来	l	O
该	r	O
到	v	O
哪里	r	O
划分	v	O
，	x	O
假设	vn	O
初始化	l	O
为	p	O
-	x	O
1	x	O
，	x	O

	x	O
如果	c	O
a	x	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
选择	v	O
最优	d	O
的	uj	O
时候	n	O
，	x	O
选择	v	O
的	uj	O
是	v	O
a	eng	O
[	x	O
i	x	O
,	x	O
k	x	O
]	x	O
+	x	O
a	eng	O
[	x	O
k	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
]	x	O
,	x	O
那么	r	O
记录	n	O
下	v	O
k	eng	O
的	uj	O
位置	v	O
；	x	O

	x	O
如果	c	O
a	x	O
[	x	O
i	x	O
,	x	O
j	x	O
]	x	O
选择	v	O
的	uj	O
是	v	O
a	eng	O
[	x	O
i	eng	O
+	x	O
1	m	O
,	x	O
j	x	O
-	x	O
1	x	O
]	x	O
的话	u	O
，	x	O
那么	r	O
保持	v	O
初始值	l	O
即可	d	O
。	x	O

	x	O
这样	r	O
再	d	O
根据	p	O
a	x	O
[	x	O
0	x	O
,	x	O
strlen	eng	O
(	x	O
str	eng	O
)	x	O
-	x	O
1	x	O
]	x	O
逐步	d	O
回溯	v	O
。	x	O

这个	r	O
回溯	v	O
就	d	O
不	d	O
讲	v	O
了	ul	O
，	x	O
DP	eng	O
才	d	O
是	v	O
这个	r	O
帖子	n	O
要	v	O
讲	v	O
的	uj	O
，	x	O
回溯	v	B-KNOWLEDGE
以后	f	O
再说	c	O
吧	y	O
。	x	B-KNOWLEDGE

	x	I-KNOWLEDGE
下面	f	O
看下	v	O
我	r	O
实现	v	O
的	uj	O
代码	n	O
吧	y	B-KNOWLEDGE
：	x	I-KNOWLEDGE
）	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
stdio	eng	O
.	m	O
h	eng	O
>	x	O

	x	O
#	x	O
include	eng	O
 	x	O
<	x	O
string	eng	O
.	m	O
h	eng	O
>	x	O

	x	O
int	eng	O
 	x	O
a	x	O
[	x	O
102	m	O
]	x	O
[	x	O
102	m	O
]	x	O
,	x	O
tag	eng	O
[	x	O
102	m	O
]	x	O
[	x	O
102	m	O
]	x	O
;	x	O

	x	O
char	eng	O
 	x	O
str	eng	O
[	x	O
128	m	O
]	x	O
;	x	O

	x	O
void	eng	O
 	x	O
search	eng	O
(	x	O
int	eng	O
 	x	O
st	eng	O
,	x	O
int	eng	O
 	x	O
end	eng	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
if	eng	O
(	x	O
st	eng	O
>	x	O
end	eng	O
)	x	O
 	x	O
return	eng	O
;	x	O

	x	O
 	x	O
else	eng	O
 	x	O
if	eng	O
(	x	O
st	eng	O
=	x	O
=	x	O
end	eng	O
)	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
str	eng	O
[	x	O
st	eng	O
]	x	O
=	x	O
=	x	O
'	x	O
(	x	O
'	x	O
|	x	O
|	x	O
str	eng	O
[	x	O
st	eng	O
]	x	O
=	x	O
=	x	O
'	x	O
)	x	O
'	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
(	x	O
)	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
else	eng	O
 	x	O
printf	eng	O
(	x	O
"	x	O
[	x	O
]	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
}	x	O
else	eng	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
tag	eng	O
[	x	O
st	eng	O
]	x	O
[	x	O
end	eng	O
]	x	O
=	x	O
=	x	O
-	x	O
1	x	O
)	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
str	eng	O
[	x	O
st	eng	O
]	x	O
=	x	O
=	x	O
'	x	O
(	x	O
'	x	O
)	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
(	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
search	eng	O
(	x	O
st	eng	O
+	x	O
1	m	O
,	x	O
end	eng	O
-	x	O
1	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
)	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O
else	eng	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
[	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
search	eng	O
(	x	O
st	eng	O
+	x	O
1	m	O
,	x	O
end	eng	O
-	x	O
1	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
]	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
}	x	O
else	eng	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
search	eng	O
(	x	O
st	eng	O
,	x	O
tag	eng	O
[	x	O
st	eng	O
]	x	O
[	x	O
end	eng	O
]	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
search	eng	O
(	x	O
tag	eng	O
[	x	O
st	eng	O
]	x	O
[	x	O
end	eng	O
]	x	O
+	x	O
1	m	O
,	x	O
end	eng	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
}	x	O

	x	O
}	x	O

	x	O
int	eng	O
 	x	O
main	eng	O
(	x	O
)	x	O

	x	O
{	x	O

	x	O
 	x	O
int	eng	O
 	x	O
len	eng	O
,	x	O
i	x	O
,	x	O
st	eng	O
,	x	O
j	x	O
,	x	O
k	x	O
,	x	O
s	x	O
,	x	O
tmp	eng	O
;	x	O

	x	O
 	x	O
while	eng	O
(	x	O
scanf	eng	O
(	x	O
"	x	O
%	x	O
s	x	O
"	x	O
,	x	O
str	eng	O
)	x	O
!	x	O
=	x	O
EOF	eng	O
)	x	O

	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
len	eng	O
=	x	O
strlen	eng	O
(	x	O
str	eng	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	x	O
<	x	O
len	eng	O
;	x	O
a	x	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
i	x	O
]	x	O
=	x	O
0	x	O
,	x	O
a	x	O
[	x	O
i	x	O
]	x	O
[	x	O
i	x	O
]	x	O
=	x	O
1	x	O
,	x	O
i	eng	O
++	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
st	eng	O
=	x	O
1	x	O
;	x	O
st	eng	O
<	x	O
len	eng	O
;	x	O
st	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
i	x	O
=	x	O
0	x	O
;	x	O
i	eng	O
+	x	O
st	eng	O
<	x	O
len	eng	O
;	x	O
i	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
j	x	O
=	x	O
i	eng	O
+	x	O
st	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
tmp	eng	O
=	x	O
0	m	O
x7fffffff	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
str	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
(	x	O
'	x	O
&&	x	O
str	eng	O
[	x	O
j	x	O
]	x	O
=	x	O
=	x	O
'	x	O
)	x	O
'	x	O
|	x	O
|	x	O
str	eng	O
[	x	O
i	x	O
]	x	O
=	x	O
=	x	O
'	x	O
[	x	O
'	x	O
&&	x	O
str	eng	O
[	x	O
j	x	O
]	x	O
=	x	O
=	x	O
'	x	O
]	x	O
'	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
tmp	eng	O
=	x	O
a	x	O
[	x	O
i	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
-	x	O
1	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
tag	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
-	x	O
1	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
for	eng	O
(	x	O
k	x	O
=	x	O
i	x	O
;	x	O
k	x	O
<	x	O
j	x	O
;	x	O
k	eng	O
++	x	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
{	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
s	x	O
=	x	O
a	x	O
[	x	O
i	x	O
]	x	O
[	x	O
k	x	O
]	x	O
+	x	O
a	eng	O
[	x	O
k	eng	O
+	x	O
1	m	O
]	x	O
[	x	O
j	x	O
]	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
if	eng	O
(	x	O
s	x	O
<	x	O
tmp	eng	O
)	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
tmp	eng	O
=	x	O
s	x	O
,	x	O
tag	eng	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
k	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
 	x	O
a	x	O
[	x	O
i	x	O
]	x	O
[	x	O
j	x	O
]	x	O
=	x	O
tmp	eng	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
 	x	O
}	x	O

	x	O
 	x	O
 	x	O
 	x	O
search	eng	O
(	x	O
0	x	O
,	x	O
len	eng	O
-	x	O
1	x	O
)	x	O
;	x	O

	x	O
 	x	O
 	x	O
 	x	O
printf	eng	O
(	x	O
"	x	O
\	x	O
n	x	O
"	x	O
)	x	O
;	x	O

	x	O
 	x	O
}	x	O

	x	O
 	x	O
return	eng	O
 	x	O
0	x	O
;	x	O

	x	O
}	x	O

	x	O