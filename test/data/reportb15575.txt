pku 2904 The Mailboxes Manufacturers Problem  解题报告_nczhousc的空间_百度空间

/*
pku 2904 The Mailboxes Manufacturers Problem  解题报告-动态规划
http://poj.org/problem?id=2904
  制造商给你1个box和爆竹,爆竹多少没有限制但给定每次试验不能超过M个, 问
box的结实程度。你用M个爆竹炸box,如果没有炸坏,那么你得到结论了。如果炸坏
了 .那么box没有了，你没有得到结论，因为若用比 M 个还少的爆竹也可能炸坏它.
在只有1个盒子的情况下你只能这样试验：
  用1个炸，如果没有扎坏，用2个炸，....
  最多使用 1+2+3+...+M个爆竹试验就可得到结论
  给你2个box,就可以用较少的爆竹试验就可得到结论
  例1. M=10. 你先用5个爆竹炸。
   1 如果炸坏了，你还有1个box，再用
     1+2+3+4 共15个 爆竹试验就可得到结论
   2 如果没炸坏，用8个炸
     1) 炸坏了，再用6个7个 炸
        共 5+8+6+7=26个 爆竹试验就可得到结论
     2) 没炸坏，再用9个，10个炸  
        共 5+8+9+10=32个 爆竹试验就可得到结论
   结论：2个box，M=10，最多32个爆竹试验就可得到结论
         1个box，M=10，最多55个爆竹试验就可得到结论
制造商给你 k (1<=k<=10)个box, 每次实验最多使用m(1..100)个爆竹
问：最多使用多少个爆竹实验知道box的结实程度.
例2. k=2,m=4
1. 用2个爆竹炸 一个box
   1) box被炸坏 ，用 1个爆竹炸另1个box
    结论： 1或2个 爆竹可 炸坏box ,只要使用 3个 爆竹
   2）box没有被炸坏，用3个，4个再实验，共需 2+3+4=9个 爆竹
    结论： 共需 2+3+4=9个 爆竹
2. 用3个爆竹炸 一个box
   1) box被炸坏 ，用 1个，2个爆竹炸另1个box
    结论： 1，2，3个 爆竹可 炸坏box ,只要使用 6个 爆竹
   2）box没有被炸坏，用4个再实验，共需 3+4=7个 爆竹
    结论：共需 3+4=7个 爆竹
  由2 ，k=2,m=4, answer=7   记为c[2][1][4]=7
d[k][n][m]的含义： 给你 k 个box,每次实验最多使用m个爆竹，最少使用
n个爆竹，最多使用d[k][n][m]个爆竹 进行实验，可知box的结实程度。
算法：
 1.d[1][1][m]=1+2+..+m   =sum[m]
   d[1][n][m]=n+n+1+n+2+..+m   = sum[m]-sum[n-1], n<=m<=100
 2.d[k][n][n]=n;d[k][n][n+1]=n+n+1;
   d[k][1][1]=1;
   d[k][n][m]= min{max(s+d[k-1][n][s-1],s+d[k][s+1][m]),n<s<m}
*/
#include<stdio.h>
#include<iostream>
using namespace std;
#include<string.h>
short c[51][1001],d[11][101][101];
void box()
{int i,j,k,m,n,s,t;
 for(i=1;i<=100;i++)d[1][1][i]=d[1][1][i-1]+i;
 for(i=2;i<=100;i++)
 for(j=1;j<=i;j++)d[1][j][i]=d[1][1][i]-d[1][1][j-1];
 for(k=2;k<=10;k++)
   {d[k][1][1]=1;
    for(m=100;m>1;m--)
    { d[k][m][m]=m;d[k][m-1][m]=m-1+m;
     for(n=m-2;n>=1;n--)  //d[k][1][3]
     { //d[k][n][m]    n s m
       s=n+1;
       d[k][n][m]=max(d[k-1][n][s-1],d[k][s+1][m])+s;
       for(s=n+2;s<m;s++)
       {
         t=max(d[k-1][n][s-1],d[k][s+1][m])+s;
         if(d[k][n][m]>t)d[k][n][m]=t;                 
       }
     }
    }//for m
   }
}
int main()
{int k,m,T,ca;
 box();
  scanf("%d",&T);
 for(ca=1;ca<=T;ca++)
 { 
   scanf("%d%d",&k,&m);
   printf("%d\n",d[k][1][m]);
  }
}
/*
2904
Sample Input
5
1 10
1 100
3 73
5 100
10 100
Sample Output  box
55
5050
382
495
479
*/
