栈可是一个好东西啊pku3044_苏航的空间_百度空间

比较好的栈类型题目。

值得纪念！

题目大意： 给我们一个由一些矩形构造出来的图，我们需要找到最少矩形的块数来覆盖它。acm.pku.edu.cn/JudgeOnline/problem

解题思路：

首先可以肯定如果有两块矩形是连在一起的，那么肯定是用低的那块矩形的高去覆盖，然后再去覆盖高的那块矩形, 所以横坐标是没有关系的，只会受到矩形高度的影响。但是如果直接这样贪心，会出现这种情况：1、2、1，这样做的时候1与2用1先覆盖，但是之后这个1是不需要多余的矩形来覆盖的。所以可以用到栈来处理这个东西。首先我要保证栈是单调上升的。当前插入一个h[i]高度的矩形，也就是在栈中插入h[i]。如果小于栈顶元素那么踢掉栈顶元素，答案累加1，知道大于等于栈顶元素为止。因为在你加入这个h[i]的时候如果它前面的矩形高于它肯定 要竖着去覆盖那个矩形了。最后再累加栈中元素即可！ 

代码：


C++语言: 
Codee#883001 #include <cstdio>

02 

03 const int maxn=50123;

04 

05 int stack[maxn],tot,n,w,h[maxn];

06 

07 int main()

08 {

09     freopen("p3044.in","r",stdin);

10     freopen("p3044.out","w",stdout);

11     

12     

13     int ans=0;tot=0;stack[0]=0;

14     scanf("%d%d",&n,&w);

15     for (int i=1;i<=n;i++)

16     {

17         int x,y;

18         scanf("%d%d",&x,&y);

19         h[i]=y;

20     }

21     h[n+1]=0;

22     for (int i=1;i<=n+1;i++)

23     {

24         while (h[i]<stack[tot] && tot>0)

25         {

26             tot--;

27             ans++;

28         }

29         if (h[i]!=stack[tot])

30         {

31             tot++;

32             stack[tot]=h[i];

33         }

34     }

35     printf("%d\n",ans);

36     

37     return 0;

38 }